### Directory structure:
/Users/rizzytwizzy/prod/cxmpute-core
temp.md
pnpm-lock.yaml
middleware.ts
.DS_Store
auth
auth/subjects.ts
auth/index.ts
all_code.txt
contracts
contracts/test
contracts/test/Lock.ts
contracts/all_code.txt
contracts/contracts
contracts/contracts/SynthFactory.sol
contracts/contracts/Lock.sol
contracts/contracts/CXPTToken.sol
contracts/contracts/Vault.sol
contracts/contracts/SynthERC20.sol
contracts/envexample.txt
contracts/README.md
contracts/package-lock.json
contracts/package.json
contracts/ignition
contracts/ignition/modules
contracts/ignition/modules/Lock.ts
contracts/.env
contracts/scripts
contracts/scripts/deploy.ts
contracts/tsconfig.json
contracts/hardhat.config.ts
sst.config.ts
sst-env.d.ts
docs
docs/trade.md
next-env.d.ts
README.md
public
public/.DS_Store
public/images
public/images/mistral.png
public/images/deepseek.png
public/images/github-circle.svg
public/images/server.png
public/images/shield.png
public/images/8.png
public/images/file.svg
public/images/dolphinhero.png
public/images/brain-electricity.svg
public/images/x.svg
public/images/ibm.png
public/images/code.svg
public/images/meta.png
public/images/vercel.svg
public/images/youtube.svg
public/images/reddit.png
public/images/servercloud.png
public/images/computer.png
public/images/unlock.png
public/images/7.png
public/images/discord.svg
public/images/6.png
public/images/google.png
public/images/window.svg
public/images/3.png
public/images/qwen.png
public/images/1.png
.gitignore
package-lock.json
package.json
.env
dex
dex/streams
dex/streams/ordersStreamRouter.ts
dex/chain
dex/chain/vaultHelper.ts
dex/matchers
dex/matchers/marketRegistry.ts
dex/matchers/perps.ts
dex/matchers/matchEngine.ts
dex/matchers/futures.ts
dex/matchers/market.ts
dex/matchers/options.ts
dex/ws
dex/ws/fanOut.ts
dex/ws/disconnect.ts
dex/ws/default.ts
dex/ws/connect.ts
dex/ws/subscribe.ts
dex/cron
dex/cron/optionExpiry.ts
dex/cron/futureExpiry.ts
dex/cron/oracle.ts
dex/cron/perpsDailySettle.ts
dex/cron/metricsRollup.ts
dex/cron/funding.ts
tsconfig.json
.open-next
.open-next/.build
.open-next/.build/middleware.mjs
.open-next/.build/cache.cjs
.open-next/.build/open-next.config.mjs
.open-next/warmer-function
.open-next/warmer-function/index.mjs
.open-next/warmer-function/open-next.config.mjs
.open-next/cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/docs.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/favicon.ico.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/roadmap.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/favicon.ico
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/roadmap
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/docs
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/101.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/dashboard
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/services.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/101
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/download
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/_not-found.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/index.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/_not-found
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/maximize.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/maximize
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/500.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/dashboard.cache
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/services
.open-next/cache/c9ft-WjqKtyF6XMyrXjBI/download.cache
.open-next/dynamodb-provider
.open-next/dynamodb-provider/resource.enc
.open-next/dynamodb-provider/dynamodb-cache.json
.open-next/dynamodb-provider/index.mjs
.open-next/dynamodb-provider/open-next.config.mjs
.open-next/image-optimization-function
.open-next/image-optimization-function/resource.enc
.open-next/image-optimization-function/index.mjs
.open-next/image-optimization-function/open-next.config.mjs
.open-next/server-functions
.open-next/server-functions/default
.open-next/server-functions/default/resource.enc
.open-next/server-functions/default/patchedAsyncStorage.cjs
.open-next/server-functions/default/middleware.mjs
.open-next/server-functions/default/package.json
.open-next/server-functions/default/index.mjs
.open-next/server-functions/default/cache.cjs
.open-next/server-functions/default/open-next.config.mjs
.open-next/open-next.output.json
.open-next/revalidation-function
.open-next/revalidation-function/resource.enc
.open-next/revalidation-function/index.mjs
.open-next/revalidation-function/prerender-manifest.json
.open-next/revalidation-function/open-next.config.mjs
.open-next/assets
.open-next/assets/_next
.open-next/assets/_next/static
.open-next/assets/_next/static/c9ft-WjqKtyF6XMyrXjBI
.open-next/assets/_next/static/c9ft-WjqKtyF6XMyrXjBI/_ssgManifest.js
.open-next/assets/_next/static/c9ft-WjqKtyF6XMyrXjBI/_buildManifest.js
.open-next/assets/_next/static/css
.open-next/assets/_next/static/css/d757f2db635a9663.css
.open-next/assets/_next/static/css/3efeb2a0fee35da0.css
.open-next/assets/_next/static/chunks
.open-next/assets/_next/static/chunks/main-7f3c3e2fe057f498.js
.open-next/assets/_next/static/chunks/461-fa20059e5d9a1829.js
.open-next/assets/_next/static/chunks/app
.open-next/assets/_next/static/chunks/app/page-3f426a90af1897f5.js
.open-next/assets/_next/static/chunks/app/layout-b539d98f2857a2fe.js
.open-next/assets/_next/static/chunks/app/roadmap
.open-next/assets/_next/static/chunks/app/roadmap/page-1e5d6cefe0237f11.js
.open-next/assets/_next/static/chunks/app/docs
.open-next/assets/_next/static/chunks/app/docs/page-e08983e6349d9462.js
.open-next/assets/_next/static/chunks/app/dashboard
.open-next/assets/_next/static/chunks/app/dashboard/page-f0dca95a5a890101.js
.open-next/assets/_next/static/chunks/app/101
.open-next/assets/_next/static/chunks/app/101/page-b12b2523371db34f.js
.open-next/assets/_next/static/chunks/app/download
.open-next/assets/_next/static/chunks/app/download/page-dfd92fd481bedf94.js
.open-next/assets/_next/static/chunks/app/_not-found
.open-next/assets/_next/static/chunks/app/_not-found/page-cccc916a6a10f0af.js
.open-next/assets/_next/static/chunks/app/maximize
.open-next/assets/_next/static/chunks/app/maximize/page-82a7a50aa6445800.js
.open-next/assets/_next/static/chunks/app/services
.open-next/assets/_next/static/chunks/app/services/page-d212e5a1f14522a7.js
.open-next/assets/_next/static/chunks/587-ae0bb185f08a1619.js
.open-next/assets/_next/static/chunks/4bd1b696-2c1bcb2abe1c6987.js
.open-next/assets/_next/static/chunks/main-app-d8d5ef49d759193f.js
.open-next/assets/_next/static/chunks/framework-d626bb57a450c627.js
.open-next/assets/_next/static/chunks/webpack-d567642bc65e0559.js
.open-next/assets/_next/static/chunks/pages
.open-next/assets/_next/static/chunks/pages/_error-5933f280f2bada68.js
.open-next/assets/_next/static/chunks/pages/_app-eef484fc49b57a90.js
.open-next/assets/_next/static/chunks/polyfills-42372ed130431b0a.js
.open-next/assets/_next/static/media
.open-next/assets/_next/static/media/47cbc4e2adbc5db9-s.p.woff2
.open-next/assets/_next/static/media/b5ee789b512e4d1b-s.woff2
.open-next/assets/_next/static/media/c21b67b0a36892e5-s.woff2
.open-next/assets/_next/static/media/ba015fad6dcf6784-s.woff2
.open-next/assets/_next/static/media/ac3b7908202f8517-s.woff2
.open-next/assets/_next/static/media/369c6e283c5acc6e-s.woff2
.open-next/assets/_next/static/media/2c07349e02a7b712-s.woff2
.open-next/assets/_next/static/media/92f44bb82993d879-s.p.woff2
.open-next/assets/_next/static/media/90da053edc2b7de3-s.woff2
.open-next/assets/_next/static/media/747892c23ea88013-s.woff2
.open-next/assets/_next/static/media/24c15609eaa28576-s.woff2
.open-next/assets/_next/static/media/627d916fd739a539-s.woff2
.open-next/assets/_next/static/media/b2f7755ffc613443-s.woff2
.open-next/assets/_next/static/media/74c003a2abab0c4f-s.woff2
.open-next/assets/_next/static/media/569ce4b8f30dc480-s.p.woff2
.open-next/assets/_next/static/media/84602850c8fd81c3-s.woff2
.open-next/assets/_next/static/media/93f479601ee12b01-s.p.woff2
.open-next/assets/_next/static/media/c5a3bf8cfa32037a-s.woff2
.open-next/assets/_next/static/media/ffff0c425fbeefe6-s.woff2
.open-next/assets/favicon.ico
.open-next/assets/.DS_Store
.open-next/assets/images
.open-next/assets/images/github-circle.svg
.open-next/assets/images/server.png
.open-next/assets/images/shield.png
.open-next/assets/images/8.png
.open-next/assets/images/file.svg
.open-next/assets/images/dolphinhero.png
.open-next/assets/images/brain-electricity.svg
.open-next/assets/images/x.svg
.open-next/assets/images/code.svg
.open-next/assets/images/vercel.svg
.open-next/assets/images/youtube.svg
.open-next/assets/images/reddit.png
.open-next/assets/images/servercloud.png
.open-next/assets/images/computer.png
.open-next/assets/images/unlock.png
.open-next/assets/images/7.png
.open-next/assets/images/discord.svg
.open-next/assets/images/6.png
.open-next/assets/images/window.svg
.open-next/assets/images/3.png
.open-next/assets/images/1.png
.open-next/assets/BUILD_ID
eslint.config.mjs
next.config.ts
src
src/app
src/app/favicon.ico
src/app/roadmap
src/app/roadmap/page.module.css
src/app/roadmap/page.tsx
src/app/provider
src/app/user
src/app/user/user.module.css
src/app/user/page.tsx
src/app/models
src/app/models/models.module.css
src/app/models/page.tsx
src/app/models/[slug]
src/app/models/[slug]/page.module.css
src/app/models/[slug]/page.tsx
src/app/page.module.css
src/app/docs
src/app/docs/page.module.css
src/app/docs/page.tsx
src/app/dashboard
src/app/dashboard/dashboard.module.css
src/app/dashboard/page.tsx
src/app/101
src/app/101/101.module.css
src/app/101/page.tsx
src/app/actions.ts
src/app/download
src/app/download/page.module.css
src/app/download/page.tsx
src/app/layout.tsx
src/app/c3d
src/app/c3d/threejs
src/app/c3d/threejs/threejs.module.css
src/app/c3d/threejs/page.tsx
src/app/api
src/app/api/v1
src/app/api/v1/video
src/app/api/v1/video/route.ts
src/app/api/v1/embeddings
src/app/api/v1/embeddings/route.ts
src/app/api/v1/chat
src/app/api/v1/chat/completions
src/app/api/v1/chat/completions/route.ts
src/app/api/v1/trade
src/app/api/v1/trade/route.ts
src/app/api/v1/providers
src/app/api/v1/providers/delete
src/app/api/v1/providers/delete/route.ts
src/app/api/v1/providers/start
src/app/api/v1/providers/start/route.ts
src/app/api/v1/providers/start/callback
src/app/api/v1/providers/start/callback/route.ts
src/app/api/v1/providers/end
src/app/api/v1/providers/end/route.ts
src/app/api/v1/providers/new
src/app/api/v1/providers/new/route.ts
src/app/api/v1/scrape
src/app/api/v1/scrape/route.ts
src/app/api/v1/image
src/app/api/v1/image/route.ts
src/app/api/v1/tts
src/app/api/v1/tts/route.ts
src/app/api/v1/m
src/app/api/v1/m/detect
src/app/api/v1/m/detect/route.ts
src/app/api/v1/m/caption
src/app/api/v1/m/caption/route.ts
src/app/api/v1/m/point
src/app/api/v1/m/point/route.ts
src/app/api/v1/m/query
src/app/api/v1/m/query/route.ts
src/app/api/paper
src/app/api/paper/faucet
src/app/api/paper/faucet/route.ts
src/app/api/metrics
src/app/api/metrics/route.ts
src/app/api/iterate
src/app/api/iterate/route.ts
src/app/api/example
src/app/api/example/route.ts
src/app/api/providers
src/app/api/providers/signup
src/app/api/providers/signup/route.ts
src/app/api/providers/[providerId]
src/app/api/providers/[providerId]/ak
src/app/api/providers/[providerId]/ak/reset
src/app/api/providers/[providerId]/ak/reset/route.ts
src/app/api/providers/[providerId]/ak/route.ts
src/app/api/providers/[providerId]/[provisionId]
src/app/api/providers/[providerId]/[provisionId]/rerun
src/app/api/providers/[providerId]/[provisionId]/rerun/route.ts
src/app/api/providers/[providerId]/[provisionId]/route.ts
src/app/api/providers/[providerId]/providerAk
src/app/api/providers/[providerId]/providerAk/refresh
src/app/api/providers/[providerId]/providerAk/refresh/route.ts
src/app/api/providers/[providerId]/route.ts
src/app/api/providers/[providerId]/earnings
src/app/api/providers/[providerId]/earnings/route.ts
src/app/api/providers/login
src/app/api/providers/login/route.ts
src/app/api/admin
src/app/api/admin/fees
src/app/api/admin/fees/route.ts
src/app/api/admin/markets
src/app/api/admin/markets/route.ts
src/app/api/user
src/app/api/user/[userId]
src/app/api/user/[userId]/userAk
src/app/api/user/[userId]/userAk/refresh
src/app/api/user/[userId]/userAk/refresh/route.ts
src/app/api/user/[userId]/keys
src/app/api/user/[userId]/keys/[key]
src/app/api/user/[userId]/keys/[key]/route.ts
src/app/api/user/[userId]/keys/route.ts
src/app/api/user/[userId]/summary
src/app/api/user/[userId]/summary/route.ts
src/app/api/positions
src/app/api/positions/route.ts
src/app/api/callback
src/app/api/callback/route.ts
src/app/api/orders
src/app/api/orders/[orderId]
src/app/api/orders/[orderId]/route.ts
src/app/api/orders/route.ts
src/app/api/vault
src/app/api/vault/deposit
src/app/api/vault/deposit/route.ts
src/app/api/vault/withdraw
src/app/api/vault/withdraw/route.ts
src/app/maximize
src/app/maximize/page.module.css
src/app/maximize/page.tsx
src/app/page.tsx
src/app/globals.css
src/app/services
src/app/services/page.module.css
src/app/services/page.tsx
src/app/auth.ts
src/components
src/components/dashboard
src/components/dashboard/Dashboard.tsx
src/components/dashboard/dashboard.module.css
src/components/map
src/components/map/map.tsx
src/components/map/mapstring.js
src/components/map/map.module.css
src/components/button
src/components/button/button.module.css
src/components/button/button.tsx
src/components/faqCard
src/components/faqCard/faqCard.tsx
src/components/faqCard/faqCard.module.css
src/lib
src/lib/genSchemaCad.ts
src/lib/utils.ts
src/lib/genSchema.ts
src/lib/references.ts
src/lib/openapi.yaml
src/lib/privateutils.ts
src/lib/auth.ts
src/lib/interfaces.ts

### File: middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

// Define allowed paths under /trade to prevent infinite rewrites
const ALLOWED_TRADE_PATHS = [
  "/", // maps to /trade
  "/about",
  "/contact",
  "/products",
];

export function middleware(request: NextRequest) {
  const host = request.headers.get("host");
  const url = request.nextUrl.clone();

  const isTradeSubdomain = host?.startsWith("trade.");

  if (isTradeSubdomain) {
    const originalPath = url.pathname;

    // Rewrite all trade.example.com/* to /trade/*
    if (!originalPath.startsWith("/trade")) {
      url.pathname =
        originalPath === "/" ? "/trade" : `/trade${originalPath}`;
      return NextResponse.rewrite(url);
    }

    // Optional: Redirect if not a known path
    const rewrittenPath = url.pathname.replace(/^\/trade/, "");
    if (
      rewrittenPath &&
      !ALLOWED_TRADE_PATHS.includes(rewrittenPath) &&
      !rewrittenPath.startsWith("/api") // allow API calls if needed
    ) {
      url.hostname = "example.com";
      url.pathname = originalPath;
      return NextResponse.redirect(url);
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/((?!_next|static|favicon.ico).*)"],
};
### File: auth/subjects.ts
import { object, string, array, boolean } from "valibot";
import { createSubjects } from "@openauthjs/openauth/subject";

/** OpenAuth subject schema.  Everything returned in `ctx.subject()` MUST
 *  validate against this exactly. */
export const subjects = createSubjects({
  user: object({
    id:          string(),        // User ID
    providerId:  string(),        // Links back to ProviderTable
    providerAk:  string(),        // Same AK we stored on the provider
    userAks:     array(string()), // Future per-app AKs (can be empty)
    userAk:  string(),        // User's API key (for this app)
    admin: boolean(),        // Is this user an admin?
    email: string(),
  }),
});
### File: auth/index.ts
import { handle } from "hono/aws-lambda";
import { issuer } from "@openauthjs/openauth";
import { CodeProvider } from "@openauthjs/openauth/provider/code";
import { CodeUI } from "@openauthjs/openauth/ui/code";
import { MemoryStorage } from "@openauthjs/openauth/storage/memory";
import { v4 as uuidv4 } from "uuid";
import { THEME_OPENAUTH } from "@openauthjs/openauth/ui/theme"

import {
  DynamoDBDocumentClient,
  QueryCommand,
  PutCommand,
  ScanCommand,
} from "@aws-sdk/lib-dynamodb";

import { DynamoDBClient } from "@aws-sdk/client-dynamodb";

import {
  SESv2Client,
  SendEmailCommand,
} from "@aws-sdk/client-sesv2";

import { Resource } from "sst";
import { subjects } from "./subjects";
import { ADMIN_EMAILS } from "@/lib/privateutils";

THEME_OPENAUTH.favicon = "https://i.postimg.cc/bNLm9f7T/3.png"
THEME_OPENAUTH.logo = "https://i.postimg.cc/6qhxh1Kv/8.png"
// THEME_OPENAUTH.logo = "https://i.postimg.cc/yNdZ0wFw/6.png"
THEME_OPENAUTH.title = "cxmpute.cloud - login"
THEME_OPENAUTH.background = 'white'
THEME_OPENAUTH.primary = 'black'



/* ——————————————————————————————————— */
/* Dynamo helpers                                                           */
/* ——————————————————————————————————— */

const ddbDoc = DynamoDBDocumentClient.from(new DynamoDBClient({}));

const PROVIDER_TABLE = Resource.ProviderTable.name;
const USER_TABLE     = Resource.UserTable.name;

/**
 * Find (or create) Provider & User rows for the given e-mail.
 * - Provider is looked-up via the GSI  “ByEmail”.
 * - User is scanned by providerId (tiny data-set → acceptable; add GSI if it grows).
 * Returns a complete subject for OpenAuth.
 */
async function ensureUser(email: string): Promise<{
  userId: string;
  providerId: string;
  userAks: string[];
  providerAk: string;
  userAk: string;
  }> {
  /* ➜ 1. Provider */
  const provRes = await ddbDoc.send(
    new QueryCommand({
      TableName: PROVIDER_TABLE,
      IndexName: "ByEmail",
      KeyConditionExpression: "providerEmail = :e",
      ExpressionAttributeValues: { ":e": email },
      Limit: 1,
    }),
  );

  let providerId: string;
  let providerAk: string;

  if (provRes.Items?.length) {
    providerId = provRes.Items[0].providerId as string;
    providerAk = provRes.Items[0].apiKey     as string;
  } else {
    providerId = uuidv4().replace(/-/g, "");
    providerAk = uuidv4().replace(/-/g, "");

    await ddbDoc.send(
      new PutCommand({
        TableName: PROVIDER_TABLE,
        Item: {
          providerId,
          providerEmail: email,
          apiKey: providerAk,
        },
      }),
    );
  }

  /* ➜ 2. User */
  const userScan = await ddbDoc.send(
    new ScanCommand({
      TableName: USER_TABLE,
      FilterExpression: "providerId = :pid",
      ExpressionAttributeValues: { ":pid": providerId },
      Limit: 1,
    }),
  );

  let userId: string;
  let userAks: string[];
  let userAk: string;

  if (userScan.Items?.length) {
    const u = userScan.Items[0];
    userId  = u.userId  as string;
    userAks = (u.userAks as string[]) ?? [];
    userAk = u.userAk as string;
  } else {
    userId  = uuidv4().replace(/-/g, "");
    userAks = [];
    userAk  = uuidv4().replace(/-/g, "");

    await ddbDoc.send(
      new PutCommand({
        TableName: USER_TABLE,
        Item: {
          userId,
          providerId,
          userAks,
          providerAk,
          userAk,
        },
      }),
    );
  }

  return { userId, providerId, userAks, providerAk, userAk };
}

/* ——————————————————————————————————— */
/* Mailer – uses the linked SES identity                                    */
/* ——————————————————————————————————— */

const ses = new SESv2Client();

async function sendLoginCode(claims: Record<string, string>, code: string) {
  console.log("Sending login code to", claims.email);
  console.log("Code:", code);
  console.log("Claims:", claims);
  const email = claims.email;
  await ses.send(
    new SendEmailCommand({
      FromEmailAddress: `noreply@${Resource.AuthEmail.sender}`,
      Destination: { ToAddresses: [email] },
      Content: {
        Simple: {
          Subject: { Data: "Your Cxmpute login code" },
          Body: {
            Text: {
              Data: `Here is your one-time code: ${code}\n\n` +
                    `If you did not request this, simply ignore the email.`,
            },
          },
        },
      },
    }),
  );
}

/* ——————————————————————————————————— */
/* OpenAuth issuer                                                          */
/* ——————————————————————————————————— */

const app = issuer({
  theme: THEME_OPENAUTH,
  subjects,
  storage: MemoryStorage(),

  // dev-only; lock this down in prod
  allow: async () => true,

  providers: {
    code: CodeProvider(
      CodeUI({
        sendCode: sendLoginCode,
      }),
    ),
  },

  success: async (ctx, value) => {
    if (value.provider !== "code") throw new Error("Invalid provider");

    const { userId, providerId, userAks, providerAk, userAk } =
      await ensureUser(value.claims.email);

    return ctx.subject("user", {
      id:          userId,
      providerId,
      userAks,
      providerAk,
      userAk,
      admin: ADMIN_EMAILS.includes(value.claims.email),
      email: value.claims.email,
    });
  },
});

/* Lambda entry-point for SST */
export const handler = handle(app);
### File: contracts/test/Lock.ts
import {
  time,
  loadFixture,
} from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import { expect } from "chai";
import hre from "hardhat";

describe("Lock", function () {
  // We define a fixture to reuse the same setup in every test.
  // We use loadFixture to run this setup once, snapshot that state,
  // and reset Hardhat Network to that snapshot in every test.
  async function deployOneYearLockFixture() {
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    const ONE_GWEI = 1_000_000_000;

    const lockedAmount = ONE_GWEI;
    const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

    // Contracts are deployed using the first signer/account by default
    const [owner, otherAccount] = await hre.ethers.getSigners();

    const Lock = await hre.ethers.getContractFactory("Lock");
    const lock = await Lock.deploy(unlockTime, { value: lockedAmount });

    return { lock, unlockTime, lockedAmount, owner, otherAccount };
  }

  describe("Deployment", function () {
    it("Should set the right unlockTime", async function () {
      const { lock, unlockTime } = await loadFixture(deployOneYearLockFixture);

      expect(await lock.unlockTime()).to.equal(unlockTime);
    });

    it("Should set the right owner", async function () {
      const { lock, owner } = await loadFixture(deployOneYearLockFixture);

      expect(await lock.owner()).to.equal(owner.address);
    });

    it("Should receive and store the funds to lock", async function () {
      const { lock, lockedAmount } = await loadFixture(
        deployOneYearLockFixture
      );

      expect(await hre.ethers.provider.getBalance(lock.target)).to.equal(
        lockedAmount
      );
    });

    it("Should fail if the unlockTime is not in the future", async function () {
      // We don't use the fixture here because we want a different deployment
      const latestTime = await time.latest();
      const Lock = await hre.ethers.getContractFactory("Lock");
      await expect(Lock.deploy(latestTime, { value: 1 })).to.be.revertedWith(
        "Unlock time should be in the future"
      );
    });
  });

  describe("Withdrawals", function () {
    describe("Validations", function () {
      it("Should revert with the right error if called too soon", async function () {
        const { lock } = await loadFixture(deployOneYearLockFixture);

        await expect(lock.withdraw()).to.be.revertedWith(
          "You can't withdraw yet"
        );
      });

      it("Should revert with the right error if called from another account", async function () {
        const { lock, unlockTime, otherAccount } = await loadFixture(
          deployOneYearLockFixture
        );

        // We can increase the time in Hardhat Network
        await time.increaseTo(unlockTime);

        // We use lock.connect() to send a transaction from another account
        await expect(lock.connect(otherAccount).withdraw()).to.be.revertedWith(
          "You aren't the owner"
        );
      });

      it("Shouldn't fail if the unlockTime has arrived and the owner calls it", async function () {
        const { lock, unlockTime } = await loadFixture(
          deployOneYearLockFixture
        );

        // Transactions are sent using the first signer by default
        await time.increaseTo(unlockTime);

        await expect(lock.withdraw()).not.to.be.reverted;
      });
    });

    describe("Events", function () {
      it("Should emit an event on withdrawals", async function () {
        const { lock, unlockTime, lockedAmount } = await loadFixture(
          deployOneYearLockFixture
        );

        await time.increaseTo(unlockTime);

        await expect(lock.withdraw())
          .to.emit(lock, "Withdrawal")
          .withArgs(lockedAmount, anyValue); // We accept any value as `when` arg
      });
    });

    describe("Transfers", function () {
      it("Should transfer the funds to the owner", async function () {
        const { lock, unlockTime, lockedAmount, owner } = await loadFixture(
          deployOneYearLockFixture
        );

        await time.increaseTo(unlockTime);

        await expect(lock.withdraw()).to.changeEtherBalances(
          [owner, lock],
          [lockedAmount, -lockedAmount]
        );
      });
    });
  });
});

### File: contracts/contracts/SynthFactory.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./SynthERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SynthFactory is Ownable {
    event SynthCreated(address indexed synth, string name, string symbol);

    address public immutable vault;

    constructor(address _vault) {
        vault = _vault;
    }

    function createSynth(
        string calldata name,
        string calldata symbol
    ) external onlyOwner returns (address synth) {
        // Simple CREATE2 gives deterministic addresses if you ever need them
        bytes32 salt = keccak256(abi.encodePacked(symbol));
        synth = address(new SynthERC20{salt: salt}(name, symbol, vault));

        emit SynthCreated(synth, name, symbol);
    }
}
### File: contracts/contracts/Lock.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

// Uncomment this line to use console.log
// import "hardhat/console.sol";

contract Lock {
    uint public unlockTime;
    address payable public owner;

    event Withdrawal(uint amount, uint when);

    constructor(uint _unlockTime) payable {
        require(
            block.timestamp < _unlockTime,
            "Unlock time should be in the future"
        );

        unlockTime = _unlockTime;
        owner = payable(msg.sender);
    }

    function withdraw() public {
        // Uncomment this line, and the import of "hardhat/console.sol", to print a log in your terminal
        // console.log("Unlock time is %o and block timestamp is %o", unlockTime, block.timestamp);

        require(block.timestamp >= unlockTime, "You can't withdraw yet");
        require(msg.sender == owner, "You aren't the owner");

        emit Withdrawal(address(this).balance, block.timestamp);

        owner.transfer(address(this).balance);
    }
}

### File: contracts/contracts/CXPTToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * Governance / rebate token – minted 1 : 1 when users withdraw
 * “asCxpt = true”.  Vault is the sole minter.
 */
contract CXPTToken is ERC20, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(address vault) ERC20("CXMpute Token", "CXPT") {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, vault);
    }

    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
        _mint(to, amount);
    }
}
### File: contracts/contracts/Vault.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./SynthERC20.sol";
import "./CXPTToken.sol";

/**
 * @title Vault Contract for CXMPUTE DEX
 * @notice Holds 100% USDC collateral, manages user shares, tracks collected fees,
 *         and facilitates synth/CXPT minting/burning via role-based access.
 * @dev Uses AccessControl for roles (ADMIN, CORE, GATEWAY).
 *      GATEWAY role handles deposits/withdrawals.
 *      CORE role (matcher) handles synth minting/burning and fee recording.
 *      ADMIN role handles fee withdrawals and synth registration.
 */
contract Vault is AccessControlEnumerable, ReentrancyGuard {

    // --- Roles ---
    bytes32 public constant CORE_ROLE    = keccak256("CORE_ROLE");
    bytes32 public constant ADMIN_ROLE   = keccak256("ADMIN_ROLE");
    bytes32 public constant GATEWAY_ROLE = keccak256("GATEWAY_ROLE");

    // --- State Variables ---
    IERC20 public immutable usdc;
    CXPTToken public immutable cxpt;

    mapping(address => uint256) public shares;      // user => shares (1:1 USDC)
    mapping(address => bool) public isSynth;        // synth address => registered?

    uint256 public collectedFees; // <<< NEW: Tracks accumulated USDC fees (in base units)

    // --- Events ---
    event Deposited(address indexed gateway, address indexed user, uint256 amount);
    event Withdrawn(address indexed gateway, address indexed user, uint256 amount, bool asCxpt);
    event SynthRegistered(address indexed admin, address indexed synth);
    event SynthMinted(address indexed core, address indexed synth, address indexed to, uint256 amount);
    event SynthBurned(address indexed core, address indexed synth, address indexed from, uint256 amount);
    event FeesRecorded(address indexed core, uint256 amount); // <<< NEW: Event for fee recording
    event FeesWithdrawn(address indexed admin, address indexed to, uint256 amount);

    // --- Errors ---
    error Vault__ZeroAddress();
    error Vault__ZeroAmount();
    error Vault__InsufficientBalance();
    error Vault__InsufficientFees(); // <<< NEW: Error for insufficient fees
    error Vault__TransferFailed(string reason);
    error Vault__UnknownSynth();
    error Vault__AlreadyRegistered();

    // --- Constructor ---
    constructor(
        address _usdc,
        address _cxpt,
        address _coreAddress,
        address _gatewayAddress
    ) {
        if (_usdc == address(0) || _cxpt == address(0) || _coreAddress == address(0) || _gatewayAddress == address(0)) {
            revert Vault__ZeroAddress();
        }
        usdc = IERC20(_usdc);
        cxpt = CXPTToken(_cxpt);

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
        _grantRole(CORE_ROLE, _coreAddress);
        _grantRole(GATEWAY_ROLE, _gatewayAddress);
    }

    // --- Admin Functions ---

    function registerSynth(address synth) external onlyRole(ADMIN_ROLE) {
        if (synth == address(0)) revert Vault__ZeroAddress();
        if (isSynth[synth]) revert Vault__AlreadyRegistered();
        isSynth[synth] = true;
        emit SynthRegistered(msg.sender, synth);
    }

    /**
     * @notice Admin function to withdraw accumulated protocol fees.
     * @dev Checks against the on-chain `collectedFees` balance.
     * @param to The address to receive the fees.
     * @param amt The amount of USDC fees (in base units) to withdraw.
     */
    function withdrawFees(address to, uint256 amt) external onlyRole(ADMIN_ROLE) nonReentrant {
        if (to == address(0)) revert Vault__ZeroAddress();
        if (amt == 0) revert Vault__ZeroAmount();

        uint256 currentCollectedFees = collectedFees; // Gas optimization
        if (currentCollectedFees < amt) revert Vault__InsufficientFees(); // <<< CHECK collectedFees

        uint256 vaultUsdcBalance = usdc.balanceOf(address(this));
        if (vaultUsdcBalance < amt) revert Vault__InsufficientBalance(); // Still need vault balance check

        collectedFees = currentCollectedFees - amt; // <<< DECREMENT collectedFees

        bool success = usdc.transfer(to, amt);
        if (!success) {
            // Revert state change if transfer fails
            collectedFees = currentCollectedFees;
            revert Vault__TransferFailed("USDC fee transfer failed");
        }

        emit FeesWithdrawn(msg.sender, to, amt);
    }


    // --- Gateway Functions (Deposit/Withdraw) ---
    // (deposit and withdraw functions remain the same as previous revision)

    function deposit(address user, uint256 amt) external onlyRole(GATEWAY_ROLE) nonReentrant {
        if (user == address(0)) revert Vault__ZeroAddress();
        if (amt == 0) revert Vault__ZeroAmount();
        bool success = usdc.transferFrom(user, address(this), amt);
        if (!success) revert Vault__TransferFailed("USDC transferFrom failed");
        shares[user] += amt;
        emit Deposited(msg.sender, user, amt);
    }

    function withdraw(address user, uint256 amt, bool asCxpt) external onlyRole(GATEWAY_ROLE) nonReentrant {
        if (user == address(0)) revert Vault__ZeroAddress();
        if (amt == 0) revert Vault__ZeroAmount();
        uint256 userShares = shares[user]; // Gas optimization
        if (userShares < amt) revert Vault__InsufficientBalance();

        shares[user] = userShares - amt;

        if (asCxpt) {
            cxpt.mint(user, amt);
        } else {
            bool success = usdc.transfer(user, amt);
            if (!success) {
                shares[user] = userShares; // Revert share decrement
                revert Vault__TransferFailed("USDC transfer failed");
            }
        }
        emit Withdrawn(msg.sender, user, amt, asCxpt);
    }


    // --- Core (Matcher) Functions ---

    /**
     * @notice Called by the CORE (Matcher) to record fees collected from trades.
     * @param feeAmount The total fee amount (in USDC base units) generated in a match batch.
     */
    function recordFees(uint256 feeAmount) external onlyRole(CORE_ROLE) {
        // No nonReentrant needed unless complex logic added
        if (feeAmount == 0) revert Vault__ZeroAmount();

        collectedFees += feeAmount; // <<< INCREMENT collectedFees
        emit FeesRecorded(msg.sender, feeAmount); // msg.sender is core/matcher
    }

    // --- Synth Mint/Burn Functions (remain the same) ---

    function mintSynth(address synth, address to, uint256 amt) external onlyRole(CORE_ROLE) {
        if (!isSynth[synth]) revert Vault__UnknownSynth();
        if (to == address(0)) revert Vault__ZeroAddress();
        SynthERC20(synth).mint(to, amt);
        emit SynthMinted(msg.sender, synth, to, amt);
    }

    function burnSynth(address synth, address from, uint256 amt) external onlyRole(CORE_ROLE) {
        if (!isSynth[synth]) revert Vault__UnknownSynth();
        if (from == address(0)) revert Vault__ZeroAddress();
        SynthERC20(synth).burnFromVault(from, amt);
        emit SynthBurned(msg.sender, synth, from, amt);
    }

    // --- View Functions ---

    function getShares(address user) external view returns (uint256) {
        return shares[user];
    }

    function isRegisteredSynth(address synth) external view returns (bool) {
        return isSynth[synth];
    }

    /**
     * @notice Returns the current amount of collected fees available for withdrawal by admin.
     */
    function getCollectedFees() external view returns (uint256) { // <<< NEW View function
        return collectedFees;
    }
}
### File: contracts/contracts/SynthERC20.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

/**
 * 1 : 1‑backed synthetic asset.  Vault is the minter & burner.
 */
contract SynthERC20 is ERC20Burnable, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(string memory n, string memory s, address vault)
        ERC20(n, s)
    {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, vault);
    }

    /* Vault‐only */
    function mint(address to, uint256 amt) external onlyRole(MINTER_ROLE) {
        _mint(to, amt);
    }

    function burnFromVault(address from, uint256 amt)
        external
        onlyRole(MINTER_ROLE)
    {
        _burn(from, amt);
    }
}
### File: contracts/ignition/modules/Lock.ts
// This setup uses Hardhat Ignition to manage smart contract deployments.
// Learn more about it at https://hardhat.org/ignition

import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

const JAN_1ST_2030 = 1893456000;
const ONE_GWEI: bigint = 1_000_000_000n;

const LockModule = buildModule("LockModule", (m) => {
  const unlockTime = m.getParameter("unlockTime", JAN_1ST_2030);
  const lockedAmount = m.getParameter("lockedAmount", ONE_GWEI);

  const lock = m.contract("Lock", [unlockTime], {
    value: lockedAmount,
  });

  return { lock };
});

export default LockModule;

### File: contracts/scripts/deploy.ts
// /Users/rizzytwizzy/prod/cxmpute-core/contracts/scripts/deploy.ts
import { ethers } from "hardhat"; // Use Hardhat's ethers instance

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log("Deploying contracts with the account:", deployer.address);
  console.log("Account balance:", (await deployer.provider.getBalance(deployer.address)).toString());

  // --- Addresses needed for deployment (Update these based on your setup) ---
  // You'll need the addresses of your backend components that need roles.
  // Get these from your SST output or environment variables.
  const coreAddress = process.env.CORE_SIGNER_ADDRESS || "0xReplaceWithCoreSignerAddress"; // Matcher Lambda Signer
  const gatewayAddress = process.env.GATEWAY_SIGNER_ADDRESS || "0xReplaceWithGatewaySignerAddress"; // API Gateway Lambda Signer
  const adminAddress = deployer.address; // Often the deployer starts as admin

  if (!ethers.isAddress(coreAddress) || !ethers.isAddress(gatewayAddress)) {
      throw new Error("CORE_SIGNER_ADDRESS and GATEWAY_SIGNER_ADDRESS must be valid addresses in .env or environment");
  }

  // --- 1. Deploy USDC Mock (ONLY FOR TESTING - Replace with actual Peaq USDC address for Agung/Mainnet) ---
  // IMPORTANT: For real deployment, get the OFFICIAL Peaq USDC address for the target network!
  let usdcAddress: string;
  if (process.env.HARDHAT_NETWORK === 'hardhat' || process.env.HARDHAT_NETWORK === 'localhost') {
       console.log("Deploying MockUSDC for local testing...");
       const MockUSDC = await ethers.getContractFactory("CXPTToken"); // Re-using ERC20 for mock
       const mockUsdc = await MockUSDC.deploy(deployer.address); // Deployer can mint mock tokens
       await mockUsdc.waitForDeployment();
       usdcAddress = await mockUsdc.getAddress();
       console.log("MockUSDC deployed to:", usdcAddress);
       // Optionally mint some mock USDC to the deployer for testing deposits
       // await mockUsdc.mint(deployer.address, ethers.parseUnits("1000000", 6)); // Mint 1M mock USDC (assuming 6 decimals)
       // console.log("Minted 1M MockUSDC to deployer");
  } else {
      usdcAddress = process.env.USDC_ADDRESS || "0xReplaceWithActualPeaqUsdcAddress"; // Get actual address for Peaq/Agung
      if (!ethers.isAddress(usdcAddress)) {
          throw new Error("USDC_ADDRESS environment variable must be set to the official Peaq USDC contract address for this network.");
      }
      console.log("Using existing USDC address:", usdcAddress);
  }


  // --- 2. Deploy CXPTToken ---
  // The Vault address isn't known yet, so we deploy CXPT first,
  // and the Vault constructor will get MINTER_ROLE later implicitly if needed,
  // OR we grant it manually after Vault deployment. Let's grant it manually.
  console.log("Deploying CXPTToken...");
  const CXPTTokenFactory = await ethers.getContractFactory("CXPTToken");
  // Pass deployer as initial admin, vault address will be granted role later
  const cxptToken = await CXPTTokenFactory.deploy(adminAddress); // Pass *something* valid, we'll grant role later
  await cxptToken.waitForDeployment();
  const cxptTokenAddress = await cxptToken.getAddress();
  console.log("CXPTToken deployed to:", cxptTokenAddress);


  // --- 3. Deploy Vault ---
  // Vault needs USDC, CXPT, CORE, and GATEWAY addresses
  console.log("Deploying Vault...");
  const VaultFactory = await ethers.getContractFactory("Vault");
  const vault = await VaultFactory.deploy(
    usdcAddress,
    cxptTokenAddress,
    coreAddress,
    gatewayAddress
  );
  await vault.waitForDeployment();
  const vaultAddress = await vault.getAddress();
  console.log("Vault deployed to:", vaultAddress);


  // --- 4. Deploy SynthFactory ---
  // Factory needs the Vault address
  console.log("Deploying SynthFactory...");
  const SynthFactoryFactory = await ethers.getContractFactory("SynthFactory");
  const synthFactory = await SynthFactoryFactory.deploy(vaultAddress);
  await synthFactory.waitForDeployment();
  const synthFactoryAddress = await synthFactory.getAddress();
  console.log("SynthFactory deployed to:", synthFactoryAddress);


  // --- 5. Grant Roles (Post-Deployment) ---
  // Grant MINTER_ROLE on CXPTToken to the deployed Vault
  console.log(`Granting MINTER_ROLE on CXPTToken (${cxptTokenAddress}) to Vault (${vaultAddress})...`);
  const grantTx = await cxptToken.grantRole(await cxptToken.MINTER_ROLE(), vaultAddress);
  await grantTx.wait(1); // Wait for confirmation
  console.log("MINTER_ROLE granted to Vault on CXPTToken.");

  // Optional: Grant ADMIN_ROLE, CORE_ROLE, GATEWAY_ROLE on Vault to other addresses if needed
  // Example: Grant ADMIN_ROLE to another admin multisig
  // const anotherAdmin = "0x...";
  // console.log(`Granting ADMIN_ROLE on Vault to ${anotherAdmin}...`);
  // const grantAdminTx = await vault.grantRole(await vault.ADMIN_ROLE(), anotherAdmin);
  // await grantAdminTx.wait(1);
  // console.log("ADMIN_ROLE granted.");

  console.log("\n--- Deployment Summary ---");
  console.log("Deployer:", deployer.address);
  console.log("USDC Address:", usdcAddress);
  console.log("CXPTToken Address:", cxptTokenAddress);
  console.log("Vault Address:", vaultAddress);
  console.log("SynthFactory Address:", synthFactoryAddress);
  console.log("CORE_ROLE Address:", coreAddress);
  console.log("GATEWAY_ROLE Address:", gatewayAddress);
  console.log("------------------------\n");
  console.log("✅ Deployment complete!");

  // TODO: Save these addresses to your SST config/secrets or a deployment info file
  // for your backend application to use.
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
### File: contracts/hardhat.config.ts
// /Users/rizzytwizzy/prod/cxmpute-core/contracts/hardhat.config.ts
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import * as dotenv from "dotenv";

// Load environment variables from .env file
dotenv.config();

// Ensure necessary environment variables are set
const PEAQ_RPC_URL = process.env.PEAQ_RPC_URL || "";
const AGUNG_RPC_URL = process.env.AGUNG_RPC_URL || "https://rpcpc1-qa.agung.peaq.network"; // Default Agung RPC
const DEPLOYER_PRIVATE_KEY = process.env.DEPLOYER_PRIVATE_KEY || ""; // Your deployment wallet private key

if (!DEPLOYER_PRIVATE_KEY) {
  console.warn("⚠️ DEPLOYER_PRIVATE_KEY environment variable not set. Deployment transactions will fail.");
}
 if (!PEAQ_RPC_URL) {
    console.warn("⚠️ PEAQ_RPC_URL environment variable not set. Deployment to Peaq mainnet will fail.");
 }


const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.24", // Match your contract pragma
    settings: {
      optimizer: {
        enabled: true,
        runs: 200, // Standard optimization setting
      },
    },
  },
  networks: {
    // Peaq Mainnet Configuration
    peaq: {
      url: PEAQ_RPC_URL,
      chainId: 3338, // Peaq Mainnet Chain ID
      accounts: DEPLOYER_PRIVATE_KEY !== '' ? [DEPLOYER_PRIVATE_KEY] : [],
      // gasPrice: 100000000000, // Optional: Set gas price (e.g., 100 Gwei) if needed
    },
    // Peaq Agung Testnet Configuration
    agung: {
      url: AGUNG_RPC_URL,
      chainId: 9990, // Agung Testnet Chain ID
      accounts: DEPLOYER_PRIVATE_KEY !== '' ? [DEPLOYER_PRIVATE_KEY] : [],
       // gasPrice: 100000000000, // Optional: Set gas price (e.g., 100 Gwei)
    },
    // Local Hardhat Network (for testing)
    hardhat: {
      chainId: 31337, // Default Hardhat network chain ID
    },
    // localhost: { // Optional: If running a local node like Anvil/Ganache
    //   url: "http://127.0.0.1:8545",
    //   chainId: 31337, // Match your local node's chain ID
    // }
  },
  paths: {
    sources: "./contracts",   // Where your .sol files are
    tests: "./test",          // Where your test files will go
    cache: "./cache",         // Hardhat cache files
    artifacts: "./artifacts", // Compiled contract output (ABI, bytecode)
  },
  mocha: {
    timeout: 40000 // Increase timeout for tests if needed
  },
  // Optional: Etherscan/Blockscout verification config (Peaqscan might need custom setup)
  // etherscan: {
  //   apiKey: {
  //      peaq: "YOUR_PEAQSCAN_API_KEY", // Placeholder - Peaqscan might not use API keys like Etherscan
  //      agung: "YOUR_AGUNG_EXPLORER_API_KEY" // Placeholder
  //   },
  //   customChains: [
  //     {
  //       network: "peaq",
  //       chainId: 3338,
  //       urls: {
  //         apiURL: "https://peaq.subscan.io/api/scan", // Adjust if Peaqscan has a different API endpoint
  //         browserURL: "https://peaq.subscan.io"
  //       }
  //     },
  //     {
  //       network: "agung",
  //       chainId: 9990,
  //       urls: {
  //         apiURL: "https://agung.subscan.io/api/scan", // Adjust if Agung explorer has a different API endpoint
  //         browserURL: "https://agung.subscan.io"
  //       }
  //     }
  //   ]
  // }
};

export default config;
### File: sst.config.ts
// sst.config.ts
// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path="./.sst/platform/config.d.ts" />

export default $config({
  app(input) {
    return {
      name: "cxmpute-core",
      removal: input?.stage === "production" ? "retain" : "remove",
      protect: ["production"].includes(input?.stage),
      home: "aws",
    };
  },
  async run() {

    // --- Define Secrets ---
    const paperPointsLimitOrder = new sst.Secret("PaperPointsLimitOrder"); 
    const paperPointsUsdcVolume = new sst.Secret("PaperPointsUsdcVolume"); 
    const paperPointsUsdcPnl = new sst.Secret("PaperPointsUsdcPnl"); 

    const coreWalletPk = new sst.Secret("CoreWalletPk");
    const coreVaultAddress = new sst.Secret("CoreVaultAddress");

    const cmcApiKey = new sst.Secret("CmcApiKey");

    // Provider Table
    const providerTable = new sst.aws.Dynamo("ProviderTable", {
      fields: {
        providerId: "string",
        providerEmail: "string",
        apiKey: "string",
        // provider wallet address: string
        // - rewards[] // rewards over the past 30 days
        //     - Day (timestamp)
        //     - Amount: number
        // - Total Rewards: number
      },
      primaryIndex: { hashKey: "providerId" },
      globalIndexes: {
        ByApiKey: { hashKey: "apiKey" },
        ByEmail: { hashKey: "providerEmail" }
      }
    });

    // Provisions Table
    const provisionsTable = new sst.aws.Dynamo("ProvisionsTable", {
      fields: {
        provisionId: "string",
        providerId: "string",
        // provision Specs: DeviceDiagnostics type
        // location: location object
      },
      primaryIndex: { hashKey: "provisionId" },
      globalIndexes: {
        ByProviderId: { hashKey: "providerId" }
      }
    });

    const authEmail = new sst.aws.Email("AuthEmail", {
      sender: "cxmpute.cloud",
    });

    // LLM Provision Pool Table
    const llmProvisionPoolTable = new sst.aws.Dynamo("LLMProvisionPoolTable", {
      fields: {
        provisionId: "string",
        model: "string",
        randomValue: "number", // float in [0..1)
        // provision endpoint: string, url used to make request to node and get response
        // location: location object
      },
      primaryIndex: { hashKey: "provisionId" },
      globalIndexes: {
        ByModel: { hashKey: "model" },
        ByModelRandom: { 
          hashKey: "model", 
          rangeKey: "randomValue" 
        }
      }
    });

    // Embeddings Provision Pool Table
    const embeddingsProvisionPoolTable = new sst.aws.Dynamo("EmbeddingsProvisionPoolTable", {
      fields: {
        provisionId: "string",
        model: "string",
        randomValue: "number", // float in [0..1)
        // provision endpoint: string, url used to make request to node and get response
        // location: location object
      },
      primaryIndex: { hashKey: "provisionId" },
      globalIndexes: {
        ByModel: { hashKey: "model" },
        ByModelRandom: { 
          hashKey: "model", 
          rangeKey: "randomValue" 
        }
      }
    });

    // Scraping Provision Pool Table
    const scrapingProvisionPoolTable = new sst.aws.Dynamo("ScrapingProvisionPoolTable", {
      fields: {
        provisionId: "string",
        randomValue: "number", // float in [0..1)
        // provision endpoint: string, url used to make request to node and get response
        // location: location object
      },
      primaryIndex: { hashKey: "provisionId" },
      globalIndexes: {
        ByRandom: { hashKey: "randomValue" }
      }
    });

    // Moon Provision Pool Table
    const moonProvisionPoolTable = new sst.aws.Dynamo("MoonProvisionPoolTable", {
      fields: {
        provisionId: "string",
        randomValue: "number", // float in [0..1)
        // provision endpoint: string, url used to make request to node and get response
        // location: location object
      },
      primaryIndex: { hashKey: "provisionId" },
      globalIndexes: {
        ByRandom: { hashKey: "randomValue" }
      }
    });

    // Video and Image Provision Pool Table
    const mediaProvisionPoolTable = new sst.aws.Dynamo("MediaProvisionPoolTable", {
      fields: {
        provisionId: "string",
        model: "string",
        type: "string", // "image" or "video"
        randomValue: "number", // float in [0..1)
        // provision endpoint: string, url used to make request to node and get response
        // location: location object
      },
      primaryIndex: { hashKey: "provisionId" },
      globalIndexes: {
        ByModelAndType: { hashKey: "model", rangeKey: "type" },
        ByType: { hashKey: "type" },
        ByModelAndTypeRandom: { 
          hashKey: "model", 
          rangeKey: "randomValue", 
        }
      }
    });

    // TTS Provision Pool Table
    const ttsProvisionPoolTable = new sst.aws.Dynamo("TTSProvisionPoolTable", {
      fields: {
        provisionId: "string",
        model: "string",
        randomValue: "number", // float in [0..1)
        // provision endpoint: string, url used to make request to node and get response
        // location: location object
      },
      primaryIndex: { hashKey: "provisionId" },
      globalIndexes: {
        ByModel: { hashKey: "model" },
        ByModelRandom: { 
          hashKey: "model", 
          rangeKey: "randomValue" 
        }
      }
    });

    // User Table
    const userTable = new sst.aws.Dynamo("UserTable", {
      fields: {
        userId: "string",
        userAk: "string",
        // api key: {key: string, creditLimit: number, creditsLeft: number}[]
        // credits: number
        // rewards: { day: string, amount: number }[]
        // - Total Rewards: number
      },
      primaryIndex: { hashKey: "userId" },
      globalIndexes: {
        ByWalletAddress: { hashKey: "userAk" },
      }
    });

    // Metadata Table
    const metadataTable = new sst.aws.Dynamo("MetadataTable", {
      fields: {
        endpoint: "string", // endpoint or model name
        dayTimestamp: "string",
        // llm?: { THis field exists for when the endpoint is a model
        //   model: string,
        //   tokensIn: number,
        //   tokensOut: number,
        //   averageTps: number,
        // }
        // totalNumRequests: number // incremented with each new request
        // averageLatency: number
      },
      primaryIndex: { hashKey: "endpoint", rangeKey: "dayTimestamp" }
    });

    // Service Metadata Table
    const serviceMetadataTable = new sst.aws.Dynamo("ServiceMetadataTable", {
      fields: {
        serviceName: "string",
        // attributes for each endpoint:
        // - Total num requests
        // - requests[] // past week max
        //    - Past day timestamp
        //    - Num requests: number
        // attributes for each model:
        // - Total input tokens
        // - Total output tokens
        //     - totals[] //past week max
              // - Past day timestamp
              // - Num input tokens: number
              // - Num output tokens: number
      },
      primaryIndex: { hashKey: "serviceName" }
    });

    // Network Stats Table
    const networkStatsTable = new sst.aws.Dynamo("NetworkStatsTable", {
      fields: {
        dateTimestamp: "string",
        endpointOrModel: "string",
        // current num provisions: number
        // provision tier: number
      },
      primaryIndex: { hashKey: "dateTimestamp", rangeKey: "endpointOrModel" },
      globalIndexes: {
        ByEndpointOrModel: { hashKey: "endpointOrModel", rangeKey: "dateTimestamp" }
      }
    });

    // Advertisement Table
    const advertisementTable = new sst.aws.Dynamo("AdvertisementTable", {
      fields: {
        timeSlotTimestamp: "string",
        location: "string",
        // content: string,
      },
      primaryIndex: { hashKey: "timeSlotTimestamp", rangeKey: "location" }
    });

    const graphs = new sst.aws.Bucket("GraphsBucket");

    const auth = new sst.aws.Auth("CxmputeAuth", {
      issuer: {
        handler: "auth/index.handler",
        link: [
          providerTable,
          userTable,
          authEmail,        // <-- makes Resource.AuthEmail.* available
        ],
      },
    });

    // ──────────────────────────────────────────────────────────────
    /* ─── DEX DynamoDB tables (UPDATED FOR PAPER TRADING) ─────── */

    const ordersTable = new sst.aws.Dynamo("OrdersTable", {
      fields: {
        pk:        "string",          // NEW: MARKET#<symbol>#<mode> (e.g., MARKET#BTC-PERP#PAPER)
        sk:        "string",          // Keep: TS#<uuid>
        traderId:  "string",          // Attribute
        orderId:   "string",          // Attribute & GSI Key
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
      globalIndexes: {
        // NEW: GSI to query orders by trader and optionally filter by market/mode via SK (pk)
        ByTraderMode: { hashKey: "traderId", rangeKey: "pk" },
        // Keep: GSI to fetch/cancel specific orders
        ByOrderId:  { hashKey: "orderId" }
      },
      stream: "new-and-old-images", // Keep stream for order processing
    });

    // Unchanged Traders Table (holds user identity, not mode-specific state)
    const tradersTable = new sst.aws.Dynamo("TradersTable", {
      fields: {
        traderId: "string",
        traderAk: "string",
      },
      primaryIndex: { hashKey: "traderId" },
      globalIndexes: {
        ByAk: { hashKey: "traderAk" },
      },
    });

    const balancesTable = new sst.aws.Dynamo("BalancesTable", {
      fields: {
        pk: "string",          // NEW: TRADER#<traderId>#<mode> (e.g., TRADER#uuid123#PAPER)
        sk: "string",          // NEW: ASSET#<asset> (e.g., ASSET#USDC)
        // Attributes: balance, pending remain as attributes
        balance: "number",
        pending: "number",
      },
      // NEW Primary Index using mode-partitioned keys
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
    });

    const tradesTable = new sst.aws.Dynamo("TradesTable", {
      fields: {
        pk:       "string",          // NEW: MARKET#<symbol>#<mode>
        sk:       "string",          // Keep: TS#<tradeId>
        traderId: "string",          // Attribute (used for GSI)
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
      globalIndexes: {
        // NEW: GSI to query trades by trader and optionally filter by market/mode via SK (pk)
        ByTraderMode: { hashKey: "traderId", rangeKey: "pk" }
      },
      stream: "new-and-old-images", // Keep stream for S3 archiving
    });

    const positionsTable = new sst.aws.Dynamo("PositionsTable", {
      fields: {
        pk: "string",       // NEW: TRADER#<traderId>#<mode>
        sk: "string",       // Keep: MARKET#<symbol>
        // Attributes: size, avgEntryPrice, pnl etc. remain attributes
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
    });

    const marketsTable = new sst.aws.Dynamo("MarketsTable", {
      fields: {
        pk:     "string",   // NEW: MARKET#<symbol>#<mode>
        sk:     "string",   // Keep: META
        status: "string",   // Attribute & GSI Key
        // Attributes: type, tickSize, synth etc. remain attributes
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
      globalIndexes: {
        // NEW: GSI to query markets by status and filter by mode via SK (pk)
        ByStatusMode: { hashKey: "status", rangeKey: "pk" },
      },
    });

    // Unchanged Prices Table (paper uses real prices)
    const pricesTable = new sst.aws.Dynamo("PricesTable", {
      fields: {
        pk: "string",   // ASSET#BTC
        sk: "string",   // TS#ISO
        // Attributes: price, expireAt
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
      ttl: "expireAt",
    });

    const statsIntradayTable = new sst.aws.Dynamo("StatsIntradayTable", {
      fields: {
        pk:      "string", // NEW: MARKET#<symbol>#<mode>
        sk:      "string", // Keep: TS#<minute_epoch_ms>
        expireAt:"number", // Keep TTL
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
      ttl: "expireAt",
    });

    const statsDailyTable = new sst.aws.Dynamo("StatsDailyTable", {
      fields: {
        pk: "string", // NEW: MARKET#<symbol>#<mode>
        sk: "string", // Keep: YYYY-MM-DD
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
    });

    const statsLifetimeTable = new sst.aws.Dynamo("StatsLifetimeTable", {
      fields: {
        pk: "string", // NEW: KEY#GLOBAL#<mode>
        sk: "string", // Keep: META
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
    });

    const wsConnectionsTable = new sst.aws.Dynamo("WSConnectionsTable", {
      fields: {
        pk:       "string",            // Keep: WS#<connId>
        sk:       "string",            // Keep: META
        expireAt: "number",            // Keep TTL
        channelMode: "string",         // NEW: "REAL" or "PAPER" (nullable if not subscribed)
        // Attributes: traderId, channel etc. remain attributes
      },
      primaryIndex: { hashKey: "pk", rangeKey: "sk" },
      ttl: "expireAt",
    });

    /* ─── S3 lake for cold trade/metrics history ──────────────────────── */
    const dataLakeBucket = new sst.aws.Bucket("DexDataLakeBucket", { // Unchanged
      versioning: true,
      cors: { allowMethods: ["GET", "PUT"] },
    });

    /* ─── SNS topic for real‑time fan‑out ─────────────────────────────── */
    const marketUpdatesTopic = new sst.aws.SnsTopic("MarketUpdatesTopic"); // Unchanged

    /* ─── SQS FIFO order queues (Reused for both modes) ─────────────── */
    const marketOrdersQueue  = new sst.aws.Queue("MarketOrdersQueue",  {
      fifo: { contentBasedDeduplication: true },
      visibilityTimeout: "30 seconds",
    });
    const optionsOrdersQueue = new sst.aws.Queue("OptionsOrdersQueue", {
      fifo: { contentBasedDeduplication: true },
      visibilityTimeout: "30 seconds",
    });
    const perpsOrdersQueue   = new sst.aws.Queue("PerpsOrdersQueue",   {
      fifo: { contentBasedDeduplication: true },
      visibilityTimeout: "30 seconds",
    });
    const futuresOrdersQueue = new sst.aws.Queue("FuturesOrdersQueue", {
      fifo: { contentBasedDeduplication: true },
      visibilityTimeout: "30 seconds",
    });

    /* ─── Dynamo Stream → router Fn → SQS (Router needs updated logic) ─ */
    ordersTable.subscribe("OrdersStreamRouter",{
      handler: "dex/streams/ordersStreamRouter.handler", // Needs update to parse mode from pk
      link: [
        marketOrdersQueue,
        optionsOrdersQueue,
        perpsOrdersQueue,
        futuresOrdersQueue,
      ],
    });

    /* ─── Matcher subscribers (Matchers need updated logic for mode) ─── */
    // Links remain the same, but handlers need mode awareness
    marketOrdersQueue.subscribe({
      handler: "dex/matchers/market.handler",
      link: [
        ordersTable,
        tradesTable,
        positionsTable,
        balancesTable, // ADDED: Needed for direct paper balance updates
        statsIntradayTable,
        statsLifetimeTable,
        marketsTable,
        // wsConnectionsTable, // Not directly needed by matcher? Fanout handles WS
        marketUpdatesTopic,
      ],
      timeout: "60 seconds",
    }, { batch: { size: 10, window: "5 seconds" } });

    optionsOrdersQueue.subscribe({
      handler: "dex/matchers/options.handler",
      link: [
        ordersTable,
        tradesTable,
        positionsTable,
        balancesTable, // ADDED
        statsIntradayTable,
        statsLifetimeTable,
        marketsTable,
        marketUpdatesTopic,
      ],
      timeout: "60 seconds",
    }, { batch: { size: 10, window: "5 seconds" } });

    perpsOrdersQueue.subscribe({
      handler: "dex/matchers/perps.handler",
      link: [
        ordersTable,
        tradesTable,
        positionsTable,
        balancesTable, // ADDED
        statsIntradayTable,
        statsLifetimeTable,
        marketsTable,
        marketUpdatesTopic,
      ],
      timeout: "60 seconds",
    }, { batch: { size: 10, window: "5 seconds" } });

    futuresOrdersQueue.subscribe({
      handler: "dex/matchers/futures.handler",
      link: [
        ordersTable,
        tradesTable,
        positionsTable,
        balancesTable, // ADDED
        statsIntradayTable,
        statsLifetimeTable,
        marketsTable,
        marketUpdatesTopic,
      ],
      timeout: "60 seconds",
    }, { batch: { size: 10, window: "5 seconds" } });

    /* ───  WebSocket API  ─────────────────────────────────────────────── */
    const wsApi = new sst.aws.ApiGatewayWebSocket("DexWsApi", {
      domain: $interpolate`dex.${$app.stage}.cxmpute.cloud`,
    });

    wsApi.route("$connect",    {
      handler: "dex/ws/connect.handler",
      link: [wsConnectionsTable, tradersTable], // Connect needs tradersTable to verify Ak
    });
    wsApi.route("$disconnect", {
      handler: "dex/ws/disconnect.handler",
      link: [wsConnectionsTable],
    });
    wsApi.route("$default",    "dex/ws/default.handler");
    // Subscribe needs logic update for mode-aware channels
    wsApi.route("subscribe",   {
        handler: "dex/ws/subscribe.handler",
        link: [wsConnectionsTable] // Needs to write channelMode
    });

    /* Fan‑out needs logic update for mode-aware channels */
    marketUpdatesTopic.subscribe("WsFanOut", {
      handler: "dex/ws/fanOut.handler",
      link: [
        wsApi,
        wsConnectionsTable, // Needs to read channel/channelMode for filtering
      ],
    });

    /* ─── Scheduled jobs (Cron Jobs need mode awareness) ───────────── */

    /* 1) Oracle pull – Unchanged, uses real prices */
    new sst.aws.Cron("OracleFetchCron", {
      schedule: "rate(1 minute)",
      function: {
        handler: "dex/cron/oracle.handler",
        timeout: "60 seconds",
        memory: "256 MB",
        link: [pricesTable, marketsTable], // Reads market definitions (now includes mode)
      },
    });

    /* 2) Funding tick – Needs mode logic */
    new sst.aws.Cron("FundingCron", {
      schedule: "rate(1 hour)",
      function: {
        handler: "dex/cron/funding.handler", // Needs update
        timeout: "120 seconds",
        memory: "512 MB",
        link: [
          marketsTable,
          positionsTable,
          balancesTable, // ADDED: For paper balance adjustments
          tradesTable, // For mark price source
          statsIntradayTable,
          statsLifetimeTable,
          pricesTable, // For index price source
          // wsApi, // Not directly needed, pushes to SNS
          marketUpdatesTopic,
          coreVaultAddress,
          coreWalletPk,
        ],
        // Environment vars for Vault/CORE_PK needed only if mode is REAL
        environment: {
          PEAQ_RPC_URL: "https://peaq.api.onfinality.io/public",
          CHAIN_ID:     "3338",
        },
      },
    });

    /* 3) Option expiry – Needs mode logic */
    new sst.aws.Cron("OptionExpiryCron", {
      schedule: "rate(1 hour)",
      function: {
        handler: "dex/cron/optionExpiry.handler", // Needs update
        timeout: "120 seconds",
        link: [
          ordersTable,
          positionsTable,
          balancesTable, // ADDED
          tradesTable,
          marketsTable,
          pricesTable, // ADDED: For settlement price source
          // wsApi,
          marketUpdatesTopic,
          coreVaultAddress,
          coreWalletPk,
        ],
        // Environment vars for Vault/CORE_PK needed only if mode is REAL
         environment: {
          PEAQ_RPC_URL: "https://peaq.api.onfinality.io/public",
          CHAIN_ID:     "3338",
        },
      },
    });

    /* 4) Future expiry – Needs mode logic */
    new sst.aws.Cron("FutureExpiryCron", {
      schedule: "rate(1 hour)",
      function: {
        handler: "dex/cron/futureExpiry.handler", // Needs update
        timeout: "120 seconds",
        link: [
          ordersTable,
          positionsTable,
          balancesTable, // ADDED
          tradesTable,
          marketsTable,
          pricesTable, // ADDED: For settlement price source
          // wsApi,
          marketUpdatesTopic,
          coreVaultAddress,
          coreWalletPk,
        ],
         // Environment vars for Vault/CORE_PK needed only if mode is REAL
         environment: {
          PEAQ_RPC_URL: "https://peaq.api.onfinality.io/public",
          CHAIN_ID:     "3338",
        },
      },
    });

    /* 5) Daily metrics roll‑up – Needs mode logic */
    new sst.aws.Cron("MetricsRollupCron", {
      schedule: "cron(0 0 * * ? *)",
      function: {
        handler: "dex/cron/metricsRollup.handler", // Needs update
        timeout: "300 seconds",
        memory: "1024 MB",
        link: [
          statsIntradayTable,
          statsDailyTable,
          dataLakeBucket,
          marketsTable, // To know which markets existed
        ],
      },
    });

    /* PerpDailySettleCron - Needs mode logic */
    new sst.aws.Cron("PerpDailySettleCron", {
      schedule: "cron(5 0 * * ? *)",
      function: {
        handler: "dex/cron/perpsDailySettle.handler", // Needs update
        timeout: "300 seconds",
        link: [
          positionsTable,
          balancesTable, // Needed for both REAL and PAPER balance updates
          pricesTable, // Needed for PnL calculation
          coreVaultAddress,
          coreWalletPk
          // statsIntradayTable, // Not directly needed for settlement?
        ],
        // Environment vars for Vault/CORE_PK only needed for REAL mode (if settlement involves on-chain transfers, which it doesn't seem to here, only balance updates)
        // Keep them linked for consistency if other CRONs need them
        environment: {
          PEAQ_RPC_URL: "https://peaq.api.onfinality.io/public",
          CHAIN_ID:     "3338",
        },
      },
    });

    // Link tables to the NextJS app
    new sst.aws.Nextjs("CxmputeSite", {
      domain: {
        name: "cxmpute.cloud",
        redirects: ["www." + "cxmpute.cloud"],
        aliases: ["trade.cxmpute.cloud"],
      },
      link: [
        providerTable,
        provisionsTable,
        llmProvisionPoolTable,
        embeddingsProvisionPoolTable,
        scrapingProvisionPoolTable,
        moonProvisionPoolTable,
        mediaProvisionPoolTable,
        ttsProvisionPoolTable,
        userTable,
        metadataTable,
        serviceMetadataTable,
        networkStatsTable,
        advertisementTable,
        auth,
        graphs,
        authEmail,
        tradesTable,
        positionsTable,
        ordersTable,
        marketsTable,
        pricesTable,
        statsIntradayTable,
        statsDailyTable,
        statsLifetimeTable,
        wsConnectionsTable,
        dataLakeBucket,
        wsApi,
        marketUpdatesTopic,
        tradersTable,
        marketOrdersQueue,
        optionsOrdersQueue,
        perpsOrdersQueue,
        futuresOrdersQueue,
        balancesTable,
        paperPointsLimitOrder,
        paperPointsUsdcPnl,
        paperPointsUsdcVolume,
        cmcApiKey,
      ]
    });
  },
});

### File: sst-env.d.ts
/* This file is auto-generated by SST. Do not edit. */
/* tslint:disable */
/* eslint-disable */
/* deno-fmt-ignore-file */

declare module "sst" {
  export interface Resource {
    "AdvertisementTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "AuthEmail": {
      "configSet": string
      "sender": string
      "type": "sst.aws.Email"
    }
    "CxmputeAuth": {
      "type": "sst.aws.Auth"
      "url": string
    }
    "CxmputeSite": {
      "type": "sst.aws.Nextjs"
      "url": string
    }
    "EmbeddingsProvisionPoolTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "GraphsBucket": {
      "name": string
      "type": "sst.aws.Bucket"
    }
    "LLMProvisionPoolTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "MediaProvisionPoolTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "MetadataTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "MoonProvisionPoolTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "NetworkStatsTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "ProviderTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "ProvisionsTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "ScrapingProvisionPoolTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "ServiceMetadataTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "TTSProvisionPoolTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
    "UserTable": {
      "name": string
      "type": "sst.aws.Dynamo"
    }
  }
}
/// <reference path="sst-env.d.ts" />

import "sst"
export {}
### File: next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

### File: dex/streams/ordersStreamRouter.ts
// dex/streams/ordersStreamRouter.ts
import { DynamoDBStreamHandler, DynamoDBStreamEvent } from "aws-lambda";
import { SQSClient, SendMessageCommand } from "@aws-sdk/client-sqs";
import { unmarshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";
import type { Order, OrderQueueMessage, TradingMode } from "../../src/lib/interfaces"; // Import TradingMode

const sqs = new SQSClient({});

// Map order types to their respective queue URLs (fetched from SST Resources)
const queueUrls = {
  MARKET: Resource.MarketOrdersQueue.url,
  LIMIT: Resource.MarketOrdersQueue.url, // Market and Limit use the same queue/matcher
  OPTION: Resource.OptionsOrdersQueue.url,
  PERP: Resource.PerpsOrdersQueue.url,
  FUTURE: Resource.FuturesOrdersQueue.url,
};

/**
 * Parses the mode ("REAL" or "PAPER") from the DynamoDB PK.
 * PK format: MARKET#<symbol>#<mode>
 */
const parseModeFromPk = (pk: string): TradingMode | null => {
  const parts = pk.split("#");
  if (parts.length === 3 && parts[0] === "MARKET") {
    const mode = parts[2].toUpperCase();
    if (mode === "REAL" || mode === "PAPER") {
      return mode as TradingMode;
    }
  }
  console.error(`Could not parse mode from PK: ${pk}`);
  return null;
};


export const handler: DynamoDBStreamHandler = async (
  event: DynamoDBStreamEvent
) => {
  for (const record of event.Records) {
    // Only process new order insertions
    if (record.eventName !== "INSERT" || !record.dynamodb?.NewImage) {
      continue;
    }

    try {
      // Unmarshall the full order item from the stream
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const newImage = unmarshall(record.dynamodb.NewImage as any) as Order & { pk: string; sk: string};

      // --- Paper Trading: Parse Mode ---
      const mode = parseModeFromPk(newImage.pk);
      if (!mode) {
          console.error(`Skipping record - failed to parse mode for orderId: ${newImage.orderId}, pk: ${newImage.pk}`);
          continue; // Skip processing if mode cannot be determined
      }
      // --- End Paper Trading ---

      const orderType = newImage.orderType;

      // Determine the target queue based on order type

      const targetQueueUrl = queueUrls[orderType];

      if (!targetQueueUrl) {
        console.warn(`No queue configured for order type: ${orderType}`);
        continue; // Skip if no queue is mapped
      }

      // Prepare the message for the SQS queue
      const messagePayload: OrderQueueMessage = {
        orderId: newImage.orderId,
        market: newImage.market,
        order: newImage, // Pass the full unmarshalled order item
        mode: mode,      // Include the parsed mode
      };

      // Send the message to the specific SQS queue
      await sqs.send(
        new SendMessageCommand({
          QueueUrl: targetQueueUrl,
          MessageBody: JSON.stringify(messagePayload),
          // FIFO specific properties: MessageGroupId determines the partition (matching engine)
          // Use the market symbol and mode to ensure orders for the same market/mode are processed sequentially.
          MessageGroupId: `${newImage.market}-${mode}`,
          // MessageDeduplicationId can be based on orderId for idempotency
          MessageDeduplicationId: newImage.orderId,
        })
      );

      // console.log(`Order ${newImage.orderId} (${mode}) routed to queue for ${orderType}`);

    } catch (error) {
      console.error("Error processing DynamoDB stream record:", error);
      console.error("Failed record:", JSON.stringify(record, null, 2));
      // Consider sending failed records to a Dead Letter Queue (DLQ) configured on the Lambda
    }
  }
};
### File: dex/chain/vaultHelper.ts
// dex/onchain/vaultHelper.ts
import { ethers } from "ethers";
import { Resource } from "sst";
const { PEAQ_RPC_URL, CHAIN_ID = "3338" } = process.env;
const VAULT_ADDR = Resource.CoreVaultAddress.value;
const CORE_PK = Resource.CoreWalletPk.value;
const abi = [
  "function mintSynth(address synth,address to,uint256 amt)",
  "function burnSynth(address synth,address from,uint256 amt)",
];

const provider = new ethers.JsonRpcProvider(PEAQ_RPC_URL!, +CHAIN_ID);
export const vault = new ethers.Contract(
  VAULT_ADDR!,
  abi,
  new ethers.Wallet(CORE_PK!, provider)   // CORE_ROLE signer
);
### File: dex/matchers/marketRegistry.ts
// dex/matchers/marketRegistry.ts (Example Implementation)
import { DynamoDBClient, GetItemCommand } from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";
import type { MarketMeta, TradingMode } from "../../src/lib/interfaces";

const ddb = new DynamoDBClient({});
const MARKETS_TABLE = Resource.MarketsTable.name;

// Cache market details to reduce DynamoDB calls (optional but recommended)
const marketCache = new Map<string, MarketMeta | null>(); // Key: <symbol>#<mode>

/**
 * Helper: derive PK for Markets table
 */
const pkMarketMode = (symbol: string, mode: TradingMode) =>
  `MARKET#${symbol}#${mode.toUpperCase()}`;


/**
 * Fetches market metadata from DynamoDB (with caching).
 */
export async function getMarketDetails(symbol: string, mode: TradingMode): Promise<MarketMeta | null> {
    const cacheKey = `${symbol}#${mode}`;
    if (marketCache.has(cacheKey)) {
        return marketCache.get(cacheKey) ?? null;
    }

    const pk = pkMarketMode(symbol, mode);
    try {
        const { Item } = await ddb.send(new GetItemCommand({
            TableName: MARKETS_TABLE,
            Key: marshall({ pk: pk, sk: "META" })
        }));

        if (!Item) {
            console.warn(`Market details not found for ${pk}`);
            marketCache.set(cacheKey, null); // Cache the miss
            return null;
        }

        const marketMeta = unmarshall(Item) as MarketMeta;
        marketCache.set(cacheKey, marketMeta);
        return marketMeta;

    } catch (error) {
        console.error(`Error fetching market details for ${pk}:`, error);
        return null; // Return null on error
    }
}

/**
 * Gets the Synth address for a REAL market. Returns null otherwise.
 */
export async function getSynthAddr(symbol: string): Promise<string | null> {
    const details = await getMarketDetails(symbol, "REAL"); // Only REAL markets have synths
    // The 'synth' attribute should exist on the MarketMeta interface
    return details?.synth ?? null;
}

// Add other helper functions as needed, e.g., getting tickSize, lotSize, etc.
export async function getTickSize(symbol: string, mode: TradingMode): Promise<number | null> {
     const details = await getMarketDetails(symbol, mode);
     return details?.tickSize ?? null;
}
### File: dex/matchers/perps.ts
// dex/matchers/market.ts (Example - Apply similar changes to options.ts, perps.ts, futures.ts)
import { SQSHandler, SQSEvent } from "aws-lambda";
import { matchOrder } from "./matchEngine"; // Assuming matchOrder is updated
import {
    OrderQueueMessage,
    TradingMode, // Import TradingMode
    PerpOrder
} from "../../src/lib/interfaces";
import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
import { Resource } from "sst";

const sns = new SNSClient({});

export const handler: SQSHandler = async (event: SQSEvent) => {
  for (const rec of event.Records) {
    try {
        const msg = JSON.parse(rec.body) as OrderQueueMessage; // Parse the full message

        // Extract order details and the mode
        const order = msg.order as PerpOrder; // Cast to appropriate types for this matcher
        const mode: TradingMode = msg.mode;
        const market: string = msg.market; // Or msg.order.market
        const orderId: string = msg.orderId; // Or msg.order.orderId

        if (!mode) {
             console.error(`Matcher Error: Missing mode in SQS message for orderId ${orderId}. Skipping.`);
             continue;
        }

        // Call the updated matchOrder function, passing the mode
        await matchOrder(order, mode); // Pass mode to the matching engine

        // Fan-out WebSocket update via SNS (include mode in the SNS message)
        await sns.send(
          new PublishCommand({
            TopicArn: Resource.MarketUpdatesTopic.arn,
            Message: JSON.stringify({
              type: "orderUpdate", // Keep message type consistent
              market: market,
              orderId: orderId,
              mode: mode, // Include mode in the WS payload
              // Add other relevant order details if needed by WS clients
              status: order.status // Example: Current status might be useful
            }),
            // Optional: Use MessageAttributes for filtering on the SNS subscriber side if needed
            // MessageAttributes: {
            //     'mode': { DataType: 'String', StringValue: mode },
            //     'market': { DataType: 'String', StringValue: market }
            // }
          })
        );
    } catch (error) {
        console.error(`Error processing SQS message for order: ${rec.messageId}`, error);
        console.error("Failed message body:", rec.body);
        // Implement retry or DLQ logic as needed
        // Re-throwing the error might cause SQS to retry the message automatically (depending on Lambda config)
        // throw error;
    }
  }
};
### File: dex/matchers/matchEngine.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/matchers/matchEngine.ts
import {
    DynamoDBClient,
    TransactWriteItemsCommand,
    QueryCommand,
    TransactWriteItem,
    GetItemCommand,
    Update,
    UpdateItemCommand, // Now needed for point updates outside transaction
  } from "@aws-sdk/client-dynamodb";
  import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
  import {
    Order,
    OrderSide,
    Trade,
    UUID,
    TradingMode,
    Position,
  } from "../../src/lib/interfaces"; // Ensure interfaces define base Order structure
  import { Resource } from "sst";
  import { vault } from "../chain/vaultHelper"; // Import the updated helper with recordFees
  import { getSynthAddr } from "./marketRegistry"; // Mode-aware market details helper
  
  // Define an extended Order type that includes DynamoDB keys, used internally
  type OrderWithKeys = Order & { pk: string; sk: string };
  
  const ddb = new DynamoDBClient({});
  
  // --- Constants ---
  const ORDERS_TABLE = Resource.OrdersTable.name;
  const TRADES_TABLE = Resource.TradesTable.name;
  const POSITIONS_TABLE = Resource.PositionsTable.name;
  const STATS_INTRADAY_TABLE = Resource.StatsIntradayTable.name;
  const STATS_LIFETIME_TABLE = Resource.StatsLifetimeTable.name;
  const TRADERS_TABLE = Resource.TradersTable.name; // Added for points
  
  /** Fee = 1 % = 100 BPS */
  const FEE_BPS = 100;
  const BPS_DIVISOR = 10_000; // For fee calculation
  const USDC_DECIMALS = 6;    // Define USDC decimals for fee/synth conversion
  
  // --- Point Calculation Constants (from Secrets) ---
  // Use parseFloat and provide defaults in case secrets aren't set or are invalid numbers
  const POINTS_PER_USDC_VOLUME: number = parseFloat(Resource.PaperPointsUsdcVolume?.value ?? "0.01") || 0.01;
  const POINTS_PER_USDC_PNL: number = parseFloat(Resource.PaperPointsUsdcPnl?.value ?? "0.05") || 0.05;
  
  
  /**
   * Helper to build PK / SK for various tables (now includes mode where applicable).
   */
  export const pk = {
    marketMode: (market: string, mode: TradingMode) => `MARKET#${market}#${mode.toUpperCase()}`,
    traderMode: (id: UUID, mode: TradingMode) => `TRADER#${id}#${mode.toUpperCase()}`,
    globalMode: (mode: TradingMode) => `KEY#GLOBAL#${mode.toUpperCase()}`,
    asset: (a: string) => `ASSET#${a}`,
  };
  
  // --- Helper Functions ---
  
  /** Safely calculates fees using integer math if possible, or careful float handling. */
  function calculateFee(value: number): number {
      // Avoid division by zero and handle non-positive values gracefully
      if (BPS_DIVISOR <= 0 || value <= 0 || !isFinite(value)) return 0;
      // Use Math.floor for consistent integer results, or adjust rounding as needed
      // Ensure intermediate calculation doesn't overflow standard number limits if value is huge
      return Math.floor((value * FEE_BPS) / BPS_DIVISOR);
  }
  
  /** Loads the current position state for a trader, market, and mode. */
  async function getCurrentPosition(traderId: UUID, market: string, mode: TradingMode): Promise<Position> {
      const positionPk = pk.traderMode(traderId, mode);
      const positionSk = `MARKET#${market}`;
      try {
          const { Item } = await ddb.send(new GetItemCommand({
              TableName: POSITIONS_TABLE,
              Key: marshall({ pk: positionPk, sk: positionSk }),
          }));
          if (Item) {
              const pos = unmarshall(Item) as Position;
              // Ensure numeric types are correctly handled, default to 0 if missing/invalid
              return {
                  traderId: traderId, market: market,
                  size: typeof pos.size === 'number' && isFinite(pos.size) ? pos.size : 0,
                  avgEntryPrice: typeof pos.avgEntryPrice === 'number' && isFinite(pos.avgEntryPrice) ? pos.avgEntryPrice : 0,
                  realizedPnl: typeof pos.realizedPnl === 'number' && isFinite(pos.realizedPnl) ? pos.realizedPnl : 0,
                  unrealizedPnl: typeof pos.unrealizedPnl === 'number' && isFinite(pos.unrealizedPnl) ? pos.unrealizedPnl : 0,
                  updatedAt: typeof pos.updatedAt === 'number' && isFinite(pos.updatedAt) ? pos.updatedAt : 0,
              };
          }
      } catch (error) {
          console.error(`Error fetching position for ${traderId}#${market}#${mode}:`, error);
      }
      // Default state if no position found or on error
      return { traderId: traderId, market: market, size: 0, avgEntryPrice: 0, realizedPnl: 0, unrealizedPnl: 0, updatedAt: 0 };
  }
  
  
  /** Calculates the new state of a position after a trade. */
  function calculateNewPositionState(
      currentPosition: Position,
      qtyChange: number, // Signed quantity of the fill (+ buy, - sell)
      fillPx: number
  ): { newSize: number; newAvgEntry: number; realizedPnlChange: number } {
  
      const oldSize = currentPosition.size;
      let oldAvgEntry = currentPosition.avgEntryPrice;
      let realizedPnlChange = 0;
      const newSize = oldSize + qtyChange;
      let newAvgEntry = oldAvgEntry;
  
      // Sanitize inputs
      if (isNaN(oldAvgEntry) || !isFinite(oldAvgEntry)) {
          console.warn("calculateNewPositionState: Invalid oldAvgEntry, defaulting to 0", { oldAvgEntry });
          oldAvgEntry = 0;
      }
       if (isNaN(fillPx) || !isFinite(fillPx)) {
          console.error("calculateNewPositionState: CRITICAL Invalid fillPx provided, cannot calculate state.", { fillPx });
          // Depending on desired behavior, you might return current state or throw
          return { newSize: oldSize, newAvgEntry: oldAvgEntry, realizedPnlChange: 0 }; // Prevent state change on bad price
      }
       if (isNaN(qtyChange) || !isFinite(qtyChange)) {
           console.error("calculateNewPositionState: CRITICAL Invalid qtyChange provided.", { qtyChange });
           return { newSize: oldSize, newAvgEntry: oldAvgEntry, realizedPnlChange: 0 };
       }
       if (isNaN(oldSize) || !isFinite(oldSize)) {
          console.error("calculateNewPositionState: CRITICAL Invalid oldSize provided.", { oldSize });
          // This indicates a data corruption issue, might need specific handling
           return { newSize: oldSize, newAvgEntry: oldAvgEntry, realizedPnlChange: 0 };
       }
  
  
      if (oldSize !== 0 && (oldSize * qtyChange < 0)) { // Position reduction or flip
          const closedQty = Math.min(Math.abs(oldSize), Math.abs(qtyChange));
          // PnL calculation now relies on sanitized inputs
          realizedPnlChange = closedQty * (fillPx - oldAvgEntry) * Math.sign(oldSize);
  
          if (Math.abs(qtyChange) >= Math.abs(oldSize)) { // Flip or full close
              newAvgEntry = (newSize !== 0) ? fillPx : 0; // New entry is fillPx if flipped, 0 if closed
          } // else partial close: newAvgEntry remains oldAvgEntry
      } else if (newSize !== 0) { // Increasing position or opening new
           // Ensure calculation doesn't result in NaN/Infinity
           const currentTotalValue = oldSize * oldAvgEntry;
           const addedValue = qtyChange * fillPx;
           if (isFinite(currentTotalValue) && isFinite(addedValue)) {
               newAvgEntry = (currentTotalValue + addedValue) / newSize;
           } else {
                console.warn("calculateNewPositionState: Non-finite values in avg entry calculation", { currentTotalValue, addedValue });
                newAvgEntry = fillPx; // Fallback to fillPx if calculation is invalid
           }
      } else { // Position fully closed exactly
           newAvgEntry = 0;
      }
  
      // Final safety checks
      if (newSize === 0) { newAvgEntry = 0; }
      if (isNaN(newAvgEntry) || !isFinite(newAvgEntry)) {
          console.warn("calculateNewPositionState: Final newAvgEntry is NaN/Infinite, resetting to 0", { newAvgEntry });
          newAvgEntry = 0;
      }
       if (isNaN(realizedPnlChange) || !isFinite(realizedPnlChange)) {
          console.warn("calculateNewPositionState: Final realizedPnlChange is NaN/Infinite, resetting to 0", { realizedPnlChange });
          realizedPnlChange = 0;
      }
  
      return { newSize, newAvgEntry, realizedPnlChange };
  }
  
  /** Generates the DynamoDB Update object structure for updating a position. */
  function createPositionUpdateInput(
      traderId: UUID,
      market: string,
      mode: TradingMode,
      newState: { newSize: number; newAvgEntry: number; realizedPnlChange: number },
      matchTimestamp: number
  ): Update {
      const positionPk = pk.traderMode(traderId, mode);
      const positionSk = `MARKET#${market}`;
      return {
          TableName: POSITIONS_TABLE,
          Key: marshall({ pk: positionPk, sk: positionSk }),
          UpdateExpression: `
              SET size = :ns,
                  avgEntryPrice = :nae,
                  updatedAt = :ts
              ADD realizedPnl :rpc
          `,
          // Ensure numbers are finite and not NaN before marshalling
          ExpressionAttributeValues: marshall({
              ":ns": newState.newSize, // Assumes newSize is always finite
              ":nae": isFinite(newState.newAvgEntry) ? newState.newAvgEntry : 0,
              ":rpc": isFinite(newState.realizedPnlChange) ? newState.realizedPnlChange : 0,
              ":ts": matchTimestamp,
          }),
      };
  }
  
  
  /** Query opposite-side OPEN/PARTIAL orders */
  export async function loadOpenOrders(
    market: string,
    side: OrderSide,
    mode: TradingMode
  ): Promise<OrderWithKeys[]> {
    const marketModePk = pk.marketMode(market, mode);
    try {
      const resp = await ddb.send(
          new QueryCommand({
          TableName: ORDERS_TABLE,
          KeyConditionExpression: "pk = :pk",
          FilterExpression: "#s IN (:open, :partial) AND #side = :side",
          ExpressionAttributeNames: { "#s": "status", "#side": "side" },
          ExpressionAttributeValues: marshall({
              ":pk": marketModePk, ":open": "OPEN", ":partial": "PARTIAL", ":side": side,
          }),
          // ProjectionExpression: "pk, sk, orderId, traderId, price, qty, filledQty, status, side, createdAt, orderType", // Example projection
          })
      );
  
      const items = (resp.Items ?? []).map((it) => unmarshall(it) as OrderWithKeys);
  
      // In-memory sort with robust price comparison
      items.sort((a, b) => {
          const priceA = a.price;
          const priceB = b.price;
          // Use safe defaults if price is not a finite number
          const numericPriceA = typeof priceA === 'number' && isFinite(priceA) ? priceA : (side === 'BUY' ? Infinity : -Infinity);
          const numericPriceB = typeof priceB === 'number' && isFinite(priceB) ? priceB : (side === 'BUY' ? Infinity : -Infinity);
  
          if (numericPriceA !== numericPriceB) {
              // Standard price priority: BUY seeks lowest ask (ascending sort), SELL seeks highest bid (descending sort)
              // The query loads asks for a BUY taker, bids for a SELL taker.
              // If side is 'BUY' (meaning these are asks from the book), sort ascending.
              // If side is 'SELL' (meaning these are bids from the book), sort descending.
               return side === 'BUY' ? numericPriceA - numericPriceB : numericPriceB - numericPriceA;
          }
          // Time priority if prices are equal or invalid
          return (a.createdAt ?? 0) - (b.createdAt ?? 0); // Default createdAt to 0 if missing
      });
  
      return items;
    } catch (error) {
        console.error(`Error loading open orders for ${market} (${mode}), side ${side}:`, error);
        return []; // Return empty array on error
    }
  }
  
  
  /**
   * Main Matching Engine Logic.
   */
  export async function matchOrder(taker: OrderWithKeys, mode: TradingMode): Promise<void> {
      // --- Pre-computation and Setup ---
      const oppositeSide: OrderSide = taker.side === "BUY" ? "SELL" : "BUY";
      const matchTimestamp = Date.now();
      let remainingQty = taker.qty - taker.filledQty;
  
      if (remainingQty <= 0) return; // Already filled
  
      let synthAddr: string | null = null;
      if (mode === "REAL") {
          synthAddr = await getSynthAddr(taker.market);
          if (!synthAddr) {
              console.error(`CRITICAL: Synth address not found for REAL market ${taker.market}. Aborting match for taker ${taker.orderId}.`);
              return;
          }
      }
  
      const currentTakerPosition = await getCurrentPosition(taker.traderId, taker.market, mode);
      const book = await loadOpenOrders(taker.market, oppositeSide, mode); // Loads orders with price/time priority
      const transactionItems: TransactWriteItem[] = [];
      const pointsToAward = new Map<string, number>(); // <traderPk, points> - For paper points accumulation
      let successfulFills = 0; // Count fills that succeeded blockchain interaction (if applicable)
      let totalFeesForBatch = 0; // Accumulate fees for the batch (in USDC value, not base units yet)
  
      // --- Matching Loop ---
      for (const maker of book) {
          if (remainingQty <= 0) break; // Taker order filled
  
          // Basic safety checks for maker order data integrity
          if (!maker || typeof maker.status !== 'string' || typeof maker.price !== 'number' || !isFinite(maker.price) || typeof maker.qty !== 'number' || typeof maker.filledQty !== 'number') {
              console.warn(`Skipping invalid maker order in loop: ${maker?.orderId}`, maker);
              continue;
          }
          if (maker.status !== "OPEN" && maker.status !== "PARTIAL") continue; // Skip filled/cancelled makers
  
          // Price Cross Check (Limit vs Maker Price)
          const priceAgreed =
              taker.orderType === "MARKET" ||
              (taker.side === "BUY" && (taker.price ?? Infinity) >= maker.price) || // BUY taker hits asks at or below limit
              (taker.side === "SELL" && (taker.price ?? 0) <= maker.price);      // SELL taker hits bids at or above limit
  
          // If limit order price isn't met, and we are sorting asks ascending / bids descending, we can stop checking book
          if (!priceAgreed) {
              if (taker.orderType === "LIMIT") break;
              else continue; // Market order keeps checking
          }
  
          // Determine fill quantity
          const makerAvailableQty = maker.qty - maker.filledQty;
          const fillQty = Math.min(remainingQty, makerAvailableQty); // Already handles positive checks implicitly
          if (fillQty <= 0) continue; // Should not happen if checks above pass, but safety first
  
          const fillPx = maker.price; // Validated as finite number earlier
  
          // Calculate trade value and fees
          const tradeValue = fillQty * fillPx;
          if (!isFinite(tradeValue)) {
              console.warn(`Skipping fill due to non-finite tradeValue: ${fillQty} * ${fillPx}`);
              continue;
          }
          const takerFee = calculateFee(tradeValue);
          const makerFee = calculateFee(tradeValue);
  
          // --- Blockchain Interaction (Conditional for REAL mode) ---
          let blockchainInteractionOk = true;
          if (mode === "REAL" && synthAddr) {
              try {
                  // Convert trade value (fillQty) to base units for synth transfer
                  const amount = BigInt(Math.round(fillQty * (10 ** USDC_DECIMALS)));
                  if (amount <= BigInt(0)) throw new Error("Calculated synth amount is zero or negative.");
  
                  // Logic: If Taker BUYS asset, Taker receives synth, Maker sends synth (burn).
                  // If Taker SELLS asset, Taker sends synth (burn), Maker receives synth.
                  if (taker.side === "BUY") {
                      await vault.mintSynth(synthAddr, taker.traderId, amount);
                      await vault.burnSynth(synthAddr, maker.traderId, amount);
                  } else { // Taker is SELLING
                      await vault.burnSynth(synthAddr, taker.traderId, amount);
                      await vault.mintSynth(synthAddr, maker.traderId, amount);
                  }
              } catch (error) {
                  blockchainInteractionOk = false;
                  console.error(`CRITICAL: Blockchain Interaction Failed! Taker: ${taker.orderId}, Maker: ${maker.orderId}, Synth: ${synthAddr}. Fill Skipped.`, error);
                  continue; // Skip DB updates for this specific fill
              }
          }
          // If blockchain interaction failed, skip the rest of the logic for *this* fill
          if (!blockchainInteractionOk) continue;
  
          successfulFills++;
          totalFeesForBatch += (takerFee + makerFee); // Accumulate fees (USDC value)
  
          // --- Prepare Trade Record ---
          const trade: Trade = {
              tradeId: crypto.randomUUID().replace(/-/g, ""), takerOrderId: taker.orderId, makerOrderId: maker.orderId,
              market: taker.market, price: fillPx, qty: fillQty, timestamp: matchTimestamp,
              side: taker.side, // Taker's side
              takerFee, makerFee,
          };
  
          // --- Calculate Position Updates ---
          const currentMakerPosition = await getCurrentPosition(maker.traderId, maker.market, mode);
          const takerQtyChange = taker.side === 'BUY' ? fillQty : -fillQty;
          const makerQtyChange = maker.side === 'BUY' ? fillQty : -fillQty; // Opposite sign for maker
  
          const takerNewState = calculateNewPositionState(currentTakerPosition, takerQtyChange, fillPx);
          const makerNewState = calculateNewPositionState(currentMakerPosition, makerQtyChange, fillPx);
  
          // Update taker's current position *in memory* for next iteration's calculation
          currentTakerPosition.size = takerNewState.newSize;
          currentTakerPosition.avgEntryPrice = takerNewState.newAvgEntry;
          currentTakerPosition.realizedPnl += takerNewState.realizedPnlChange; // Accumulate realized PnL
  
          // --- Accumulate Paper Points ---
          if (mode === "PAPER") {
              // 1. Volume Points
              const volumePoints = isFinite(tradeValue) ? Math.floor(tradeValue * POINTS_PER_USDC_VOLUME) : 0;
              // 2. PnL Points
              let takerPnlPoints = 0; let makerPnlPoints = 0;
              if (isFinite(takerNewState.realizedPnlChange) && takerNewState.realizedPnlChange > 0) {
                  takerPnlPoints = Math.floor(takerNewState.realizedPnlChange * POINTS_PER_USDC_PNL);
              }
              if (isFinite(makerNewState.realizedPnlChange) && makerNewState.realizedPnlChange > 0) {
                  makerPnlPoints = Math.floor(makerNewState.realizedPnlChange * POINTS_PER_USDC_PNL);
              }
              // 3. & 4. Update map
              const takerPk = pk.traderMode(taker.traderId, "PAPER");
              const makerPk = pk.traderMode(maker.traderId, "PAPER");
              pointsToAward.set(takerPk, (pointsToAward.get(takerPk) ?? 0) + volumePoints + takerPnlPoints);
              pointsToAward.set(makerPk, (pointsToAward.get(makerPk) ?? 0) + volumePoints + makerPnlPoints);
          }
          // --- End Paper Points Accumulation ---
  
  
          // ===== Add Items to DynamoDB Transaction ============================
          // 1️⃣ Update Maker Order Status & filledQty
          const makerNewFilledQty = maker.filledQty + fillQty;
          const makerNewStatus = makerNewFilledQty >= maker.qty ? "FILLED" : "PARTIAL";
          transactionItems.push({
              Update: {
                  TableName: ORDERS_TABLE,
                  Key: marshall({ pk: maker.pk, sk: maker.sk }),
                  UpdateExpression: "SET filledQty = :fq, #s = :ns, updatedAt = :ts",
                  ConditionExpression: "attribute_exists(pk) AND #s IN (:open, :partial)",
                  ExpressionAttributeNames: { "#s": "status" },
                  ExpressionAttributeValues: marshall({
                      ":fq": makerNewFilledQty, ":ns": makerNewStatus, ":ts": matchTimestamp,
                      ":open": "OPEN", ":partial": "PARTIAL",
                  }),
              },
          });
  
          // 2️⃣ Update Taker Order (Handled definitively after loop)
  
          // 3️⃣ Put Trade Row
          transactionItems.push({
              Put: {
                  TableName: TRADES_TABLE,
                  Item: marshall({
                      pk: pk.marketMode(trade.market, mode), sk: `TS#${trade.tradeId}`, ...trade,
                      takerTraderId: taker.traderId, makerTraderId: maker.traderId, mode: mode,
                  }, { removeUndefinedValues: true }),
              },
          });
  
          // 4️⃣ Update Positions (Taker and Maker)
          transactionItems.push({ Update: createPositionUpdateInput(taker.traderId, taker.market, mode, takerNewState, matchTimestamp) });
          transactionItems.push({ Update: createPositionUpdateInput(maker.traderId, maker.market, mode, makerNewState, matchTimestamp) });
  
          // 5️⃣ & 6️⃣ Update Stats (Intraday & Lifetime)
          const statsIntradayPk = pk.marketMode(trade.market, mode);
          const statsIntradaySk = `TS#${Math.floor(matchTimestamp / 60_000) * 60_000}`; // Minute bucket
          const statsIntradayTtl = Math.floor((matchTimestamp + 48 * 3_600_000) / 1_000); // 48h TTL in seconds
          transactionItems.push({
              Update: {
                  TableName: STATS_INTRADAY_TABLE,
                  Key: marshall({ pk: statsIntradayPk, sk: statsIntradaySk }),
                  UpdateExpression: `ADD volume :vol, fees :fees, trades :one SET expireAt = if_not_exists(expireAt, :ttl)`,
                  ExpressionAttributeValues: marshall({
                      ":vol": tradeValue, ":fees": trade.takerFee + trade.makerFee, ":one": 1, ":ttl": statsIntradayTtl,
                  }),
              },
          });
          transactionItems.push({
               Update: {
                   TableName: STATS_LIFETIME_TABLE,
                   Key: marshall({ pk: pk.globalMode(mode), sk: "META" }),
                   UpdateExpression: "ADD volume :vol, fees :fees, trades :one",
                   ExpressionAttributeValues: marshall({
                       ":vol": tradeValue, ":fees": trade.takerFee + trade.makerFee, ":one": 1,
                   }),
               },
           });
          // =====================================================================
  
          remainingQty -= fillQty; // Decrease remaining taker qty
  
      } // --- End of Matching Loop ---
  
      // --- Final Taker Order Update ---
      const totalFilledQty = taker.qty - remainingQty;
      if (totalFilledQty > taker.filledQty) { // Only add update if quantity actually filled in *this* match run
           const finalTakerStatus = remainingQty <= 0 ? "FILLED" : "PARTIAL";
           transactionItems.push({
               Update: {
                   TableName: ORDERS_TABLE, Key: marshall({ pk: taker.pk, sk: taker.sk }),
                   UpdateExpression: "SET filledQty = :fq, #s = :ns, updatedAt = :ts",
                   ConditionExpression: "attribute_exists(pk)", // Check if it still exists (wasn't cancelled concurrently)
                   ExpressionAttributeNames: { "#s": "status" },
                   ExpressionAttributeValues: marshall({
                       ":fq": totalFilledQty, ":ns": finalTakerStatus, ":ts": matchTimestamp,
                   }),
               },
           });
      }
  
      // --- Execute the Main Transaction ---
      let transactionSucceeded = false;
      if (transactionItems.length > 0) {
          try {
              const MAX_TX_ITEMS = 100; // DynamoDB transaction limit
              for (let i = 0; i < transactionItems.length; i += MAX_TX_ITEMS) {
                  const batch = transactionItems.slice(i, i + MAX_TX_ITEMS);
                  await ddb.send(new TransactWriteItemsCommand({ TransactItems: batch }));
              }
              transactionSucceeded = true; // Mark as succeeded only if all batches pass
              if (successfulFills > 0) {
                   console.log(`Match transaction successful for taker ${taker.orderId} (${mode}). Fills included: ${successfulFills}.`);
              }
          } catch (error: any) {
              transactionSucceeded = false; // Explicitly mark as failed
              console.error(`CRITICAL: TransactWriteItems Failed! Taker: ${taker.orderId} (${mode}). Fills attempted: ${successfulFills}.`, error);
              if (error.name === 'TransactionCanceledException') {
                  console.error("Cancellation Reasons:", JSON.stringify(error.CancellationReasons, null, 2));
              }
              // TODO: Implement robust error handling/retry or DLQ strategy.
              // If transaction failed, DO NOT award points or record fees below.
          }
      } else if (successfulFills > 0) {
          // This case means blockchain interaction happened, but no DB updates needed (e.g., order already filled but synth move needed)
          console.warn(`No DynamoDB transaction items generated for taker ${taker.orderId} (${mode}), but ${successfulFills} blockchain interactions occurred.`);
          transactionSucceeded = true; // Consider it successful for fee/point logic if blockchain worked
      }
  
  
      // --- Record Fees On-Chain (Only if REAL mode and transaction succeeded) ---
      if (transactionSucceeded && mode === "REAL" && totalFeesForBatch > 0) {
          try {
              // Convert totalFeesForBatch (USDC value) to base units (BigInt)
              const totalFeesBaseUnits = BigInt(Math.round(totalFeesForBatch * (10 ** USDC_DECIMALS)));
  
              if (totalFeesBaseUnits > BigInt(0)) {
                  console.log(`Recording ${totalFeesBaseUnits} base units of fees to Vault for match batch of taker ${taker.orderId}...`);
                  await vault.recordFees(totalFeesBaseUnits); // Call the Vault function
                  console.log(`Successfully recorded fees on-chain for taker ${taker.orderId}.`);
              }
          } catch (feeError) {
              // Log critical error, but don't fail the whole match process. Needs monitoring.
              console.error(`CRITICAL: Failed to record fees on-chain for taker ${taker.orderId} (${mode}). Amount (USDC Value): ${totalFeesForBatch}. Error:`, feeError);
          }
      }
      // --- End Fee Recording ---
  
  
      // --- Award Accumulated Paper Points (Only if PAPER mode and transaction succeeded) ---
      if (transactionSucceeded && mode === "PAPER" && pointsToAward.size > 0) {
          // console.log(`Attempting to award paper points to ${pointsToAward.size} traders...`);
          for (const [traderPk, points] of pointsToAward.entries()) {
               if (points <= 0) continue; // Skip if no points earned
               try {
                   await ddb.send(
                       new UpdateItemCommand({
                           TableName: TRADERS_TABLE,
                           Key: marshall({ pk: traderPk, sk: "META" }), // Assuming SK is META for trader record
                           UpdateExpression: `
                               SET paperPoints.epoch = if_not_exists(paperPoints.epoch, :initEpoch)
                               ADD paperPoints.totalPoints :points
                           `,
                           ExpressionAttributeValues: marshall({
                               ":points": Math.floor(points), // Ensure integer points
                               ":initEpoch": 1, // Initialize epoch if needed
                           }),
                       })
                   );
                   // console.log(`Successfully awarded ${Math.floor(points)} paper points to ${traderPk}.`);
               } catch (pointError) {
                   // Log error but don't fail the overall process
                   console.error(`Failed to award paper points to trader ${traderPk}:`, pointError);
               }
          }
      }
      // --- End Points Award Logic ---
  
  
      // --- Handle Market Order Remainder (If Applicable and Transaction Succeeded) ---
      if (transactionSucceeded && taker.orderType === "MARKET" && remainingQty > 0 && totalFilledQty < taker.qty) {
          // Determine the status based on the outcome of the transaction batch
          const finalTakerStatus = remainingQty <= 0 ? "FILLED" : "PARTIAL";
          if(finalTakerStatus === "PARTIAL") { // Only cancel if it ended up partial
              console.warn(`Market order ${taker.orderId} (${mode}) partially filled (${totalFilledQty}/${taker.qty}). Insufficient liquidity. Cancelling remainder.`);
              try {
                  // Use the PK/SK known for the taker order
                  await ddb.send(new UpdateItemCommand({
                       TableName: ORDERS_TABLE, Key: marshall({ pk: taker.pk, sk: taker.sk }),
                       UpdateExpression: "SET #s = :cancelled, updatedAt = :ts",
                       ConditionExpression: "#s = :partial", // Only cancel if it's still partial
                       ExpressionAttributeNames: { "#s": "status" },
                       ExpressionAttributeValues: marshall({
                           ":cancelled": "CANCELLED", ":ts": Date.now(), ":partial": "PARTIAL"
                       })
                  }));
              } catch(cancelError: any) {
                   // Ignore ConditionalCheckFailedException (means it was filled/cancelled concurrently)
                   if (cancelError.name !== 'ConditionalCheckFailedException') {
                       console.error(`Failed to auto-cancel partially filled market order ${taker.orderId}:`, cancelError);
                   }
              }
          }
      }
  
  } // --- End of matchOrder function ---
### File: dex/matchers/futures.ts
// dex/matchers/market.ts (Example - Apply similar changes to options.ts, perps.ts, futures.ts)
import { SQSHandler, SQSEvent } from "aws-lambda";
import { matchOrder } from "./matchEngine"; // Assuming matchOrder is updated
import {
    OrderQueueMessage,
    TradingMode, // Import TradingMode
    FutureOrder
} from "../../src/lib/interfaces";
import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
import { Resource } from "sst";

const sns = new SNSClient({});

export const handler: SQSHandler = async (event: SQSEvent) => {
  for (const rec of event.Records) {
    try {
        const msg = JSON.parse(rec.body) as OrderQueueMessage; // Parse the full message

        // Extract order details and the mode
        const order = msg.order as FutureOrder; // Cast to appropriate types for this matcher
        const mode: TradingMode = msg.mode;
        const market: string = msg.market; // Or msg.order.market
        const orderId: string = msg.orderId; // Or msg.order.orderId

        if (!mode) {
             console.error(`Matcher Error: Missing mode in SQS message for orderId ${orderId}. Skipping.`);
             continue;
        }

        // Call the updated matchOrder function, passing the mode
        await matchOrder(order, mode); // Pass mode to the matching engine

        // Fan-out WebSocket update via SNS (include mode in the SNS message)
        await sns.send(
          new PublishCommand({
            TopicArn: Resource.MarketUpdatesTopic.arn,
            Message: JSON.stringify({
              type: "orderUpdate", // Keep message type consistent
              market: market,
              orderId: orderId,
              mode: mode, // Include mode in the WS payload
              // Add other relevant order details if needed by WS clients
              status: order.status // Example: Current status might be useful
            }),
            // Optional: Use MessageAttributes for filtering on the SNS subscriber side if needed
            // MessageAttributes: {
            //     'mode': { DataType: 'String', StringValue: mode },
            //     'market': { DataType: 'String', StringValue: market }
            // }
          })
        );
    } catch (error) {
        console.error(`Error processing SQS message for order: ${rec.messageId}`, error);
        console.error("Failed message body:", rec.body);
        // Implement retry or DLQ logic as needed
        // Re-throwing the error might cause SQS to retry the message automatically (depending on Lambda config)
        // throw error;
    }
  }
};
### File: dex/matchers/market.ts
// dex/matchers/market.ts (Example - Apply similar changes to options.ts, perps.ts, futures.ts)
import { SQSHandler, SQSEvent } from "aws-lambda";
import { matchOrder } from "./matchEngine"; // Assuming matchOrder is updated
import {
    OrderQueueMessage,
    TradingMode, // Import TradingMode
    MarketOrder, // Specific types if needed for casting
    LimitOrder
} from "../../src/lib/interfaces";
import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
import { Resource } from "sst";

const sns = new SNSClient({});

export const handler: SQSHandler = async (event: SQSEvent) => {
  for (const rec of event.Records) {
    try {
        const msg = JSON.parse(rec.body) as OrderQueueMessage; // Parse the full message

        // Extract order details and the mode
        const order = msg.order as (MarketOrder | LimitOrder); // Cast to appropriate types for this matcher
        const mode: TradingMode = msg.mode;
        const market: string = msg.market; // Or msg.order.market
        const orderId: string = msg.orderId; // Or msg.order.orderId

        if (!mode) {
             console.error(`Matcher Error: Missing mode in SQS message for orderId ${orderId}. Skipping.`);
             continue;
        }

        // Call the updated matchOrder function, passing the mode
        await matchOrder(order, mode); // Pass mode to the matching engine

        // Fan-out WebSocket update via SNS (include mode in the SNS message)
        await sns.send(
          new PublishCommand({
            TopicArn: Resource.MarketUpdatesTopic.arn,
            Message: JSON.stringify({
              type: "orderUpdate", // Keep message type consistent
              market: market,
              orderId: orderId,
              mode: mode, // Include mode in the WS payload
              // Add other relevant order details if needed by WS clients
              status: order.status // Example: Current status might be useful
            }),
            // Optional: Use MessageAttributes for filtering on the SNS subscriber side if needed
            // MessageAttributes: {
            //     'mode': { DataType: 'String', StringValue: mode },
            //     'market': { DataType: 'String', StringValue: market }
            // }
          })
        );
    } catch (error) {
        console.error(`Error processing SQS message for order: ${rec.messageId}`, error);
        console.error("Failed message body:", rec.body);
        // Implement retry or DLQ logic as needed
        // Re-throwing the error might cause SQS to retry the message automatically (depending on Lambda config)
        // throw error;
    }
  }
};
### File: dex/matchers/options.ts
// dex/matchers/market.ts (Example - Apply similar changes to options.ts, perps.ts, futures.ts)
import { SQSHandler, SQSEvent } from "aws-lambda";
import { matchOrder } from "./matchEngine"; // Assuming matchOrder is updated
import {
    OrderQueueMessage,
    TradingMode, // Import TradingMode
    OptionOrder
} from "../../src/lib/interfaces";
import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
import { Resource } from "sst";

const sns = new SNSClient({});

export const handler: SQSHandler = async (event: SQSEvent) => {
  for (const rec of event.Records) {
    try {
        const msg = JSON.parse(rec.body) as OrderQueueMessage; // Parse the full message

        // Extract order details and the mode
        const order = msg.order as OptionOrder; // Cast to appropriate types for this matcher
        const mode: TradingMode = msg.mode;
        const market: string = msg.market; // Or msg.order.market
        const orderId: string = msg.orderId; // Or msg.order.orderId

        if (!mode) {
             console.error(`Matcher Error: Missing mode in SQS message for orderId ${orderId}. Skipping.`);
             continue;
        }

        // Call the updated matchOrder function, passing the mode
        await matchOrder(order, mode); // Pass mode to the matching engine

        // Fan-out WebSocket update via SNS (include mode in the SNS message)
        await sns.send(
          new PublishCommand({
            TopicArn: Resource.MarketUpdatesTopic.arn,
            Message: JSON.stringify({
              type: "orderUpdate", // Keep message type consistent
              market: market,
              orderId: orderId,
              mode: mode, // Include mode in the WS payload
              // Add other relevant order details if needed by WS clients
              status: order.status // Example: Current status might be useful
            }),
            // Optional: Use MessageAttributes for filtering on the SNS subscriber side if needed
            // MessageAttributes: {
            //     'mode': { DataType: 'String', StringValue: mode },
            //     'market': { DataType: 'String', StringValue: market }
            // }
          })
        );
    } catch (error) {
        console.error(`Error processing SQS message for order: ${rec.messageId}`, error);
        console.error("Failed message body:", rec.body);
        // Implement retry or DLQ logic as needed
        // Re-throwing the error might cause SQS to retry the message automatically (depending on Lambda config)
        // throw error;
    }
  }
};
### File: dex/ws/fanOut.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/ws/fanOut.ts
import { SNSHandler, SNSEvent } from "aws-lambda";
import {
  DynamoDBClient,
  ScanCommand, // Note: Scan is inefficient. GSI recommended for production.
  DeleteItemCommand,
  ScanCommandInput
} from "@aws-sdk/client-dynamodb";
import {
  ApiGatewayManagementApiClient,
  PostToConnectionCommand,
  GoneException, // Import specific exception
} from "@aws-sdk/client-apigatewaymanagementapi";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";
import type { TradingMode } from "../../src/lib/interfaces"; // Import TradingMode

const ddb = new DynamoDBClient({});
const WS_TABLE = Resource.WSConnectionsTable.name;

// API Gateway Management API Client - endpoint injected by SST link
const apigw = new ApiGatewayManagementApiClient({
  endpoint: process.env.WS_API_URL, // Provided by wsApi.link() in sst.config.ts
});

// Interface for the expected structure of the SNS message payload
interface SnsPayload {
    type: string; // e.g., "orderUpdate", "fundingRateUpdate"
    mode: TradingMode; // Crucial: Mode must be included by the publisher (matcher/CRON)
    market?: string; // e.g., "BTC-PERP" - for market channels
    traderId?: string; // e.g., "uuid123abc" - for trader channels
    // ... other payload data (orderId, status, fundingRate, etc.)
    [key: string]: any; // Allow other properties
}


export const handler: SNSHandler = async (ev: SNSEvent) => {
  // Process each message received from SNS (usually just one unless batching is enabled)
  for (const record of ev.Records) {
      let payload: SnsPayload;
      try {
          payload = JSON.parse(record.Sns.Message) as SnsPayload;

          // --- Validate Payload ---
          if (!payload.mode || (payload.mode !== "REAL" && payload.mode !== "PAPER")) {
              console.error("FanOut Error: SNS message missing or invalid 'mode'. Skipping.", record.Sns.Message);
              continue; // Skip this message
          }
          if (!payload.type || (!payload.market && !payload.traderId)) {
               console.error("FanOut Error: SNS message missing type or identifier (market/traderId). Skipping.", record.Sns.Message);
               continue;
          }
          // --- End Validation ---

      } catch (error) {
          console.error("FanOut Error: Failed to parse SNS message JSON.", error, record.Sns.Message);
          continue; // Skip malformed messages
      }

      // --- Construct Target Channel String ---
      let targetChannel: string;
      if (payload.market) {
          targetChannel = `market.${payload.market}.${payload.mode}`; // e.g., market.BTC-PERP.PAPER
      } else if (payload.traderId) {
          targetChannel = `trader.${payload.traderId}.${payload.mode}`; // e.g., trader.uuid123.REAL
      } else {
          // Should not happen due to validation above, but good practice
          console.error("FanOut Logic Error: No market or traderId found in validated payload.", payload);
          continue;
      }
      // --- End Channel Construction ---


      // --- Find Subscribed Connections ---
      // PERFORMANCE NOTE: Scan is inefficient for many connections (> few thousand).
      // Create a GSI on the `channel` attribute for efficient lookups in production.
      // GSI Example: PK=channel, SK=pk (connectionId)
      let connections: { pk: string }[] = [];
      let lastEvaluatedKey: Record<string, any> | undefined = undefined;

      try {
          console.log(`FanOut: Searching connections for channel: ${targetChannel}`);
          do {
              const scanParams: ScanCommandInput = {
                  TableName: WS_TABLE,
                  // Filter based on the *exact* channel string (which includes mode)
                  FilterExpression: "#chan = :channelVal",
                  ExpressionAttributeNames: { "#chan": "channel" },
                  ExpressionAttributeValues: marshall({ ":channelVal": targetChannel }),
                  ProjectionExpression: "pk", // Only need the connection ID (pk)
                  ExclusiveStartKey: lastEvaluatedKey,
              };
              const { Items, LastEvaluatedKey } = await ddb.send(new ScanCommand(scanParams));

              if (Items) {
                  connections = connections.concat(
                      Items.map(item => unmarshall(item) as { pk: string })
                  );
              }
              lastEvaluatedKey = LastEvaluatedKey;
          } while (lastEvaluatedKey);

          console.log(`FanOut: Found ${connections.length} connections for ${targetChannel}.`);

      } catch (error) {
          console.error(`FanOut Error: Failed to scan WSConnectionsTable for channel ${targetChannel}:`, error);
          continue; // Skip processing this message if connections can't be fetched
      }
      // --- End Finding Connections ---


      // --- Broadcast Message ---
      const broadcastPromises: Promise<any>[] = [];
      const messageData = Buffer.from(record.Sns.Message); // Send the original payload

      for (const conn of connections) {
          const connectionId = conn.pk.slice(3); // Extract ID from "WS#<connectionId>"

          const postPromise = apigw.send(
              new PostToConnectionCommand({
                  ConnectionId: connectionId,
                  Data: messageData,
              })
          ).catch(async (error: any) => {
              // Handle stale connections (client disconnected)
              if (error instanceof GoneException || error.statusCode === 410) {
                  console.log(`FanOut: Stale connection ${connectionId}. Deleting.`);
                  // Attempt to delete the stale connection record
                  try {
                      await ddb.send(new DeleteItemCommand({
                          TableName: WS_TABLE,
                          Key: marshall({ pk: conn.pk, sk: "META" }), // Use full key
                      }));
                  } catch (deleteError) {
                      console.error(`FanOut Error: Failed to delete stale connection ${connectionId}:`, deleteError);
                  }
              } else {
                  // Log other errors during broadcasting
                  console.error(`FanOut Error: Failed to post to connection ${connectionId}:`, error);
              }
          });
          broadcastPromises.push(postPromise);
      } // End broadcast loop

      // Wait for all broadcasts for this message to attempt completion
      await Promise.allSettled(broadcastPromises);

  } // End SNS record loop
};
### File: dex/ws/disconnect.ts
import {
  APIGatewayProxyWebsocketEventV2,
  APIGatewayProxyResultV2,
} from "aws-lambda";
import { DynamoDBClient, DeleteItemCommand } from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";

const ddb = new DynamoDBClient({});

export const handler = async (
  ev: APIGatewayProxyWebsocketEventV2
): Promise<APIGatewayProxyResultV2> => {
  const { connectionId } = ev.requestContext;

  await ddb.send(
    new DeleteItemCommand({
      TableName: Resource.WSConnectionsTable.name,
      Key: marshall({ pk: `WS#${connectionId}`, sk: "META" }),
    })
  );

  return { statusCode: 200 };
};
### File: dex/ws/default.ts
import {
  APIGatewayProxyResultV2,
} from "aws-lambda";

export const handler = async (
): Promise<APIGatewayProxyResultV2> => {
  return {
    statusCode: 200,
    body: JSON.stringify({ ok: false, msg: "unknown action" }),
  };
};
### File: dex/ws/connect.ts
// dex/ws/connect.ts
import {
  APIGatewayProxyWebsocketEventV2,
  APIGatewayProxyResultV2,
} from "aws-lambda";
import {
  DynamoDBClient,
  QueryCommand,
  PutItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";

const ddb = new DynamoDBClient({});
const TABLE   = Resource.TradersTable.name;
const WS_TBL  = Resource.WSConnectionsTable.name;

export const handler = async (
  ev: APIGatewayProxyWebsocketEventV2
): Promise<APIGatewayProxyResultV2> => {
  /* ── 1️⃣  pull ?traderAk=xxxxx from query‑string */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const traderAk = (ev as any).queryStringParameters?.traderAk;
  if (!traderAk) {
    return { statusCode: 401, body: "missing traderAk" };
  }

  /* ── 2️⃣ look up trader in GSI `ByAk` */
  const res = await ddb.send(
    new QueryCommand({
      TableName: TABLE,
      IndexName: "ByAk",
      KeyConditionExpression: "traderAk = :ak",
      ExpressionAttributeValues: { ":ak": { S: traderAk } },
      ProjectionExpression: "traderId, #st",
      ExpressionAttributeNames: { "#st": "status" },
      Limit: 1,
      ConsistentRead: false,
    })
  );

  const item = res.Items?.[0];
  if (!item) {
    return { statusCode: 401, body: "invalid traderAk" };
  }

  const { traderId, status } = unmarshall(item) as {
    traderId: string;
    status?: "ACTIVE" | "SUSPENDED";
  };

  /* ── 3️⃣ optionally enforce status */
  if (status && status !== "ACTIVE") {
    return { statusCode: 403, body: "trader suspended" };
  }

  /* ── 4️⃣ record the connection (24 h TTL) */
  const ttl = Math.floor(Date.now() / 1_000) + 24 * 60 * 60;

  await ddb.send(
    new PutItemCommand({
      TableName: WS_TBL,
      Item: marshall({
        pk: `WS#${ev.requestContext.connectionId}`,
        sk: "META",
        traderId,
        traderAk,
        channel: null,
        expiresAt: ttl,
      }),
    })
  );

  return { statusCode: 200 };
};
### File: dex/ws/subscribe.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/ws/subscribe.ts
import {
  APIGatewayProxyWebsocketEventV2,
  APIGatewayProxyResultV2,
} from "aws-lambda";
import {
  DynamoDBClient,
  UpdateItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";
import type { TradingMode } from "../../src/lib/interfaces"; // Import TradingMode

const ddb = new DynamoDBClient({});
const WS_TABLE = Resource.WSConnectionsTable.name;

// Interface for the expected message body from the client
interface ClientSubscribeMsg {
  action: "subscribe"; // Ensure action is subscribe
  /** Expected format: <type>.<identifier>.<mode>
   * e.g., "market.BTC-PERP.REAL"
   * e.g., "trader.uuid123abc.PAPER"
   */
  channel: string;
}

/**
 * Parses the channel string to extract type, identifier, and mode.
 * Returns null if the format is invalid.
 */
function parseChannelString(channel: string): { type: string; identifier: string; mode: TradingMode } | null {
    const parts = channel.split('.');
    if (parts.length !== 3) return null;

    const [type, identifier, modeStr] = parts;
    const mode = modeStr.toUpperCase();

    if ((type !== 'market' && type !== 'trader') || !identifier || (mode !== 'REAL' && mode !== 'PAPER')) {
        return null; // Invalid type, missing identifier, or invalid mode
    }

    return { type, identifier, mode: mode as TradingMode };
}


export const handler = async (
  ev: APIGatewayProxyWebsocketEventV2
): Promise<APIGatewayProxyResultV2> => {
  const { connectionId } = ev.requestContext;

  try {
    const body = JSON.parse(ev.body ?? "{}") as Partial<ClientSubscribeMsg>;

    // Validate input message
    if (!body || body.action !== "subscribe" || !body.channel) {
      console.warn(`Invalid subscribe message received from ${connectionId}:`, ev.body);
      // Optionally send error back to client via PostToConnectionCommand
      return { statusCode: 400, body: JSON.stringify({ error: "Invalid message format. Expects {action: 'subscribe', channel: '<type>.<id>.<mode>'}" }) };
    }

    const { channel } = body;

    // --- Parse Channel and Mode ---
    const parsedChannel = parseChannelString(channel);

    if (!parsedChannel) {
         console.warn(`Invalid channel format from ${connectionId}: ${channel}`);
         return { statusCode: 400, body: JSON.stringify({ error: "Invalid channel format. Use <type>.<id>.<mode> (e.g., market.BTC-PERP.REAL)" }) };
    }
    const { mode } = parsedChannel;
    // --- End Parsing ---


    // Update the connection record in DynamoDB
    await ddb.send(
      new UpdateItemCommand({
        TableName: WS_TABLE,
        Key: marshall({
            pk: `WS#${connectionId}`,
            sk: "META" // Assuming SK is always 'META'
        }),
        // Set the full channel string and the extracted mode
        UpdateExpression: "SET #chan = :channel, #cMode = :mode, #updAt = :ts",
        ExpressionAttributeNames: {
            "#chan": "channel",     // Attribute name for the full channel string
            "#cMode": "channelMode", // Attribute name for the extracted mode
            "#updAt": "updatedAt",  // Track last update time
        },
        ExpressionAttributeValues: marshall({
            ":channel": channel, // Store the full string like "market.BTC-PERP.REAL"
            ":mode": mode,       // Store the extracted mode "REAL" or "PAPER"
            ":ts": Date.now()
        }),
        // ConditionExpression: "attribute_exists(pk)" // Ensure the connection record exists
      })
    );

    console.log(`Connection ${connectionId} subscribed to channel: ${channel} (Mode: ${mode})`);
    return { statusCode: 200, body: JSON.stringify({ success: true, subscribedTo: channel }) };

  } catch (error: any) {
      console.error(`Error processing subscribe request for ${connectionId}:`, error);
       // Check for specific DynamoDB errors if needed
       // if (error.name === 'ResourceNotFoundException') { ... }
       // if (error.name === 'ConditionalCheckFailedException') { ... } // If ConditionExpression is used
       return { statusCode: 500, body: JSON.stringify({ error: "Internal server error during subscription." }) };
  }
};
### File: dex/cron/optionExpiry.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/cron/optionExpiry.ts
import {
    DynamoDBClient,
    QueryCommand,
    QueryCommandInput,
    UpdateItemCommand,
    ScanCommand,
    ScanCommandInput,
  } from "@aws-sdk/client-dynamodb";
  import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
  import { Resource } from "sst";
  import {
    MarketMeta,
    Position,
    TradingMode,
    PriceSnapshot,
  } from "../../src/lib/interfaces";
  import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
  import { pk as pkHelper } from "../matchers/matchEngine";
  
  // Internal types including DynamoDB keys
  type MarketMetaWithOptions = MarketMeta & {
    pk: string;
    sk: string;
    strike?: number;
    optionType?: "CALL" | "PUT";
  };
  type PositionWithKeys = Position & { pk: string; sk: string };
  
  const ddb = new DynamoDBClient({});
  const sns = new SNSClient({});
  
  const MARKETS_TABLE = Resource.MarketsTable.name;
  const POSITIONS_TABLE = Resource.PositionsTable.name;
  const BALANCES_TABLE = Resource.BalancesTable.name;
  const PRICES_TABLE = Resource.PricesTable.name;
  const MARKET_UPDATES_TOPIC_ARN = Resource.MarketUpdatesTopic.arn;
  
  const USDC_DECIMALS_FACTOR = 1_000_000; // Assuming 6 decimals for USDC
  
  /** Fetch most recent oracle price for the underlying asset for settlement */
  async function getSettlementPrice(asset: string): Promise<number | null> {
    try {
      const { Items } = await ddb.send(
        new QueryCommand({
          TableName: PRICES_TABLE,
          KeyConditionExpression: "pk = :pk",
          ExpressionAttributeValues: marshall({ ":pk": pkHelper.asset(asset) }),
          ScanIndexForward: false, // Newest first
          Limit: 1,
        })
      );
      if (!Items?.[0]) {
        console.warn(`[OptionExpiry] No oracle price found for settlement of asset: ${asset}`);
        return null;
      }
      const priceData = unmarshall(Items[0]) as PriceSnapshot;
      return priceData.price;
    } catch (error) {
      console.error(`[OptionExpiry] Error fetching settlement price for ${asset}:`, error);
      return null;
    }
  }
  
  /** Publish market state update via SNS */
  async function publishMarketStateUpdate(
    marketSymbol: string,
    mode: TradingMode,
    newStatus: "DELISTED" | "EXPIRED"
  ) {
    try {
      await sns.send(new PublishCommand({
        TopicArn: MARKET_UPDATES_TOPIC_ARN,
        Message: JSON.stringify({
          type: "marketStateUpdate",
          market: marketSymbol,
          mode: mode,
          status: newStatus,
          timestamp: Date.now(),
        }),
      }));
    } catch (error) {
      console.error(`[OptionExpiry] Failed to publish market state update for ${marketSymbol} (${mode}):`, error);
    }
  }
  
  export const handler = async (): Promise<void> => {
    const now = Date.now();
    console.log(`[OptionExpiry] CRON starting at ${new Date(now).toISOString()}`);
  
    let expiredOptionMarkets: MarketMetaWithOptions[] = [];
    let lastEvaluatedKeyMarkets: Record<string, any> | undefined = undefined;
  
    try {
      do {
        const queryParams: QueryCommandInput = {
          TableName: MARKETS_TABLE,
          IndexName: "ByStatusMode",
          KeyConditionExpression: "#s = :active",
          FilterExpression: "#t = :option AND expiryTs < :now",
          ExpressionAttributeNames: { "#s": "status", "#t": "type" },
          ExpressionAttributeValues: marshall({
            ":active": "ACTIVE",
            ":option": "OPTION",
            ":now": now,
          }),
          ExclusiveStartKey: lastEvaluatedKeyMarkets,
        };
        const { Items, LastEvaluatedKey } = await ddb.send(new QueryCommand(queryParams));
        if (Items) {
          expiredOptionMarkets = expiredOptionMarkets.concat(
            Items.map((item) => unmarshall(item) as MarketMetaWithOptions)
          );
        }
        lastEvaluatedKeyMarkets = LastEvaluatedKey;
      } while (lastEvaluatedKeyMarkets);
  
      console.log(`[OptionExpiry] Found ${expiredOptionMarkets.length} expired OPTION markets.`);
    } catch (error) {
      console.error("[OptionExpiry] Error scanning for expired OPTION markets:", error);
      return;
    }
  
    for (const market of expiredOptionMarkets) {
      if (!market.pk || !market.symbol || market.strike === undefined || !market.optionType) {
        console.warn(`[OptionExpiry] Skipping market with invalid/missing option data:`, market);
        continue;
      }
      const pkParts = market.pk.split("#");
      if (pkParts.length !== 3) {
        console.warn(`[OptionExpiry] Skipping market with invalid PK format: ${market.pk}`);
        continue;
      }
      const mode = pkParts[2] as TradingMode;
      const underlyingAsset = market.symbol.split("-")[0];
  
      console.log(`[OptionExpiry] Processing expiry for: ${market.symbol} (${mode})`);
  
      const settlementPx = await getSettlementPrice(underlyingAsset);
      if (settlementPx === null) {
        console.error(
          `[OptionExpiry]  CRITICAL: Cannot settle ${market.symbol} (${mode}) - failed to get settlement price for ${underlyingAsset}. Skipping settlement for this market.`
        );
        continue;
      }
      console.log(`[OptionExpiry]  Settlement Price for ${underlyingAsset}: ${settlementPx}`);
  
      let intrinsicValue = 0;
      if (market.optionType === "CALL") {
        intrinsicValue = Math.max(0, settlementPx - market.strike);
      } else { // PUT
        intrinsicValue = Math.max(0, market.strike - settlementPx);
      }
      const isITM = intrinsicValue > 0;
  
      console.log(
        `[OptionExpiry]  Market: ${market.symbol}, Strike: ${market.strike}, Type: ${market.optionType}, Intrinsic Value: ${intrinsicValue.toFixed(
          6
        )}, ITM: ${isITM}`
      );
  
      let positionsToExpire: PositionWithKeys[] = [];
      let lastPositionKey: Record<string, any> | undefined = undefined;
      const marketFilterSk = `MARKET#${market.symbol}`;
  
      try {
        do {
          const scanParams: ScanCommandInput = {
            TableName: POSITIONS_TABLE,
            FilterExpression: "sk = :marketSK AND begins_with(pk, :traderModePrefix) AND size <> :zero",
            ExpressionAttributeValues: marshall({
              ":marketSK": marketFilterSk,
              ":traderModePrefix": `TRADER#`,
              ":zero": 0,
            }),
            ExclusiveStartKey: lastPositionKey,
          };
          const { Items, LastEvaluatedKey } = await ddb.send(new ScanCommand(scanParams));
          if (Items) {
            const currentModeSuffix = `#${mode}`;
            positionsToExpire = positionsToExpire.concat(
              Items.map((item) => unmarshall(item) as PositionWithKeys)
                   .filter(pos => pos.pk?.endsWith(currentModeSuffix))
            );
          }
          lastPositionKey = LastEvaluatedKey;
        } while (lastPositionKey);
        console.log(`[OptionExpiry]  Found ${positionsToExpire.length} positions to expire/settle for ${market.symbol} (${mode}).`);
      } catch (error) {
        console.error(
          `[OptionExpiry]  Error scanning positions for expiry of ${market.symbol} (${mode}):`,
          error
        );
        continue;
      }
  
      const settlementPromises: Promise<any>[] = [];
  
      for (const pos of positionsToExpire) {
        if (!pos.pk || pos.size === 0) continue;
  
        const traderId = pos.pk.split("#")[1];
        const isLong = pos.size > 0;
        let payoutUsdcValue = 0;
  
        if (isITM) {
          payoutUsdcValue = Math.abs(pos.size) * intrinsicValue;
          const balanceChangeUsdcValue = isLong ? payoutUsdcValue : -payoutUsdcValue;
          const balanceChangeBaseUnits = BigInt(Math.round(balanceChangeUsdcValue * USDC_DECIMALS_FACTOR));
  
          if (balanceChangeBaseUnits !== BigInt(0)) {
              console.log(
                  `[OptionExpiry]    Trader ${traderId}: Size ${pos.size}. Payout (USDC Value) ${balanceChangeUsdcValue.toFixed(6)}, Balance Change (Base Units) ${balanceChangeBaseUnits}`
              );
              const balancePk = pos.pk;
              const balanceSk = pkHelper.asset("USDC");
              const balanceUpdatePromise = ddb.send(
                  new UpdateItemCommand({
                  TableName: BALANCES_TABLE,
                  Key: marshall({ pk: balancePk, sk: balanceSk }),
                  UpdateExpression: "ADD balance :payout",
                  ExpressionAttributeValues: marshall({ ":payout": balanceChangeBaseUnits }),
                  })
              ).catch((err) => {
                  console.error(
                  `[OptionExpiry]    Failed balance update for ${traderId} (${market.symbol}, ${mode}):`,
                  err
                  );
              });
              settlementPromises.push(balanceUpdatePromise);
          }
        } else {
          console.log(`[OptionExpiry]    Trader ${traderId}: Size ${pos.size}, OTM/ATM - No intrinsic value payout.`);
        }
  
        const realizedPnlChangeUsdcValue = isLong ? payoutUsdcValue : -payoutUsdcValue;
        const realizedPnlChangeBaseUnits = BigInt(Math.round(realizedPnlChangeUsdcValue * USDC_DECIMALS_FACTOR));
  
        const positionUpdatePromise = ddb.send(
          new UpdateItemCommand({
            TableName: POSITIONS_TABLE,
            Key: marshall({ pk: pos.pk, sk: pos.sk }),
            UpdateExpression: `SET size = :zero, avgEntryPrice = :zero, #updAt = :now ADD realizedPnl :rPnl`,
            ExpressionAttributeNames: { "#updAt": "updatedAt" },
            ExpressionAttributeValues: marshall({
              ":zero": 0,
              ":now": now,
              ":rPnl": realizedPnlChangeBaseUnits,
            }),
          })
        ).catch((err) => {
          console.error(
            `[OptionExpiry]    Failed position update for ${traderId} (${market.symbol}, ${mode}):`,
            err
          );
        });
        settlementPromises.push(positionUpdatePromise);
  
      } // End position settlement loop
  
      if (settlementPromises.length > 0) {
          await Promise.allSettled(settlementPromises);
           console.log(`[OptionExpiry]  Processed ${settlementPromises.length} DB updates for ${market.symbol} (${mode}).`);
      }
  
      const finalMarketStatus = "DELISTED";
      try {
        console.log(`[OptionExpiry]  Marking market ${market.symbol} (${mode}) as ${finalMarketStatus}.`);
        await ddb.send(
          new UpdateItemCommand({
            TableName: MARKETS_TABLE,
            Key: marshall({ pk: market.pk, sk: market.sk }),
            UpdateExpression: "SET #s = :newStatus, #updAt = :now",
            ConditionExpression: "#s = :active",
            ExpressionAttributeNames: { "#s": "status", "#updAt": "updatedAt" },
            ExpressionAttributeValues: marshall({
              ":newStatus": finalMarketStatus,
              ":active": "ACTIVE",
              ":now": now,
            }),
          })
        );
        await publishMarketStateUpdate(market.symbol, mode, finalMarketStatus);
      } catch (error: any) {
        if (error.name !== "ConditionalCheckFailedException") {
          console.error(
            `[OptionExpiry]  Error marking market ${market.symbol} (${mode}) as ${finalMarketStatus}:`,
            error
          );
        } else {
          console.log(
            `[OptionExpiry]  Market ${market.symbol} (${mode}) was likely already marked ${finalMarketStatus}.`
          );
        }
      }
    } // End market loop
  
    console.log(`[OptionExpiry] CRON finished at ${new Date().toISOString()}`);
  };
### File: dex/cron/futureExpiry.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/cron/futureExpiry.ts
import {
    DynamoDBClient,
    QueryCommand,
    QueryCommandInput,
    UpdateItemCommand,
    ScanCommand,
    ScanCommandInput,
  } from "@aws-sdk/client-dynamodb";
  import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
  import { Resource } from "sst";
  // No vaultHelper needed if futures contracts aren't separate synths to be burned.
  import {
    MarketMeta,
    Position,
    TradingMode,
    PriceSnapshot,
  } from "../../src/lib/interfaces";
  import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
  import { pk as pkHelper } from "../matchers/matchEngine";
  
  // Internal types
  type MarketMetaWithKeys = MarketMeta & { pk: string; sk: string };
  type PositionWithKeys = Position & { pk: string; sk: string };
  
  const ddb = new DynamoDBClient({});
  const sns = new SNSClient({});
  
  const MARKETS_TABLE = Resource.MarketsTable.name;
  const POSITIONS_TABLE = Resource.PositionsTable.name;
  const BALANCES_TABLE = Resource.BalancesTable.name;
  const PRICES_TABLE = Resource.PricesTable.name;
  const MARKET_UPDATES_TOPIC_ARN = Resource.MarketUpdatesTopic.arn;
  
  const USDC_DECIMALS_FACTOR = 1_000_000; // Assuming 6 decimals for USDC
  
  /** Fetch most recent oracle price for the underlying asset for settlement */
  async function getSettlementPrice(asset: string): Promise<number | null> {
    try {
      const { Items } = await ddb.send(
        new QueryCommand({
          TableName: PRICES_TABLE,
          KeyConditionExpression: "pk = :pk",
          ExpressionAttributeValues: marshall({ ":pk": pkHelper.asset(asset) }),
          ScanIndexForward: false, // Newest first
          Limit: 1,
        })
      );
      if (!Items?.[0]) {
        console.warn(`[FutureExpiry] No oracle price found for settlement of asset: ${asset}`);
        return null;
      }
      const priceData = unmarshall(Items[0]) as PriceSnapshot;
      return priceData.price;
    } catch (error) {
      console.error(`[FutureExpiry] Error fetching settlement price for ${asset}:`, error);
      return null;
    }
  }
  
  /** Publish market state update via SNS */
  async function publishMarketStateUpdate(
    marketSymbol: string,
    mode: TradingMode,
    newStatus: "DELISTED" | "EXPIRED"
  ) {
    try {
      await sns.send(new PublishCommand({
        TopicArn: MARKET_UPDATES_TOPIC_ARN,
        Message: JSON.stringify({
          type: "marketStateUpdate",
          market: marketSymbol,
          mode: mode,
          status: newStatus,
          timestamp: Date.now(),
        }),
      }));
    } catch (error) {
      console.error(`[FutureExpiry] Failed to publish market state update for ${marketSymbol} (${mode}):`, error);
    }
  }
  
  export const handler = async (): Promise<void> => {
    const now = Date.now();
    console.log(`[FutureExpiry] CRON starting at ${new Date(now).toISOString()}`);
  
    let expiredFuturesMarkets: MarketMetaWithKeys[] = [];
    let lastEvaluatedKeyMarkets: Record<string, any> | undefined = undefined;
  
    try {
      do {
        const queryParams: QueryCommandInput = {
          TableName: MARKETS_TABLE,
          IndexName: "ByStatusMode",
          KeyConditionExpression: "#s = :active",
          FilterExpression: "#t = :future AND expiryTs < :now", // Active FUTURE markets past expiry
          ExpressionAttributeNames: { "#s": "status", "#t": "type" },
          ExpressionAttributeValues: marshall({
            ":active": "ACTIVE",
            ":future": "FUTURE",
            ":now": now,
          }),
          ExclusiveStartKey: lastEvaluatedKeyMarkets,
        };
        const { Items, LastEvaluatedKey } = await ddb.send(new QueryCommand(queryParams));
        if (Items) {
          expiredFuturesMarkets = expiredFuturesMarkets.concat(
            Items.map((item) => unmarshall(item) as MarketMetaWithKeys)
          );
        }
        lastEvaluatedKeyMarkets = LastEvaluatedKey;
      } while (lastEvaluatedKeyMarkets);
  
      console.log(`[FutureExpiry] Found ${expiredFuturesMarkets.length} expired FUTURE markets.`);
    } catch (error) {
      console.error("[FutureExpiry] Error scanning for expired FUTURE markets:", error);
      return;
    }
  
    for (const market of expiredFuturesMarkets) {
      if (!market.pk || !market.symbol) {
        console.warn(`[FutureExpiry] Skipping market with invalid data:`, market);
        continue;
      }
      const pkParts = market.pk.split("#");
      if (pkParts.length !== 3) {
        console.warn(`[FutureExpiry] Skipping market with invalid PK format: ${market.pk}`);
        continue;
      }
      const mode = pkParts[2] as TradingMode;
      const underlyingAsset = market.symbol.split("-")[0]; // e.g., BTC from BTC-JUN24
  
      console.log(`[FutureExpiry] Processing expiry for: ${market.symbol} (${mode})`);
  
      const settlementPx = await getSettlementPrice(underlyingAsset);
      if (settlementPx === null) {
        console.error(
          `[FutureExpiry]  CRITICAL: Cannot settle ${market.symbol} (${mode}) - failed to get settlement price for ${underlyingAsset}. Skipping settlement.`
        );
        continue;
      }
      console.log(`[FutureExpiry]  Settlement Price for ${underlyingAsset}: ${settlementPx}`);
  
      let positionsToSettle: PositionWithKeys[] = [];
      let lastPositionKey: Record<string, any> | undefined = undefined;
      const marketFilterSk = `MARKET#${market.symbol}`;
  
      try {
        do {
          const scanParams: ScanCommandInput = {
            TableName: POSITIONS_TABLE,
            FilterExpression: "sk = :marketSK AND begins_with(pk, :traderModePrefix) AND size <> :zero",
            ExpressionAttributeValues: marshall({
              ":marketSK": marketFilterSk,
              ":traderModePrefix": `TRADER#`,
              ":zero": 0, // Assuming size is number
            }),
            ExclusiveStartKey: lastPositionKey,
          };
          const { Items, LastEvaluatedKey } = await ddb.send(new ScanCommand(scanParams));
          if (Items) {
            const currentModeSuffix = `#${mode}`;
            positionsToSettle = positionsToSettle.concat(
              Items.map((item) => unmarshall(item) as PositionWithKeys)
                   .filter(pos => pos.pk?.endsWith(currentModeSuffix))
            );
          }
          lastPositionKey = LastEvaluatedKey;
        } while (lastPositionKey);
        console.log(`[FutureExpiry]  Found ${positionsToSettle.length} positions to settle for ${market.symbol} (${mode}).`);
      } catch (error) {
        console.error(
          `[FutureExpiry]  Error scanning positions for settlement of ${market.symbol} (${mode}):`,
          error
        );
        continue;
      }
  
      const settlementPromises: Promise<any>[] = [];
  
      for (const pos of positionsToSettle) {
        if (!pos.pk || pos.size === 0 || typeof pos.avgEntryPrice !== 'number') continue; // Ensure avgEntryPrice is a number
  
        const traderId = pos.pk.split("#")[1];
  
        // Calculate PnL = (Settlement Price - Avg Entry Price) * Size
        const pnlUsdcValue = (settlementPx - pos.avgEntryPrice) * pos.size;
        const pnlBaseUnits = BigInt(Math.round(pnlUsdcValue * USDC_DECIMALS_FACTOR));
  
        console.log(
          `[FutureExpiry]    Trader ${traderId}: Size ${pos.size}, Entry ${pos.avgEntryPrice.toFixed(4)}, Settlement Px ${settlementPx.toFixed(4)}. ` +
          `PnL (USDC Value) ${pnlUsdcValue.toFixed(6)}, PnL (Base Units) ${pnlBaseUnits}`
        );
  
        if (pnlBaseUnits !== BigInt(0)) {
          // Update BalancesTable (USDC) for both REAL and PAPER modes
          const balancePk = pos.pk; // TRADER#<id>#<mode>
          const balanceSk = pkHelper.asset("USDC");
          const balanceUpdatePromise = ddb.send(
            new UpdateItemCommand({
              TableName: BALANCES_TABLE,
              Key: marshall({ pk: balancePk, sk: balanceSk }),
              UpdateExpression: "ADD balance :pnl",
              ExpressionAttributeValues: marshall({ ":pnl": pnlBaseUnits }),
            })
          ).catch((err) => {
            console.error(
              `[FutureExpiry]    Failed balance update for ${traderId} (${market.symbol}, ${mode}):`,
              err
            );
          });
          settlementPromises.push(balanceUpdatePromise);
        }
  
        // Zero out the position and update realized PnL
        const positionUpdatePromise = ddb.send(
          new UpdateItemCommand({
            TableName: POSITIONS_TABLE,
            Key: marshall({ pk: pos.pk, sk: pos.sk }),
            UpdateExpression: `SET size = :zero, avgEntryPrice = :zero, #updAt = :now ADD realizedPnl :rPnl`,
            ExpressionAttributeNames: { "#updAt": "updatedAt" },
            ExpressionAttributeValues: marshall({
              ":zero": 0,
              ":now": now,
              ":rPnl": pnlBaseUnits, // Add the settlement PnL
            }),
          })
        ).catch((err) => {
          console.error(
            `[FutureExpiry]    Failed position update for ${traderId} (${market.symbol}, ${mode}):`,
            err
          );
        });
        settlementPromises.push(positionUpdatePromise);
  
        // No on-chain synth burning for the future contract itself as it's not a token.
        // The underlying synthetic assets (sBTC, sETH) are handled by spot trading.
      } // End position settlement loop
  
      if (settlementPromises.length > 0) {
          await Promise.allSettled(settlementPromises);
          console.log(`[FutureExpiry]  Processed ${settlementPromises.length} DB updates for ${market.symbol} (${mode}).`);
      }
  
      const finalMarketStatus = "DELISTED";
      try {
        console.log(`[FutureExpiry]  Marking market ${market.symbol} (${mode}) as ${finalMarketStatus}.`);
        await ddb.send(
          new UpdateItemCommand({
            TableName: MARKETS_TABLE,
            Key: marshall({ pk: market.pk, sk: market.sk }),
            UpdateExpression: "SET #s = :newStatus, #updAt = :now",
            ConditionExpression: "#s = :active",
            ExpressionAttributeNames: { "#s": "status", "#updAt": "updatedAt" },
            ExpressionAttributeValues: marshall({
              ":newStatus": finalMarketStatus,
              ":active": "ACTIVE",
              ":now": now,
            }),
          })
        );
        await publishMarketStateUpdate(market.symbol, mode, finalMarketStatus);
      } catch (error: any) {
        if (error.name !== "ConditionalCheckFailedException") {
          console.error(
            `[FutureExpiry]  Error marking market ${market.symbol} (${mode}) as ${finalMarketStatus}:`,
            error
          );
        } else {
          console.log(
            `[FutureExpiry]  Market ${market.symbol} (${mode}) was likely already marked ${finalMarketStatus}.`
          );
        }
      }
    } // End market loop
  
    console.log(`[FutureExpiry] CRON finished at ${new Date().toISOString()}`);
  };
### File: dex/cron/oracle.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/cron/oracle.ts
import { DynamoDBClient, PutItemCommand, QueryCommand } from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import fetch from "node-fetch"; // Or your preferred HTTP client
import { Resource } from "sst";
import type { Trade, TradingMode } from "../../src/lib/interfaces";
import { pk as pkHelper } from "../matchers/matchEngine"; // Use PK helpers

// --- Configuration ---
const CMC_API_KEY = Resource.CmcApiKey.value; // Access via SST Secret/Env Var
const CMC_BASE_URL = "https://pro-api.coinmarketcap.com"; // Use Pro URL
const CMC_QUOTES_ENDPOINT = "/v1/cryptocurrency/quotes/latest";

const PRICE_TABLE_NAME = Resource.PricesTable.name;
const TRADES_TABLE_NAME = Resource.TradesTable.name; // For CXPT TWAP

const ddb = new DynamoDBClient({});

// List of assets to fetch from CMC (excluding CXPT, USDC, USDT)
const CMC_ASSET_SYMBOLS = ["BTC", "ETH", "PEAQ", "AVAX", "SOL", "BNB", "NEAR", "OP"];
const STABLECOIN_SYMBOLS = ["USDC", "USDT"];
const INTERNAL_TOKEN_SYMBOL = "CXPT";
const CXPT_QUOTE_ASSET = "USDC"; // CXPT is priced against USDC on our DEX
const CXPT_MARKET_SYMBOL = `${INTERNAL_TOKEN_SYMBOL}-${CXPT_QUOTE_ASSET}`; // e.g., CXPT-USDC

// TWAP Configuration for CXPT
const CXPT_TWAP_DURATION_MINUTES = 60; // Calculate TWAP over the last hour
const MIN_TRADES_FOR_TWAP = 5;       // Minimum trades required for a valid TWAP

// Helper function to create the PK for the Prices table
const pkAsset = (asset: string) => `ASSET#${asset.toUpperCase()}`;


/**
 * Fetches latest quotes from CoinMarketCap API.
 */
async function fetchCmcPrices(symbols: string[]): Promise<Record<string, number> | null> {
    if (!CMC_API_KEY) {
        console.error("CMC_API_KEY environment variable not set.");
        return null;
    }
    if (symbols.length === 0) {
        return {};
    }

    const url = `${CMC_BASE_URL}${CMC_QUOTES_ENDPOINT}?symbol=${symbols.join(',')}&convert=USD`;
    console.log(`Fetching CMC prices for: ${symbols.join(',')}`);

    try {
        const response = await fetch(url, {
            headers: {
                'X-CMC_PRO_API_KEY': CMC_API_KEY,
                'Accept': 'application/json',
            },
        });

        if (!response.ok) {
            const errorBody = await response.text();
            console.error(`CMC API Error (${response.status}): ${errorBody}`);
            return null;
        }

        const data = await response.json() as any; // Type properly based on CMC response structure

        if (data?.status?.error_code !== 0 && data?.status?.error_code !== null) { // CMC uses 0 or null for success
            console.error(`CMC API returned an error: ${data.status.error_message || 'Unknown error'}`);
            return null;
        }

        const prices: Record<string, number> = {};
        for (const symbol of symbols) {
            const quote = data?.data?.[symbol]?.quote?.USD;
            if (quote?.price) {
                prices[symbol] = quote.price;
            } else {
                console.warn(`Price data not found for ${symbol} in CMC response.`);
            }
        }
        return prices;

    } catch (error) {
        console.error("Error fetching data from CMC API:", error);
        return null;
    }
}

/**
 * Calculates the Time-Weighted Average Price (TWAP) for CXPT from recent trades.
 * Fetches trades from both REAL and PAPER modes for robustness, but prioritizes REAL if available.
 */
async function calculateCxptTwap(marketSymbol: string, durationMs: number): Promise<number | null> {
    const startTime = Date.now() - durationMs;
    let priceSum = 0;
    let totalDurationWeighted = 0;
    let lastTimestamp = startTime;
    let lastPrice = 0; // Price at the start of the interval (or first trade)
    // let tradeCount = 0;

    // Try fetching REAL trades first
    let trades = await fetchTrades(marketSymbol, "REAL", startTime);
    if (!trades || trades.length < MIN_TRADES_FOR_TWAP) {
        console.log(`Not enough REAL trades for ${marketSymbol} TWAP, trying PAPER mode...`);
        // Fallback to PAPER trades if not enough REAL trades
        trades = await fetchTrades(marketSymbol, "PAPER", startTime);
        if (!trades || trades.length < MIN_TRADES_FOR_TWAP) {
             console.warn(`Insufficient trades (<${MIN_TRADES_FOR_TWAP}) in both REAL and PAPER modes for ${marketSymbol} within the last ${durationMs / 60000} minutes to calculate TWAP.`);
             // Fallback: Optionally use the single latest trade price if available
             if (trades && trades.length > 0) return trades[trades.length - 1].price;
             return null;
        }
    }

     // Set initial price for the first interval segment
    if (trades.length > 0) {
        lastPrice = trades[0].price; // Use the price of the first trade in the period
    } else {
        return null; // Should not happen due to checks above, but safety first
    }


    console.log(`Calculating TWAP for ${marketSymbol} using ${trades.length} trades...`);

    for (const trade of trades) {
        if (trade.timestamp < lastTimestamp) continue; // Should not happen with sorted query

        const duration = trade.timestamp - lastTimestamp;
        if (duration > 0 && lastPrice > 0) { // Ensure duration and price are positive
            priceSum += lastPrice * duration;
            totalDurationWeighted += duration;
        }
        // Update for the next interval
        lastPrice = trade.price;
        lastTimestamp = trade.timestamp;
        // tradeCount++;
    }

    // Add the last interval segment (from last trade to now)
    const finalDuration = Date.now() - lastTimestamp;
    if (finalDuration > 0 && lastPrice > 0) {
        priceSum += lastPrice * finalDuration;
        totalDurationWeighted += finalDuration;
    }

    if (totalDurationWeighted === 0 || priceSum === 0) {
        console.warn(`TWAP calculation resulted in zero duration or price sum for ${marketSymbol}.`);
         // Fallback: Use simple average or latest price if TWAP fails
         if (trades.length > 0) return trades.reduce((sum, t) => sum + t.price, 0) / trades.length;
        return null;
    }

    const twap = priceSum / totalDurationWeighted;
    console.log(`  Calculated TWAP for ${marketSymbol}: ${twap.toFixed(6)}`);
    return twap;
}

/** Helper to fetch recent trades for TWAP calculation */
async function fetchTrades(marketSymbol: string, mode: TradingMode, startTime: number): Promise<Trade[]> {
    const marketModePk = pkHelper.marketMode(marketSymbol, mode);
    const startSk = `TS#${startTime}`; // Assuming trade IDs/timestamps are sortable like this

    try {
        const { Items } = await ddb.send(new QueryCommand({
            TableName: TRADES_TABLE_NAME,
            KeyConditionExpression: "pk = :pk AND sk >= :startSk", // Fetch trades from startTime onwards
            ExpressionAttributeValues: marshall({
                ":pk": marketModePk,
                ":startSk": startSk // Use timestamp-based SK if available, otherwise needs GSI on timestamp
            }),
            ScanIndexForward: true, // Fetch oldest first for TWAP calculation
             // Note: If SK is TS#<tradeId>, you need a GSI on trade timestamp for efficient time-based querying.
             // Assuming SK includes timestamp or a GSI `ByTimestamp` exists: IndexName: "ByTimestamp"
        }));

        if (!Items) return [];
        return Items.map(item => unmarshall(item) as Trade)
                   .sort((a,b) => a.timestamp - b.timestamp); // Ensure sorted by time ascending

    } catch (error) {
        console.error(`Error fetching trades for ${marketModePk}:`, error);
        return [];
    }
}


/**
 * Saves a price snapshot to the Prices table.
 */
async function savePriceSnapshot(asset: string, price: number, timestampIso: string) {
    const ttlSeconds = Math.floor(Date.now() / 1_000) + (7 * 24 * 60 * 60); // 7-day TTL

    try {
        await ddb.send(
            new PutItemCommand({
                TableName: PRICE_TABLE_NAME,
                Item: marshall({
                    pk: pkAsset(asset),           // e.g., ASSET#BTC
                    sk: `TS#${timestampIso}`,     // e.g., TS#2023-10-27T10:00:00.000Z
                    asset: asset,                 // Store asset symbol explicitly
                    price: price,
                    timestamp: new Date(timestampIso).getTime(), // Store epoch ms too
                    source: asset === INTERNAL_TOKEN_SYMBOL ? 'DEX_TWAP' : (STABLECOIN_SYMBOLS.includes(asset) ? 'FIXED' : 'CMC'), // Indicate source
                    expireAt: ttlSeconds,
                }),
            })
        );
         // console.log(`Saved price snapshot for ${asset}: ${price}`);
    } catch (error) {
         console.error(`Failed to save price snapshot for ${asset}:`, error);
    }
}


// --- Main Handler ---
export const handler = async (): Promise<void> => {
    const now = new Date();
    const nowIso = now.toISOString();
    console.log(`Oracle CRON starting at ${nowIso}`);

    const pricePromises: Promise<void>[] = [];
    const allPrices: Record<string, number> = {};

    // 1. Fetch prices from CMC
    const cmcPrices = await fetchCmcPrices(CMC_ASSET_SYMBOLS);
    if (cmcPrices) {
        console.log("CMC Prices fetched:", cmcPrices);
        Object.assign(allPrices, cmcPrices);
    } else {
        console.error("Failed to fetch prices from CMC. Oracle run may be incomplete.");
        // Decide how to handle this - potentially stop, or continue with internal/fixed prices?
    }

    // 2. Set fixed prices for Stablecoins
    for (const symbol of STABLECOIN_SYMBOLS) {
        allPrices[symbol] = 1.00; // Assume always $1.00
         console.log(`Setting fixed price for ${symbol}: 1.00`);
    }

    // 3. Calculate TWAP for internal token CXPT
    const cxptTwap = await calculateCxptTwap(
        CXPT_MARKET_SYMBOL,
        CXPT_TWAP_DURATION_MINUTES * 60 * 1000 // Duration in milliseconds
    );
    if (cxptTwap !== null) {
        allPrices[INTERNAL_TOKEN_SYMBOL] = cxptTwap;
         console.log(`Using calculated TWAP for ${INTERNAL_TOKEN_SYMBOL}: ${cxptTwap}`);
    } else {
        console.error(`Failed to calculate TWAP for ${INTERNAL_TOKEN_SYMBOL}. Price will not be updated.`);
        // TODO: Consider fallback? Use last known price? Alerting?
    }

    // 4. Save all gathered prices to DynamoDB
    console.log("Saving price snapshots to DynamoDB...");
    for (const [asset, price] of Object.entries(allPrices)) {
        if (typeof price === 'number' && !isNaN(price)) {
            pricePromises.push(savePriceSnapshot(asset, price, nowIso));
        } else {
            console.warn(`Skipping invalid price for ${asset}: ${price}`);
        }
    }

    await Promise.all(pricePromises);

    console.log(`Oracle CRON finished at ${new Date().toISOString()}. Updated prices for: ${Object.keys(allPrices).join(', ')}`);
};
### File: dex/cron/perpsDailySettle.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/cron/perpsDailySettle.ts
import {
  DynamoDBClient,
  ScanCommand,
  ScanCommandInput,
  UpdateItemCommand,
  QueryCommand,
  QueryCommandInput,
} from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";
import {
  MarketMeta,
  Position,
  TradingMode,
  Trade, // For mark price from last trade
  // PriceSnapshot, // Alternative mark price source (e.g., from Oracle TWAP)
} from "../../src/lib/interfaces";
import { SNSClient, PublishCommand } from "@aws-sdk/client-sns"; // If PnL updates are pushed
import { pk as pkHelper } from "../matchers/matchEngine";

// Internal type
type PositionWithKeys = Position & { pk: string; sk: string };
type MarketMetaWithKeys = MarketMeta & { pk: string; sk: string };

const ddb = new DynamoDBClient({});
const sns = new SNSClient({}); // For publishing position updates

const POSITIONS_TABLE = Resource.PositionsTable.name;
const BALANCES_TABLE = Resource.BalancesTable.name;
const TRADES_TABLE = Resource.TradesTable.name; // Source for Mark Price (last trade)
const MARKETS_TABLE = Resource.MarketsTable.name;
const MARKET_UPDATES_TOPIC_ARN = Resource.MarketUpdatesTopic.arn; // For PnL updates

const USDC_DECIMALS_FACTOR = 1_000_000; // Assuming 6 decimals for USDC

/** Fetch most recent trade price for the perp market (mark price source) */
async function getMarkPrice(
  marketSymbol: string,
  mode: TradingMode
): Promise<number | null> {
  const marketModePk = pkHelper.marketMode(marketSymbol, mode);
  try {
    const { Items } = await ddb.send(
      new QueryCommand({
        TableName: TRADES_TABLE,
        KeyConditionExpression: "pk = :pk",
        ExpressionAttributeValues: marshall({ ":pk": marketModePk }),
        ScanIndexForward: false, // Newest first
        Limit: 1,
      })
    );
    if (!Items?.[0]) {
      console.warn(
        `[PerpSettle] No trades found for mark price source for ${marketModePk}. Cannot settle PnL.`
      );
      return null;
    }
    const tradeData = unmarshall(Items[0]) as Trade;
    return tradeData.price;
  } catch (error) {
    console.error(
      `[PerpSettle] Error fetching mark price for ${marketModePk}:`,
      error
    );
    return null;
  }
}

/** Publish position update via SNS */
async function publishPositionUpdate(
    traderId: string,
    position: Position,
    mode: TradingMode
  ) {
    try {
      await sns.send(new PublishCommand({
        TopicArn: MARKET_UPDATES_TOPIC_ARN,
        Message: JSON.stringify({
          type: "positionUpdate", // Consistent with matcher's position update
          traderId: traderId,
          market: position.market,
          mode: mode,
          size: position.size,
          avgEntryPrice: position.avgEntryPrice,
          realizedPnl: position.realizedPnl,
          unrealizedPnl: position.unrealizedPnl, // Will be 0 after settlement
          updatedAt: position.updatedAt, // Timestamp of settlement
          // You might include the mark price used for settlement
        }),
      }));
    } catch (error) {
      console.error(`[PerpSettle] Failed to publish position update for trader ${traderId}, market ${position.market} (${mode}):`, error);
    }
  }


export const handler = async (): Promise<void> => {
  const now = Date.now();
  console.log(`[PerpSettle] Daily Settlement CRON starting at ${new Date(now).toISOString()}`);

  let activePerpMarkets: MarketMetaWithKeys[] = [];
  let lastEvaluatedKeyMarkets: Record<string, any> | undefined = undefined;

  try {
    do {
      const queryParams: QueryCommandInput = {
        TableName: MARKETS_TABLE,
        IndexName: "ByStatusMode",
        KeyConditionExpression: "#s = :active",
        FilterExpression: "#t = :perp",
        ExpressionAttributeNames: { "#s": "status", "#t": "type" },
        ExpressionAttributeValues: marshall({
          ":active": "ACTIVE",
          ":perp": "PERP",
        }),
        ExclusiveStartKey: lastEvaluatedKeyMarkets,
      };
      const { Items, LastEvaluatedKey } = await ddb.send(new QueryCommand(queryParams));
      if (Items) {
        activePerpMarkets = activePerpMarkets.concat(
          Items.map((item) => unmarshall(item) as MarketMetaWithKeys)
        );
      }
      lastEvaluatedKeyMarkets = LastEvaluatedKey;
    } while (lastEvaluatedKeyMarkets);
    console.log(`[PerpSettle] Found ${activePerpMarkets.length} active PERP markets.`);
  } catch (error) {
    console.error("[PerpSettle] Error fetching active PERP markets:", error);
    return;
  }

  const settlementPromises: Promise<any>[] = [];

  for (const market of activePerpMarkets) {
    if (!market.pk || !market.symbol) {
      console.warn(`[PerpSettle] Skipping market with invalid data:`, market);
      continue;
    }
    const pkParts = market.pk.split("#");
    if (pkParts.length !== 3) {
      console.warn(`[PerpSettle] Skipping market with invalid PK format: ${market.pk}`);
      continue;
    }
    const mode = pkParts[2] as TradingMode;

    console.log(`[PerpSettle] Processing PnL settlement for market: ${market.symbol} (${mode})`);

    const markPx = await getMarkPrice(market.symbol, mode);
    if (markPx === null) {
      console.warn(
        `[PerpSettle]  Skipping PnL settlement for ${market.symbol} (${mode}) - Mark Price unavailable.`
      );
      continue;
    }
    console.log(`[PerpSettle]  Mark Price for ${market.symbol} (${mode}): ${markPx.toFixed(4)}`);


    let openPerpPositions: PositionWithKeys[] = [];
    let lastPositionKey: Record<string, any> | undefined = undefined;
    const marketFilterSk = `MARKET#${market.symbol}`;

    try {
      do {
        const scanParams: ScanCommandInput = {
          TableName: POSITIONS_TABLE,
          FilterExpression: "sk = :marketSK AND begins_with(pk, :traderModePrefix) AND size <> :zero",
          ExpressionAttributeValues: marshall({
            ":marketSK": marketFilterSk,
            ":traderModePrefix": `TRADER#`,
            ":zero": 0,
          }),
          ExclusiveStartKey: lastPositionKey,
        };
        const { Items, LastEvaluatedKey } = await ddb.send(new ScanCommand(scanParams));
        if (Items) {
          const currentModeSuffix = `#${mode}`;
          openPerpPositions = openPerpPositions.concat(
            Items.map((item) => unmarshall(item) as PositionWithKeys)
                 .filter(pos => pos.pk?.endsWith(currentModeSuffix))
          );
        }
        lastPositionKey = LastEvaluatedKey;
      } while (lastPositionKey);
      console.log(`[PerpSettle]  Found ${openPerpPositions.length} open positions for ${market.symbol} (${mode}).`);
    } catch (error) {
      console.error(
        `[PerpSettle]  Error scanning positions for ${market.symbol} (${mode}):`,
        error
      );
      continue; // Skip to next market
    }

    for (const pos of openPerpPositions) {
      if (!pos.pk || pos.size === 0 || typeof pos.avgEntryPrice !== 'number') continue;

      const traderId = pos.pk.split("#")[1];

      // Calculate current Unrealized PnL based on the fetched mark price
      const currentUnrealizedPnlValue = (markPx - pos.avgEntryPrice) * pos.size;
      const pnlToRealizeBaseUnits = BigInt(Math.round(currentUnrealizedPnlValue * USDC_DECIMALS_FACTOR));

      // If there's no PnL change to realize (e.g., mark price equals entry or position just opened)
      // or if currentUnrealizedPnl is already 0 (perhaps settled by funding very recently)
      if (pnlToRealizeBaseUnits === BigInt(0) && pos.unrealizedPnl === 0) {
        // console.log(`[PerpSettle]    No PnL change to settle for ${traderId} in ${market.symbol} (${mode}).`);
        continue;
      }
      // The amount to settle IS the current unrealized PnL.
      // If pos.unrealizedPnl attribute was already non-zero, we use that as the amount to move.
      // However, it's safer to recalculate against the fresh mark price.
      const settlementAmountBaseUnits = pnlToRealizeBaseUnits;


      console.log(
        `[PerpSettle]    Trader ${traderId}: Size ${pos.size}, Entry ${pos.avgEntryPrice.toFixed(4)}, Mark ${markPx.toFixed(4)}. ` +
        `Settling PnL (Base Units) ${settlementAmountBaseUnits}`
      );

      // 1. Update BalancesTable: Add the settled PnL to USDC balance
      if (settlementAmountBaseUnits !== BigInt(0)) {
        const balancePk = pos.pk; // TRADER#<id>#<mode>
        const balanceSk = pkHelper.asset("USDC");
        const balanceUpdatePromise = ddb.send(
          new UpdateItemCommand({
            TableName: BALANCES_TABLE,
            Key: marshall({ pk: balancePk, sk: balanceSk }),
            UpdateExpression: "ADD balance :settleAmt",
            ExpressionAttributeValues: marshall({ ":settleAmt": settlementAmountBaseUnits }),
          })
        ).catch((err) => {
          console.error(
            `[PerpSettle]    Failed balance update for ${traderId} (${market.symbol}, ${mode}):`,
            err
          );
        });
        settlementPromises.push(balanceUpdatePromise);
      }

      // 2. Update PositionsTable:
      //    - Add settled PnL to `realizedPnl`
      //    - Set `unrealizedPnl` to 0
      //    - Update `updatedAt`
      const positionUpdatePromise = ddb.send(
        new UpdateItemCommand({
          TableName: POSITIONS_TABLE,
          Key: marshall({ pk: pos.pk, sk: pos.sk }),
          UpdateExpression: `SET unrealizedPnl = :zero, #updAt = :now ADD realizedPnl :settleAmt`,
          ExpressionAttributeNames: { "#updAt": "updatedAt" },
          ExpressionAttributeValues: marshall({
            ":zero": 0, // Reset unrealized PnL to 0 (as BigInt if schema uses it, but PnL typically number)
            ":now": now,
            ":settleAmt": settlementAmountBaseUnits,
          }),
          ReturnValues: "ALL_NEW" // To get the updated position for SNS
        })
      ).then(async (updateResult) => {
        if (updateResult.Attributes) {
            const updatedPosition = unmarshall(updateResult.Attributes) as Position;
            await publishPositionUpdate(traderId, updatedPosition, mode);
        }
      }).catch((err) => {
        console.error(
          `[PerpSettle]    Failed position update for ${traderId} (${market.symbol}, ${mode}):`,
          err
        );
      });
      settlementPromises.push(positionUpdatePromise);
    } // End position loop
  } // End market loop

  if (settlementPromises.length > 0) {
    await Promise.allSettled(settlementPromises);
    console.log(`[PerpSettle] Processed ${settlementPromises.length} total DB updates for PnL settlement.`);
  }

  console.log(`[PerpSettle] Daily Settlement CRON finished at ${new Date().toISOString()}`);
};
### File: dex/cron/metricsRollup.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/cron/metricsRollup.ts
import {
  DynamoDBClient,
  QueryCommand,
  PutItemCommand,
  ScanCommand, // Using Scan as we need to fetch all markets first
  ScanCommandInput,
  QueryCommandInput,
} from "@aws-sdk/client-dynamodb";
import { Resource } from "sst";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import type { StatsIntradayRow, StatsDailyRow } from "../../src/lib/interfaces";

// Internal type for MarketMeta including keys
// type MarketMetaWithKeys = MarketMeta & { pk: string; sk: string };

const ddb = new DynamoDBClient({});
const s3 = new S3Client({});

// Table Names (Ignoring TS errors for Resource)
const STATS_INTRADAY_TABLE = Resource.StatsIntradayTable.name;
const STATS_DAILY_TABLE = Resource.StatsDailyTable.name;
const MARKETS_TABLE = Resource.MarketsTable.name; // Need to know which markets exist
const DATA_LAKE_BUCKET = Resource.DexDataLakeBucket.name;


export const handler = async (): Promise<void> => {
    const today = new Date();
    // Calculate yesterday's date range carefully considering UTC
    const yesterday = new Date(today);
    yesterday.setUTCDate(today.getUTCDate() - 1);
    const ydayIso = yesterday.toISOString().slice(0, 10); // YYYY-MM-DD
    const ydayStartIso = `${ydayIso}T00:00:00.000Z`;
    const ydayEndIso = `${ydayIso}T23:59:59.999Z`;
    // DynamoDB sort keys for the time range
    const ydayStartSk = `TS#${new Date(ydayStartIso).getTime()}`; // Use epoch ms if SK is epoch
    const ydayEndSk = `TS#${new Date(ydayEndIso).getTime()}`;

    console.log(`Metrics Rollup CRON starting for date: ${ydayIso}`);

    // 1️⃣ Get all unique Market PKs (MARKET#symbol#mode)
    // This tells us which partitions to query in the StatsIntraday table.
    let allMarketPks: string[] = [];
    let lastMarketKey: Record<string, any> | undefined = undefined;
    try {
        do {
            const scanParams: ScanCommandInput = {
                TableName: MARKETS_TABLE,
                // Optional: FilterExpression: "#s <> :delisted", // Only rollup active/paused markets?
                // ExpressionAttributeNames: {"#s": "status"},
                // ExpressionAttributeValues: marshall({":delisted": "DELISTED"}),
                ProjectionExpression: "pk", // Only need the primary key
                ExclusiveStartKey: lastMarketKey,
            };
            const { Items, LastEvaluatedKey } = await ddb.send(new ScanCommand(scanParams));
            if (Items) {
                allMarketPks = allMarketPks.concat(
                    Items.map(item => unmarshall(item).pk as string).filter(pk => !!pk) // Filter out any potential undefined pks
                );
            }
            lastMarketKey = LastEvaluatedKey;
        } while (lastMarketKey);
        console.log(`Found ${allMarketPks.length} market partitions to process.`);
    } catch (error) {
        console.error("Error scanning markets table:", error);
        return; // Cannot proceed without knowing which markets to rollup
    }

    // Overall aggregation object (can be large)
    const dailyAggregates: Record<string, Partial<StatsDailyRow>> = {}; // Keyed by Market PK

    // 2️⃣ For each market PK, query yesterday's intraday stats
    for (const marketPk of allMarketPks) {
        console.log(`  Processing intraday stats for market partition: ${marketPk}`);
        let marketVolume = 0;
        let marketFees = 0;
        let marketTrades = 0;
        // Add other metrics to aggregate here (e.g., OI snapshots)
        let lastEvalStatsKey: Record<string, any> | undefined = undefined;

        try {
            do {
                const queryParams: QueryCommandInput = {
                    TableName: STATS_INTRADAY_TABLE,
                    KeyConditionExpression: "pk = :pk AND sk BETWEEN :startSk AND :endSk",
                    ExpressionAttributeValues: marshall({
                        ":pk": marketPk,
                        ":startSk": ydayStartSk, // Use epoch ms range for SK
                        ":endSk": ydayEndSk,
                    }),
                    ExclusiveStartKey: lastEvalStatsKey,
                };

                const { Items, LastEvaluatedKey } = await ddb.send(new QueryCommand(queryParams));

                if (Items) {
                    for (const item of Items) {
                        const row = unmarshall(item) as Partial<StatsIntradayRow>;
                        marketVolume += row.volume ?? 0;
                        marketFees += row.fees ?? 0;
                        marketTrades += row.trades ?? 0; // Assuming 'trades' is a count attribute
                        // Aggregate other metrics...
                    }
                }
                lastEvalStatsKey = LastEvaluatedKey;
            } while (lastEvalStatsKey);

            // Store aggregated data if any was found
            if (marketVolume > 0 || marketFees > 0 || marketTrades > 0) {
                 dailyAggregates[marketPk] = {
                     volume: marketVolume,
                     fees: marketFees,
                     trades: marketTrades,
                     // Store aggregated OI, etc.
                 };
                console.log(`    Aggregated for ${marketPk}: Vol=${marketVolume}, Fees=${marketFees}, Trades=${marketTrades}`);
            } else {
                // console.log(`    No intraday stats found for ${marketPk} on ${ydayIso}.`);
            }

        } catch (error) {
            console.error(`  Error querying/aggregating intraday stats for ${marketPk}:`, error);
            // Continue to the next market? Or halt? For rollup, continuing is usually preferred.
        }
    } // End loop through market PKs


    // 3️⃣ Write aggregated data to StatsDaily table
    const putPromises: Promise<any>[] = [];
    for (const [marketPk, dailyData] of Object.entries(dailyAggregates)) {
        // Basic validation
        if (!dailyData || typeof dailyData.volume !== 'number' || typeof dailyData.fees !== 'number') continue;

        const putPromise = ddb.send(
            new PutItemCommand({
                TableName: STATS_DAILY_TABLE,
                Item: marshall({
                    pk: marketPk,       // MARKET#symbol#mode
                    sk: ydayIso,        // YYYY-MM-DD
                    day: ydayIso,       // Add day attribute for clarity
                    ...dailyData,       // Spread aggregated values (volume, fees, trades, etc.)
                    rolledUpAt: Date.now(), // Timestamp of rollup
                }, { removeUndefinedValues: true }),
            })
        ).catch(err => {
             console.error(`  Error writing daily stats for ${marketPk}:`, err);
        });
        putPromises.push(putPromise);
    }

    await Promise.allSettled(putPromises);
    console.log(`Finished writing ${putPromises.length} daily stats items.`);


    // 4️⃣ Dump aggregated JSON to S3 Data Lake
    // Structure the S3 path to include the date
    const s3Key = `stats/daily/${ydayIso}/aggregated.json`; // Store all modes in one file per day
    // Alternatively, split by mode: `stats/daily/REAL/${ydayIso}.json`, `stats/daily/PAPER/${ydayIso}.json`

    try {
        await s3.send(
            new PutObjectCommand({
                Bucket: DATA_LAKE_BUCKET,
                Key: s3Key,
                Body: JSON.stringify(dailyAggregates, null, 2), // Pretty print JSON
                ContentType: "application/json",
            })
        );
        console.log(`Successfully uploaded daily aggregate to S3: ${s3Key}`);
    } catch (error) {
        console.error(`Error uploading daily aggregate to S3 (${s3Key}):`, error);
    }

    console.log(`Metrics Rollup CRON finished for date: ${ydayIso}`);
};
### File: dex/cron/funding.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// dex/cron/funding.ts
import {
    DynamoDBClient,
    QueryCommand,
    QueryCommandInput,
    ScanCommand,
    UpdateItemCommand,
    ScanCommandInput,
  } from "@aws-sdk/client-dynamodb";
  import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
  import { Resource } from "sst";
  import {
    MarketMeta,
    Position,
    TradingMode,
    PriceSnapshot,
    Trade,
  } from "../../src/lib/interfaces";
  import { SNSClient, PublishCommand } from "@aws-sdk/client-sns";
  import { pk as pkHelper } from "../matchers/matchEngine"; // Use PK helpers from matchEngine
  
  // --- Constants ---
  const MARKETS_TABLE = Resource.MarketsTable.name;
  const POSITIONS_TABLE = Resource.PositionsTable.name;
  const BALANCES_TABLE = Resource.BalancesTable.name;
  const PRICES_TABLE = Resource.PricesTable.name;
  const TRADES_TABLE = Resource.TradesTable.name;
  const STATS_INTRADAY_TABLE = Resource.StatsIntradayTable.name;
  const MARKET_UPDATES_TOPIC_ARN = Resource.MarketUpdatesTopic.arn;
  
  const USDC_DECIMALS_FACTOR = 1_000_000; // Assuming 6 decimals for USDC
  
  const ddb = new DynamoDBClient({});
  const sns = new SNSClient({});
  
  /** Clamp helper */
  const clamp = (val: number, min: number, max: number): number =>
    Math.max(min, Math.min(val, max));
  
  /** Fetch most recent oracle price for the underlying asset */
  async function getIndexPrice(asset: string): Promise<number | null> {
    try {
      const { Items } = await ddb.send(
        new QueryCommand({
          TableName: PRICES_TABLE,
          KeyConditionExpression: "pk = :pk",
          ExpressionAttributeValues: marshall({ ":pk": pkHelper.asset(asset) }),
          ScanIndexForward: false, // Newest first
          Limit: 1,
        })
      );
      if (!Items?.[0]) {
        console.warn(`[Funding] No oracle price found for asset: ${asset}`);
        return null;
      }
      const priceData = unmarshall(Items[0]) as PriceSnapshot;
      return priceData.price;
    } catch (error) {
      console.error(`[Funding] Error fetching index price for ${asset}:`, error);
      return null;
    }
  }
  
  /** Fetch most recent trade price for the perp market (mark price source) */
  async function getMarkPrice(
    marketSymbol: string,
    mode: TradingMode
  ): Promise<number | null> {
    const marketModePk = pkHelper.marketMode(marketSymbol, mode);
    try {
      const { Items } = await ddb.send(
        new QueryCommand({
          TableName: TRADES_TABLE,
          KeyConditionExpression: "pk = :pk",
          ExpressionAttributeValues: marshall({ ":pk": marketModePk }),
          ScanIndexForward: false, // Newest first
          Limit: 1,
        })
      );
      if (!Items?.[0]) {
        console.warn(
          `[Funding] No trades found for mark price source: ${marketModePk}. Funding may be inaccurate.`
        );
        return null;
      }
      const tradeData = unmarshall(Items[0]) as Trade;
      return tradeData.price;
    } catch (error) {
      console.error(
        `[Funding] Error fetching mark price for ${marketModePk}:`,
        error
      );
      return null;
    }
  }
  
  /** Publish funding rate update via SNS */
  async function publishFundingUpdate(
    marketSymbol: string,
    mode: TradingMode,
    fundingRate: number,
    markPx: number | null
  ) {
    try {
      await sns.send(
        new PublishCommand({
          TopicArn: MARKET_UPDATES_TOPIC_ARN,
          Message: JSON.stringify({
            type: "fundingRateUpdate",
            market: marketSymbol,
            mode: mode,
            fundingRate: fundingRate,
            markPrice: markPx, // Can be null if mark price fetch failed
            timestamp: Date.now(),
          }),
        })
      );
    } catch (error) {
      console.error(
        `[Funding] Failed to publish funding update for ${marketSymbol} (${mode}):`,
        error
      );
    }
  }
  
  export const handler = async (): Promise<void> => {
    const now = Date.now();
    console.log(`[Funding] CRON starting at ${new Date(now).toISOString()}`);
  
    let activePerpMarkets: (MarketMeta & { pk: string; sk: string })[] = [];
    let lastEvaluatedKeyMarkets: Record<string, any> | undefined = undefined;
  
    try {
      do {
        const queryParams: QueryCommandInput = {
          TableName: MARKETS_TABLE,
          IndexName: "ByStatusMode", // GSI: PK=status, SK=pk (MARKET#symbol#mode)
          KeyConditionExpression: "#s = :active",
          FilterExpression: "#t = :perp", // Only process PERP type markets
          ExpressionAttributeNames: { "#s": "status", "#t": "type" },
          ExpressionAttributeValues: marshall({
            ":active": "ACTIVE",
            ":perp": "PERP",
          }),
          ExclusiveStartKey: lastEvaluatedKeyMarkets,
        };
  
        const { Items, LastEvaluatedKey } = await ddb.send(
          new QueryCommand(queryParams)
        );
        if (Items) {
          activePerpMarkets = activePerpMarkets.concat(
            Items.map((item) => unmarshall(item) as (MarketMeta & { pk: string; sk: string }))
          );
        }
        lastEvaluatedKeyMarkets = LastEvaluatedKey;
      } while (lastEvaluatedKeyMarkets);
  
      console.log(`[Funding] Found ${activePerpMarkets.length} active PERP markets.`);
    } catch (error) {
      console.error("[Funding] Error fetching active PERP markets:", error);
      return;
    }
  
    for (const market of activePerpMarkets) {
      if (!market.pk || !market.symbol) {
          console.warn(`[Funding] Skipping market with invalid data:`, market);
          continue;
      }
      const pkParts = market.pk.split("#");
      if (pkParts.length !== 3) {
          console.warn(`[Funding] Skipping market with invalid PK format: ${market.pk}`);
          continue;
      }
      // const marketSymbol = pkParts[1]; // Already have market.symbol
      const mode = pkParts[2] as TradingMode;
      const underlyingAsset = market.symbol.split("-")[0]; // e.g., BTC from BTC-PERP
  
      console.log(`[Funding] Processing funding for: ${market.symbol} (${mode})`);
  
      const [indexPx, markPx] = await Promise.all([
        getIndexPrice(underlyingAsset),
        getMarkPrice(market.symbol, mode),
      ]);
  
      if (indexPx === null || markPx === null) {
        console.warn(
          `[Funding] Skipping funding for ${market.symbol} (${mode}) due to missing price(s). Index: ${indexPx}, Mark: ${markPx}`
        );
        await publishFundingUpdate(market.symbol, mode, 0, markPx); // Publish 0 rate if prices missing
        continue;
      }
  
      // Default funding interval to 1 hour (3600 seconds) if not specified
      const fundingIntervalSecs = market.fundingIntervalSec ?? 3600;
      const fundingPeriodSecs = 3600; // Standard hourly funding period
      const maxHourlyRate = 0.000375; // Use market-specific or default max rate (0.0375% per hour)
  
      const premium = (markPx - indexPx) / indexPx;
      // Clamp premium to avoid excessively large funding rates if maxHourlyRate directly applies to premium
      // Or, clamp the calculated hourlyRate. Let's clamp the hourly rate.
      const hourlyRateRaw = premium / (fundingIntervalSecs / fundingPeriodSecs); // premium per funding period -> hourly
      const hourlyRateClamped = clamp(hourlyRateRaw, -maxHourlyRate, maxHourlyRate);
      
      // Funding rate for the interval
      const fundingRate = +(hourlyRateClamped * (fundingIntervalSecs / fundingPeriodSecs)).toFixed(8);
  
  
      console.log(
        `[Funding]  Symbol: ${market.symbol}, Mode: ${mode}, Index: ${indexPx.toFixed(4)}, Mark: ${markPx.toFixed(4)}, Premium: ${premium.toFixed(6)}, Raw Hourly: ${hourlyRateRaw.toFixed(6)}, Clamped Hourly: ${hourlyRateClamped.toFixed(6)}, Rate: ${fundingRate}`
      );
  
      await publishFundingUpdate(market.symbol, mode, fundingRate, markPx);
  
      // Update StatsIntradayTable with the calculated funding rate
      try {
        const minuteBucketMs = Math.floor(now / 60_000) * 60_000;
        const statsPk = pkHelper.marketMode(market.symbol, mode);
        const statsSk = `TS#${minuteBucketMs}`;
        const statsTtl = Math.floor((now + 48 * 3_600_000) / 1_000); // 48h TTL
  
        await ddb.send(
          new UpdateItemCommand({
            TableName: STATS_INTRADAY_TABLE,
            Key: marshall({ pk: statsPk, sk: statsSk }),
            UpdateExpression:
              "SET fundingRate = :fr, markPrice = :mp, expireAt = if_not_exists(expireAt, :ttl)",
            ExpressionAttributeValues: marshall(
              {
                ":fr": fundingRate,
                ":mp": markPx,
                ":ttl": statsTtl,
              },
              { removeUndefinedValues: true }
            ),
          })
        );
      } catch (error) {
        console.error(
          `[Funding] Error updating intraday stats for ${market.symbol} (${mode}):`,
          error
        );
      }
  
      // If funding rate is zero, no payments to process
      if (fundingRate === 0) {
          console.log(`[Funding]  Zero funding rate for ${market.symbol} (${mode}). No payments to process.`);
          continue;
      }
  
      // Load all open positions for this market and mode
      let positionsToFund: (Position & { pk: string; sk: string })[] = [];
      let lastPositionKey: Record<string, any> | undefined = undefined;
      const marketFilterSk = `MARKET#${market.symbol}`;
  
      try {
        do {
          const scanParams: ScanCommandInput = {
            TableName: POSITIONS_TABLE,
            // Filter by SK (market) and PK prefix (trader ID + mode)
            // This is less efficient than a GSI but works for smaller tables or if GSI isn't ideal.
            // A GSI on `sk` (market) and filtering on `pk` prefix would be better.
            // Or, if `market` is an attribute, GSI on market+mode, then filter positions.
            FilterExpression: "sk = :marketSK AND begins_with(pk, :traderModePrefix) AND size <> :zero",
            ExpressionAttributeValues: marshall({
              ":marketSK": marketFilterSk,
              ":traderModePrefix": `TRADER#`, // Will be further filtered in code by mode
              ":zero": 0, // Assuming size is a number, not BigInt, in DDB for this table based on current code
            }),
            ExclusiveStartKey: lastPositionKey,
          };
          const { Items, LastEvaluatedKey } = await ddb.send(
            new ScanCommand(scanParams)
          );
  
          if (Items) {
            const currentModePrefix = `TRADER#`; // General prefix
            const currentModeSuffix = `#${mode}`; // Mode-specific suffix
            positionsToFund = positionsToFund.concat(
              Items.map((item) => unmarshall(item) as (Position & { pk: string; sk: string }))
                   .filter(pos => pos.pk?.startsWith(currentModePrefix) && pos.pk?.endsWith(currentModeSuffix))
            );
          }
          lastPositionKey = LastEvaluatedKey;
        } while (lastPositionKey);
        console.log(`[Funding]  Found ${positionsToFund.length} open positions for ${market.symbol} (${mode}).`);
      } catch (error) {
        console.error(
          `[Funding] Error scanning positions for ${market.symbol} (${mode}):`,
          error
        );
        continue; // Skip to next market if positions can't be loaded
      }
  
      const updatePromises: Promise<any>[] = [];
  
      for (const pos of positionsToFund) {
        if (!pos.pk || pos.size === 0) continue; // Should be filtered by scan, but double check
  
        // Funding payment is based on position size, mark price, and funding rate.
        // Payment = Position Size * Mark Price * Funding Rate
        // If positive, longs pay shorts. If negative, shorts pay longs.
        const paymentValue = pos.size * markPx * fundingRate; // This is in USDC value
        
        // Amount to transfer (positive means shorts receive from longs, negative means longs receive from shorts)
        // The actual balance change for the trader is -paymentValue.
        const balanceChangeUsdcValue = -paymentValue; 
        const balanceChangeBaseUnits = BigInt(Math.round(balanceChangeUsdcValue * USDC_DECIMALS_FACTOR));
  
        if (balanceChangeBaseUnits === BigInt(0)) continue;
  
        const traderId = pos.pk.split("#")[1]; // Extract traderId from `TRADER#<id>#<mode>`
  
        console.log(
          `[Funding]    Trader ${traderId}: Size ${pos.size}, Payment (USDC Value) ${(-paymentValue).toFixed(6)}, Balance Change (Base Units) ${balanceChangeBaseUnits}`
        );
  
        // Update BalancesTable for USDC (for both REAL and PAPER modes)
        const balancePk = pos.pk; // This is already TRADER#<id>#<mode>
        const balanceSk = pkHelper.asset("USDC");
  
        const balanceUpdatePromise = ddb
          .send(
            new UpdateItemCommand({
              TableName: BALANCES_TABLE,
              Key: marshall({ pk: balancePk, sk: balanceSk }),
              UpdateExpression: "ADD balance :payment", // Add (can be negative)
              ExpressionAttributeValues: marshall({
                ":payment": balanceChangeBaseUnits,
              }),
            })
          )
          .catch((err) => {
            console.error(
              `[Funding]    Failed balance update for ${traderId} (${market.symbol}, ${mode}):`,
              err
            );
            // Decide on error handling: retry, DLQ, or just log
          });
        updatePromises.push(balanceUpdatePromise);
  
        // Note: No direct on-chain synth mint/burn for individual funding payments here.
        // The app (this cron) is responsible for updating the BalancesTable.
        // The custodial gateway will handle actual on-chain USDC movements at an aggregate level if needed.
      } // End position loop
  
      if (updatePromises.length > 0) {
          await Promise.allSettled(updatePromises);
          console.log(`[Funding]  Processed ${updatePromises.length} balance updates for ${market.symbol} (${mode}).`);
      }
    } // End market loop
  
    console.log(`[Funding] CRON finished at ${new Date().toISOString()}`);
  };
### File: .open-next/assets/_next/static/css/d757f2db635a9663.css
@font-face{font-family:Geist;font-style:normal;font-weight:100 900;font-display:swap;src:url(/_next/static/media/ba015fad6dcf6784-s.woff2) format("woff2");unicode-range:u+0100-02ba,u+02bd-02c5,u+02c7-02cc,u+02ce-02d7,u+02dd-02ff,u+0304,u+0308,u+0329,u+1d00-1dbf,u+1e00-1e9f,u+1ef2-1eff,u+2020,u+20a0-20ab,u+20ad-20c0,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-family:Geist;font-style:normal;font-weight:100 900;font-display:swap;src:url(/_next/static/media/569ce4b8f30dc480-s.p.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+0304,u+0308,u+0329,u+2000-206f,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-family:Geist Fallback;src:local("Arial");ascent-override:95.94%;descent-override:28.16%;line-gap-override:0.00%;size-adjust:104.76%}.__className_4d318d{font-family:Geist,Geist Fallback;font-style:normal}.__variable_4d318d{--font-geist-sans:"Geist","Geist Fallback"}@font-face{font-family:Geist Mono;font-style:normal;font-weight:100 900;font-display:swap;src:url(/_next/static/media/747892c23ea88013-s.woff2) format("woff2");unicode-range:u+0100-02ba,u+02bd-02c5,u+02c7-02cc,u+02ce-02d7,u+02dd-02ff,u+0304,u+0308,u+0329,u+1d00-1dbf,u+1e00-1e9f,u+1ef2-1eff,u+2020,u+20a0-20ab,u+20ad-20c0,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-family:Geist Mono;font-style:normal;font-weight:100 900;font-display:swap;src:url(/_next/static/media/93f479601ee12b01-s.p.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+0304,u+0308,u+0329,u+2000-206f,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-family:Geist Mono Fallback;src:local("Arial");ascent-override:74.67%;descent-override:21.92%;line-gap-override:0.00%;size-adjust:134.59%}.__className_ea5f4b{font-family:Geist Mono,Geist Mono Fallback;font-style:normal}.__variable_ea5f4b{--font-geist-mono:"Geist Mono","Geist Mono Fallback"}@font-face{font-family:Roboto Mono;font-style:normal;font-weight:100 700;font-display:swap;src:url(/_next/static/media/ffff0c425fbeefe6-s.woff2) format("woff2");unicode-range:u+0460-052f,u+1c80-1c8a,u+20b4,u+2de0-2dff,u+a640-a69f,u+fe2e-fe2f}@font-face{font-family:Roboto Mono;font-style:normal;font-weight:100 700;font-display:swap;src:url(/_next/static/media/c21b67b0a36892e5-s.woff2) format("woff2");unicode-range:u+0301,u+0400-045f,u+0490-0491,u+04b0-04b1,u+2116}@font-face{font-family:Roboto Mono;font-style:normal;font-weight:100 700;font-display:swap;src:url(/_next/static/media/c5a3bf8cfa32037a-s.woff2) format("woff2");unicode-range:u+0370-0377,u+037a-037f,u+0384-038a,u+038c,u+038e-03a1,u+03a3-03ff}@font-face{font-family:Roboto Mono;font-style:normal;font-weight:100 700;font-display:swap;src:url(/_next/static/media/b2f7755ffc613443-s.woff2) format("woff2");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+0300-0301,u+0303-0304,u+0308-0309,u+0323,u+0329,u+1ea0-1ef9,u+20ab}@font-face{font-family:Roboto Mono;font-style:normal;font-weight:100 700;font-display:swap;src:url(/_next/static/media/369c6e283c5acc6e-s.woff2) format("woff2");unicode-range:u+0100-02ba,u+02bd-02c5,u+02c7-02cc,u+02ce-02d7,u+02dd-02ff,u+0304,u+0308,u+0329,u+1d00-1dbf,u+1e00-1e9f,u+1ef2-1eff,u+2020,u+20a0-20ab,u+20ad-20c0,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-family:Roboto Mono;font-style:normal;font-weight:100 700;font-display:swap;src:url(/_next/static/media/92f44bb82993d879-s.p.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+0304,u+0308,u+0329,u+2000-206f,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-family:Roboto Mono Fallback;src:local("Arial");ascent-override:77.84%;descent-override:20.13%;line-gap-override:0.00%;size-adjust:134.61%}.__className_43fb55{font-family:Roboto Mono,Roboto Mono Fallback;font-style:normal}.__variable_43fb55{--font-roboto-mono:"Roboto Mono","Roboto Mono Fallback"}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/74c003a2abab0c4f-s.woff2) format("woff2");unicode-range:u+0460-052f,u+1c80-1c8a,u+20b4,u+2de0-2dff,u+a640-a69f,u+fe2e-fe2f}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/24c15609eaa28576-s.woff2) format("woff2");unicode-range:u+0301,u+0400-045f,u+0490-0491,u+04b0-04b1,u+2116}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/84602850c8fd81c3-s.woff2) format("woff2");unicode-range:u+1f??}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/90da053edc2b7de3-s.woff2) format("woff2");unicode-range:u+0370-0377,u+037a-037f,u+0384-038a,u+038c,u+038e-03a1,u+03a3-03ff}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/ac3b7908202f8517-s.woff2) format("woff2");unicode-range:u+0302-0303,u+0305,u+0307-0308,u+0310,u+0312,u+0315,u+031a,u+0326-0327,u+032c,u+032f-0330,u+0332-0333,u+0338,u+033a,u+0346,u+034d,u+0391-03a1,u+03a3-03a9,u+03b1-03c9,u+03d1,u+03d5-03d6,u+03f0-03f1,u+03f4-03f5,u+2016-2017,u+2034-2038,u+203c,u+2040,u+2043,u+2047,u+2050,u+2057,u+205f,u+2070-2071,u+2074-208e,u+2090-209c,u+20d0-20dc,u+20e1,u+20e5-20ef,u+2100-2112,u+2114-2115,u+2117-2121,u+2123-214f,u+2190,u+2192,u+2194-21ae,u+21b0-21e5,u+21f1-21f2,u+21f4-2211,u+2213-2214,u+2216-22ff,u+2308-230b,u+2310,u+2319,u+231c-2321,u+2336-237a,u+237c,u+2395,u+239b-23b7,u+23d0,u+23dc-23e1,u+2474-2475,u+25af,u+25b3,u+25b7,u+25bd,u+25c1,u+25ca,u+25cc,u+25fb,u+266d-266f,u+27c0-27ff,u+2900-2aff,u+2b0e-2b11,u+2b30-2b4c,u+2bfe,u+3030,u+ff5b,u+ff5d,u+1d400-1d7ff,u+1ee??}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/627d916fd739a539-s.woff2) format("woff2");unicode-range:u+0001-000c,u+000e-001f,u+007f-009f,u+20dd-20e0,u+20e2-20e4,u+2150-218f,u+2190,u+2192,u+2194-2199,u+21af,u+21e6-21f0,u+21f3,u+2218-2219,u+2299,u+22c4-22c6,u+2300-243f,u+2440-244a,u+2460-24ff,u+25a0-27bf,u+28??,u+2921-2922,u+2981,u+29bf,u+29eb,u+2b??,u+4dc0-4dff,u+fff9-fffb,u+10140-1018e,u+10190-1019c,u+101a0,u+101d0-101fd,u+102e0-102fb,u+10e60-10e7e,u+1d2c0-1d2d3,u+1d2e0-1d37f,u+1f0??,u+1f100-1f1ad,u+1f1e6-1f1ff,u+1f30d-1f30f,u+1f315,u+1f31c,u+1f31e,u+1f320-1f32c,u+1f336,u+1f378,u+1f37d,u+1f382,u+1f393-1f39f,u+1f3a7-1f3a8,u+1f3ac-1f3af,u+1f3c2,u+1f3c4-1f3c6,u+1f3ca-1f3ce,u+1f3d4-1f3e0,u+1f3ed,u+1f3f1-1f3f3,u+1f3f5-1f3f7,u+1f408,u+1f415,u+1f41f,u+1f426,u+1f43f,u+1f441-1f442,u+1f444,u+1f446-1f449,u+1f44c-1f44e,u+1f453,u+1f46a,u+1f47d,u+1f4a3,u+1f4b0,u+1f4b3,u+1f4b9,u+1f4bb,u+1f4bf,u+1f4c8-1f4cb,u+1f4d6,u+1f4da,u+1f4df,u+1f4e3-1f4e6,u+1f4ea-1f4ed,u+1f4f7,u+1f4f9-1f4fb,u+1f4fd-1f4fe,u+1f503,u+1f507-1f50b,u+1f50d,u+1f512-1f513,u+1f53e-1f54a,u+1f54f-1f5fa,u+1f610,u+1f650-1f67f,u+1f687,u+1f68d,u+1f691,u+1f694,u+1f698,u+1f6ad,u+1f6b2,u+1f6b9-1f6ba,u+1f6bc,u+1f6c6-1f6cf,u+1f6d3-1f6d7,u+1f6e0-1f6ea,u+1f6f0-1f6f3,u+1f6f7-1f6fc,u+1f7??,u+1f800-1f80b,u+1f810-1f847,u+1f850-1f859,u+1f860-1f887,u+1f890-1f8ad,u+1f8b0-1f8bb,u+1f8c0-1f8c1,u+1f900-1f90b,u+1f93b,u+1f946,u+1f984,u+1f996,u+1f9e9,u+1fa00-1fa6f,u+1fa70-1fa7c,u+1fa80-1fa89,u+1fa8f-1fac6,u+1face-1fadc,u+1fadf-1fae9,u+1faf0-1faf8,u+1fb??}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/b5ee789b512e4d1b-s.woff2) format("woff2");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+0300-0301,u+0303-0304,u+0308-0309,u+0323,u+0329,u+1ea0-1ef9,u+20ab}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/2c07349e02a7b712-s.woff2) format("woff2");unicode-range:u+0100-02ba,u+02bd-02c5,u+02c7-02cc,u+02ce-02d7,u+02dd-02ff,u+0304,u+0308,u+0329,u+1d00-1dbf,u+1e00-1e9f,u+1ef2-1eff,u+2020,u+20a0-20ab,u+20ad-20c0,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-family:Roboto;font-style:normal;font-weight:100 900;font-stretch:100%;font-display:swap;src:url(/_next/static/media/47cbc4e2adbc5db9-s.p.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+0304,u+0308,u+0329,u+2000-206f,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-family:Roboto Fallback;src:local("Arial");ascent-override:92.98%;descent-override:24.47%;line-gap-override:0.00%;size-adjust:99.78%}.__className_5d4a9e{font-family:Roboto,Roboto Fallback;font-style:normal}.__variable_5d4a9e{--font-roboto:"Roboto","Roboto Fallback"}:root{--background:#ffffff;--foreground:#171717}@media (prefers-color-scheme:dark){:root{--background:#0a0a0a;--foreground:#ededed}}body,html{max-width:100vw;overflow-x:hidden}body{color:var(--foreground);background:var(--background);font-family:Arial,Helvetica,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#f9f5f2;color:black}*{box-sizing:border-box;padding:0;margin:0}a{color:inherit;text-decoration:none}*{scrollbar-color:black #f9f5f2}
### File: .open-next/assets/_next/static/css/3efeb2a0fee35da0.css
.page_page__ZU32B{--gray-rgb:0,0,0;--gray-alpha-200:rgba(var(--gray-rgb),0.08);--gray-alpha-100:rgba(var(--gray-rgb),0.05);--button-primary-hover:#383838;--button-secondary-hover:#f2f2f2;min-height:100svh;font-family:var(--font-roboto);background-color:#f9f5f2}.page_main__GlU4n code{font-family:inherit;background:var(--gray-alpha-100);padding:2px 4px;border-radius:4px;font-weight:600}.page_footer__sHKi3{grid-row-start:3;gap:24px}.page_footer__sHKi3 a{display:flex;align-items:center;gap:8px}.page_footer__sHKi3 img{flex-shrink:0}@media (max-width:600px){.page_footer__sHKi3{flex-wrap:wrap;align-items:center;justify-content:center}}.page_header__kVzhN{width:100%;justify-content:space-between;padding:16px 32px}.page_header__kVzhN,.page_logo__7fc9l{display:flex;align-items:center}.page_menu__71kMP ul{display:flex;gap:24px;list-style:none}.page_header__kVzhN h1{font-size:20px}.page_hero__SKW6o{display:flex;width:100%;justify-content:center;align-items:center;padding:32px}.page_heroLeft__JBC6J{width:50%}.page_heroLeft__JBC6J h1{font-size:56px}.page_heroLeft__JBC6J h3{margin-bottom:8px}.page_heroLeft__JBC6J p{margin-top:20px;margin-bottom:20px}.page_heroRight__Ta9KO{position:relative;width:500px;height:500px}.page_heroButtons__5vj38{display:flex;gap:12px;margin-bottom:20px}.page_whoIsCxmputeFor__1u906{display:flex;flex-direction:column;align-items:center;gap:20px}.page_whoIsCxmputeForCards___PUEJ{display:flex;gap:24px;padding:0 32px 32px;width:100%;flex-wrap:wrap;justify-content:center}.page_whoIsCxmputeForCardImage__ByUgu{width:100px;height:100px;position:relative;border:6px solid #000;border-radius:10px;margin-bottom:24px}.page_imageWrapper__OufeY{margin:5px;position:relative;height:80px;width:80px}.page_imageWrapper2__BCyqF{margin:20px;position:relative;height:300px;width:300px}.page_whoIsCxmputeForCard__Jd_pO{width:300px;padding:20px;background:#fff;border:6px solid #000;box-shadow:12px 12px 0 #000;transition:transform .3s,box-shadow .3s;border-radius:10px;display:flex;flex-direction:column;justify-content:space-between}.page_whoIsCxmputeForCard__Jd_pO:hover{transform:translate(-5px,-5px);box-shadow:17px 17px 0 #000}.page_whoIsCxmputeForCard__title__7ZVS2{font-size:32px;font-weight:900;color:#000;margin-bottom:15px;display:block;position:relative;overflow:hidden}.page_whoIsCxmputeForCard__title__7ZVS2:after{content:"";position:absolute;bottom:0;left:0;width:90%;height:3px;background-color:#000;transform:translateX(-100%);transition:transform .3s}.page_whoIsCxmputeForCard__Jd_pO:hover .page_whoIsCxmputeForCard__title__7ZVS2:after{transform:translateX(0)}.page_whoIsCxmputeForCard__content__9nOrC{font-size:16px;line-height:1.4;color:#000;margin-bottom:20px}.page_whoIsCxmputeForCard__form__ciaDQ{display:flex;flex-direction:column;gap:15px}.page_whoIsCxmputeForCard__form__ciaDQ input{padding:10px;border:3px solid #000;font-size:16px;font-family:inherit;transition:transform .3s;width:calc(100% - 26px)}.page_whoIsCxmputeForCard__form__ciaDQ input:focus{outline:none;transform:scale(1.05);background-color:#000;color:#ffffff}.page_whoIsCxmputeForCard__button__2_R1_{border:3px solid #000;background:#000;color:#fff;padding:10px;font-size:16px;left:20%;font-weight:700;text-transform:uppercase;cursor:pointer;position:relative;overflow:hidden;transition:transform .3s;width:50%;height:auto}.page_whoIsCxmputeForCard__button__2_R1_:before{content:"SELECT";position:absolute;top:0;left:0;width:100%;height:105%;background-color:var(--select-bg-color,#20a191);color:#000;display:flex;align-items:center;justify-content:center;transform:translateY(100%);transition:transform .3s}.page_whoIsCxmputeForCard__button__2_R1_:hover:before{transform:translateY(0)}.page_whoIsCxmputeForCard__button__2_R1_:active{transform:scale(.95)}@keyframes page_glitch__OObIG{0%{transform:translate(2px,2px)}25%{transform:translate(-2px,-2px)}50%{transform:translate(-2px,2px)}75%{transform:translate(2px,-2px)}to{transform:translate(2px,2px)}}.page_glitch__OObIG{animation:page_glitch__OObIG .3s infinite}.page_identitySpecific__eDhfj{width:100%;display:flex;justify-content:center;align-items:center;height:auto;padding:16px 32px}.page_ISLeft__hjwPx{width:40%;display:flex;flex-direction:column;gap:10px}.page_ISLeft__hjwPx p{max-width:80%}.page_ISLeft__hjwPx h1{font-size:56px}.page_ISLeft__hjwPx span{margin-top:10px;font-size:12px}.page_ISRight__ncJoh{width:60%;display:flex;flex-wrap:wrap;gap:30px;justify-content:flex-end}.page_ISBottom__YKSSp{display:flex;gap:10px}.page_idenitytSpecificContainer__v6wK9{display:flex;flex-direction:row}.page_idenitytSpecificInput__container__XPi0h{position:relative;background:#f0f0f0;padding:20px;display:flex;flex-direction:column;justify-content:flex-start;align-items:center;gap:15px;border:4px solid #000;max-width:350px;transition:all .4s cubic-bezier(.23,1,.32,1);transform-style:preserve-3d;perspective:1000px;box-shadow:10px 10px 0 #000;border-radius:10px}.page_shadow__idenitytSpecificInput__bJOqP{content:"";position:absolute;width:100%;height:100%;left:0;bottom:0;z-index:-1;transform:translateZ(-50px);background:linear-gradient(45deg,rgba(255,107,107,.4),rgba(255,107,107,.1));filter:blur(20px)}.page_idenitytSpecificInput__button__shadow__TxB3T{cursor:pointer;border:3px solid #000;background:var(--specific-feature-color);transition:all .4s cubic-bezier(.23,1,.32,1);display:flex;justify-content:center;align-items:center;padding:10px;transform:translateZ(20px);position:relative;z-index:3;font-weight:700;text-transform:uppercase}.page_idenitytSpecificInput__button__shadow__TxB3T:hover{background:var(--specific-feature-color);transform:translateZ(10px) translateX(-5px) translateY(-5px);box-shadow:5px 5px 0 0 #000}.page_idenitytSpecificInput__button__shadow__TxB3T svg{fill:#000;width:25px;height:25px}.page_idenitytSpecificInput__search__IdGZl{width:100%;outline:none;border:3px solid #000;padding:15px;font-size:18px;background:#fff;color:#000;transform:translateZ(10px);transition:all .4s cubic-bezier(.23,1,.32,1);position:relative;z-index:3;font-family:Roboto,Arial,sans-serif;letter-spacing:-.5px}.page_idenitytSpecificInput__search__IdGZl::placeholder{color:#666;font-weight:700;text-transform:uppercase}.page_idenitytSpecificInput__search__IdGZl:focus,.page_idenitytSpecificInput__search__IdGZl:hover{background:#f0f0f0;transform:translateZ(20px) translateX(-5px) translateY(-5px);box-shadow:5px 5px 0 0 #000}.page_idenitytSpecificInput__container__XPi0h:before{content:var(--specific-feature,"FEATURE");position:absolute;top:-15px;left:20px;background:var(--specific-feature-color);color:#000;font-weight:700;padding:5px 10px;font-size:14px;transform:translateZ(25px);z-index:4;border:2px solid #000}.page_idenitytSpecificInput__container__XPi0h h1{font-weight:600}.page_protected__aMUUz{width:100%;display:flex;justify-content:center;padding:54px}.page_protectedContainer__5k90k{width:100%;display:flex;align-items:center;justify-content:center;gap:20px;margin-top:20px;margin-bottom:20px;padding:32px;max-width:1300px;background-color:#d4d4cb;border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000}.page_protectedImageContainer__wVXOs{width:50%;height:auto;background-color:#20a191;border:6px solid #000;border-radius:20px}.page_protectedTextContainer__vbn1V h1{font-size:56px;margin-bottom:20px}.page_testimonials__T_1MQ{width:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:54px}.page_testimonials__T_1MQ h2{margin-bottom:20px;width:100%;text-align:center;font-size:48px}.page_testimonialsContainer__U3EzN{width:100%;display:flex;gap:20px;margin-top:20px;margin-bottom:20px;padding:32px;max-width:1300px;border-radius:20px;overflow-x:auto;scroll-snap-type:x mandatory;-webkit-overflow-scrolling:touch}.page_testimonial__XOTWH{background-color:var(--testimonial-color);border:6px solid #000;padding:48px;min-width:300px;max-width:800px;font-size:20px;flex-shrink:0;scroll-snap-align:start;border-radius:10px;box-shadow:12px 12px 0 #000;transition:transform .3s,box-shadow .3s}.page_testimonial__XOTWH:hover{transform:translate(-5px,-5px);box-shadow:17px 17px 0 #000}.page_architecture__FLzVT{width:100%;padding:54px;display:flex;flex-direction:column;justify-content:center;align-items:center}.page_architectureContainer__wKYqG{width:100%;display:flex;gap:20px;margin-top:20px;margin-bottom:20px;padding:32px;max-width:1300px;border-radius:20px}.page_ALeft__IDh_M,.page_ARight__hDgfR{width:50%;height:auto}.page_ALeft__IDh_M h1{font-size:56px}.page_architectureLayer__3Sd7T{border:6px solid #000;background-color:var(--architecture-layer-color);margin-bottom:20px;border-radius:10px;box-shadow:6px 6px 0 #000;transition:transform .3s,box-shadow .3s;padding:20px}.page_architectureLayer__3Sd7T:hover{transform:translate(-2.5px,-2.5px);box-shadow:10px 10px 0 #000}.page_token__fGPId{width:100%;padding:54px;display:flex;flex-direction:column;justify-content:center;align-items:center}.page_tokenContainer__Ei669{width:100%;display:flex;align-items:center;gap:20px;margin-top:20px;margin-bottom:20px;padding:32px;max-width:1300px;border-radius:20px;background-color:#d64989;border:6px solid #000;box-shadow:12px 12px 0 #000}.page_cxptToken__kBhcS{height:500px;width:500px;border:6px solid #000;border-radius:50%;box-shadow:12px 12px 0 #000;position:relative;transition:transform .3s,box-shadow .3s}.page_cxptToken__kBhcS:hover{transform:translate(-5px,-5px);box-shadow:17px 17px 0 #000}.page_blog__mjsei{width:100%;padding:54px;display:flex;flex-direction:column;justify-content:center;align-items:center}.page_blogContainer__8cNyT{width:100%;gap:20px;margin-top:20px;margin-bottom:20px;padding:32px;max-width:1400px}.page_blogCards__onTqc{display:flex;flex-wrap:wrap;gap:20px;justify-content:center}.page_blogCard__BMGej{background-color:var(--blog-card-color);border:6px solid #000;padding:24px;min-width:280px;max-width:300px;font-size:20px;flex-shrink:0;border-radius:10px;box-shadow:12px 12px 0 #000;transition:transform .3s,box-shadow .3s}.page_blogCard__BMGej h1{font-size:32px}.page_blogCard__BMGej p{font-size:18px;margin-top:10px;margin-bottom:10px}.page_blogCard__BMGej:hover{transform:translate(-5px,-5px);box-shadow:17px 17px 0 #000}.page_blogTitle__pmarS{background-color:#20a191;width:max-content;padding:10px;border-radius:10px;border:6px solid #000;box-shadow:6px 6px 0 #000;transition:transform .3s,box-shadow .3s;margin-bottom:24px}.page_blogTitle__pmarS:hover{transform:translate(-2.5px,-2.5px);box-shadow:10px 10px 0 #000}.page_blogCardImage__koP5t{width:200px;height:200px;margin-bottom:20px;border-radius:10px;position:relative}.page_faq__hmOuC{width:100%;padding:54px;display:flex;flex-direction:column;justify-content:center;align-items:center}.page_faqContainer__AQ1nw{width:100%;gap:20px;margin-top:20px;margin-bottom:20px;padding:32px;max-width:800px}.page_faqCardHeader__X30OS{display:flex;justify-content:space-between}.page_mapt__4X2LI{width:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:0 54px 54px}.page_mapContainer__fQ84Y{width:100%;gap:20px;margin-top:20px;margin-bottom:20px;max-width:2000px;position:relative}.page_mapTextOverlay__jOarX{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;justify-content:center;align-items:center}.page_mapTextOverlay__jOarX h1{margin-bottom:20px;text-align:center}.page_mapOverlayImage__aoOC0{position:relative;height:100px;width:100px}.page_footer__sHKi3{width:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;padding:54px 54px 0}.page_footerContainer__bQZKx{width:100%;gap:20px;margin-top:20px;padding:32px;max-width:1300px;display:flex;background-color:#20a191;height:40vh;border-radius:20px 20px 0 0;border:6px solid #000;border-bottom:none;justify-content:space-between}.page_footerSocialLinks__5_K57{display:flex}.page_footerSocialLink__372uk{background-color:#f8cb46;border-radius:50%;width:40px;height:40px;display:flex;justify-content:center;align-items:center;margin-right:10px;box-shadow:4px 4px 0 #000;border:2px solid #000;cursor:pointer;transition:transform .3s,box-shadow .3s}.page_footerSocialLink__372uk:hover{transform:translate(-2.5px,-2.5px);box-shadow:7px 7px 0 #000}.page_footerRight__FpukQ{display:flex;flex-direction:column;justify-content:space-between;align-items:flex-end}.page_footerButtons__kO6SL{display:flex;gap:20px}@media (max-width:1200px){.page_heroRight__Ta9KO{width:400px;height:400px}.page_ALeft__IDh_M h1,.page_ISLeft__hjwPx h1{font-size:48px}}@media (max-width:992px){.page_hero__SKW6o{flex-direction:column;align-items:center;text-align:center}.page_heroLeft__JBC6J{width:100%;margin-bottom:20px}.page_heroRight__Ta9KO{width:100%;height:400px}.page_architectureContainer__wKYqG,.page_blogContainer__8cNyT,.page_footerContainer__bQZKx,.page_tokenContainer__Ei669{flex-direction:column;align-items:center}.page_architectureLayer__3Sd7T,.page_blogCard__BMGej,.page_cxptToken__kBhcS,.page_protectedContainer__5k90k{margin:0 auto 20px}.page_ALeft__IDh_M,.page_ARight__hDgfR{width:100%}.page_cxptToken__kBhcS{margin:0 auto}.page_ISLeft__hjwPx,.page_ISRight__ncJoh{width:100%}.page_ISRight__ncJoh{justify-content:center}}@media (max-width:768px){.page_ALeft__IDh_M h1,.page_ISLeft__hjwPx h1,.page_heroLeft__JBC6J h1,.page_protectedTextContainer__vbn1V h1,.page_tokenContainer__Ei669 .page_ALeft__IDh_M h1{font-size:36px}.page_ISLeft__hjwPx p,.page_architectureLayer__3Sd7T p,.page_blogCard__BMGej p,.page_heroLeft__JBC6J p,.page_protectedTextContainer__vbn1V p{font-size:16px}.page_whoIsCxmputeForCard__title__7ZVS2{font-size:24px}.page_whoIsCxmputeForCard__Jd_pO{width:100%;margin:0 auto}.page_footerContainer__bQZKx{height:auto}.page_heroButtons__5vj38,.page_menu__71kMP ul{display:flex;flex-direction:column}.page_whoIsCxmputeFor__1u906 h1{text-align:center}.page_idenitytSpecificContainer__v6wK9{flex-direction:column;gap:20px}.page_protectedContainer__5k90k{flex-direction:column}.page_protected__aMUUz{padding:10px}.page_protectedImageContainer__wVXOs{width:100%}.page_imageWrapper2__BCyqF{margin:0}.page_testimonial__XOTWH{width:200px;padding:10px}.page_testimonials__T_1MQ{padding:10px}.page_cxptToken__kBhcS{width:200px;height:200px}.page_blogContainer__8cNyT{display:flex;flex-direction:column;align-items:center}.page_blogTitle__pmarS{max-width:300px}.page_architecture__FLzVT,.page_footer__sHKi3,.page_token__fGPId{padding:10px}.page_footerSocialLinks__5_K57{flex-wrap:wrap;margin-bottom:20px}.page_footerSocialLink__372uk{margin-bottom:10px}}@media (max-width:480px){.page_architectureContainer__wKYqG,.page_blogContainer__8cNyT,.page_faqContainer__AQ1nw,.page_hero__SKW6o,.page_testimonialsContainer__U3EzN,.page_tokenContainer__Ei669,.page_whoIsCxmputeForCards___PUEJ{padding:16px}.page_cxptToken__kBhcS,.page_heroRight__Ta9KO,.page_imageWrapper2__BCyqF{width:100%;height:300px}.page_ISLeft__hjwPx h1,.page_ISLeft__hjwPx h3,.page_heroLeft__JBC6J h1,.page_heroLeft__JBC6J h3{text-align:center}.page_ISLeft__hjwPx p{margin:0 auto;text-align:center}.page_footerContainer__bQZKx{flex-direction:column;align-items:center}.page_footerRight__FpukQ{align-items:center}.page_footerButtons__kO6SL{flex-direction:column;gap:10px}.page_header__kVzhN{flex-direction:column}.page_menu__71kMP{display:none}.page_cxptToken__kBhcS{width:200px;height:200px}}@media (max-width:320px){.page_ISLeft__hjwPx h1,.page_heroLeft__JBC6J h1{font-size:28px}.page_ISLeft__hjwPx p,.page_heroLeft__JBC6J p{font-size:14px}.page_testimonialsContainer__U3EzN{padding:8px}.page_testimonial__XOTWH{padding:24px;min-width:250px;font-size:16px}.page_blogCards__onTqc{flex-direction:column;align-items:center}.page_blogCard__BMGej{max-width:280px}.page_footerSocialLink__372uk{width:35px;height:35px}}.button_button__TIoc7{font-family:Montserrat,sans-serif;font-size:.9rem;border:2px solid black;border-radius:7px;padding:.3rem .5rem;background-color:white;box-shadow:5px 5px 0 black;cursor:pointer;text-align:center;font-weight:700;display:flex;align-items:center;justify-content:center;gap:.5rem;transition:all .3s ease}.button_button__TIoc7:hover{box-shadow:0 0 0 black;transform:translateY(3px) translateX(3px)}.button_icon__v_awl{width:24px;height:24px;transition:all .3s ease-in-out}.page_main__sp3vQ{align-items:center;font-family:var(--font-roboto)}.page_docWrapper__77GnU,.page_main__sp3vQ{display:flex;flex-direction:column;width:100%;padding:32px}.page_docWrapper__77GnU{max-width:800px;gap:24px;margin-top:20px;margin-bottom:20px}.page_docWrapper__77GnU h1{border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000;padding:20px;margin-bottom:48px}.page_docWrapper__77GnU h1,.page_docWrapper__77GnU h2{background-color:#91a8eb;transition:all .3s ease-in-out}.page_docWrapper__77GnU h2{border:6px solid #000;border-radius:10px;box-shadow:6px 6px 0 #000;padding:10px;margin-top:24px;width:max-content}.page_docWrapper__77GnU h2:hover{transform:translate(-5px,-5px);box-shadow:8px 8px 0 #000}.page_docWrapper__77GnU h3{background-color:#fe91e8;border:3px solid #000;border-radius:5px;box-shadow:6px 6px 0 #000;padding:5px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_main__i0Mru{align-items:center;font-family:var(--font-roboto)}.page_docWrapper___ZHrd,.page_main__i0Mru{display:flex;flex-direction:column;width:100%;padding:32px}.page_docWrapper___ZHrd{max-width:800px;gap:24px;margin-top:20px;margin-bottom:20px}.page_docWrapper___ZHrd h1{background-color:#20a191;border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000;padding:20px;transition:all .3s ease-in-out;margin-bottom:48px}.page_docWrapper___ZHrd h2{background-color:#91a8eb;border:6px solid #000;border-radius:10px;box-shadow:6px 6px 0 #000;padding:10px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_docWrapper___ZHrd h2:hover{transform:translate(-5px,-5px);box-shadow:8px 8px 0 #000}.page_docWrapper___ZHrd h3{background-color:#fe91e8;border:3px solid #000;border-radius:5px;box-shadow:6px 6px 0 #000;padding:5px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_main__2vmTs{align-items:center;font-family:var(--font-roboto)}.page_docWrapper__D6QYE,.page_main__2vmTs{display:flex;flex-direction:column;width:100%;padding:32px}.page_docWrapper__D6QYE{max-width:800px;gap:24px;margin-top:20px;margin-bottom:20px}.page_docWrapper__D6QYE h1{background-color:#f8cb46;border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000;padding:20px;transition:all .3s ease-in-out;margin-bottom:48px}.page_docWrapper__D6QYE h2{background-color:#91a8eb;border:6px solid #000;border-radius:10px;box-shadow:6px 6px 0 #000;padding:10px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_docWrapper__D6QYE h2:hover{transform:translate(-5px,-5px);box-shadow:8px 8px 0 #000}.page_docWrapper__D6QYE h3{background-color:#fe91e8;border:3px solid #000;border-radius:5px;box-shadow:6px 6px 0 #000;padding:5px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_main__Mvmcx{align-items:center;font-family:var(--font-roboto)}.page_docWrapper__ijmtR,.page_main__Mvmcx{display:flex;flex-direction:column;width:100%;padding:32px}.page_docWrapper__ijmtR{max-width:800px;gap:24px;margin-top:20px;margin-bottom:20px}.page_docWrapper__ijmtR h1{background-color:#f8cb46;border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000;padding:20px;transition:all .3s ease-in-out;margin-bottom:48px}.page_docWrapper__ijmtR h2{background-color:#91a8eb;border:6px solid #000;border-radius:10px;box-shadow:6px 6px 0 #000;padding:10px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_docWrapper__ijmtR h2:hover{transform:translate(-5px,-5px);box-shadow:8px 8px 0 #000}.page_docWrapper__ijmtR h3{background-color:#fe91e8;border:3px solid #000;border-radius:5px;box-shadow:6px 6px 0 #000;padding:5px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.__101_main__N5S3H{align-items:center;font-family:var(--font-roboto)}.__101_docWrapper__i0sHP,.__101_main__N5S3H{display:flex;flex-direction:column;width:100%;padding:32px}.__101_docWrapper__i0sHP{max-width:800px;gap:24px;margin-top:20px;margin-bottom:20px}.__101_docWrapper__i0sHP h1{background-color:#f8cb46;border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000;padding:20px;transition:all .3s ease-in-out;margin-bottom:48px}.__101_docWrapper__i0sHP h2{background-color:#91a8eb;border:6px solid #000;border-radius:10px;box-shadow:6px 6px 0 #000;padding:10px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.__101_docWrapper__i0sHP h2:hover{transform:translate(-5px,-5px);box-shadow:8px 8px 0 #000}.__101_docWrapper__i0sHP h3{background-color:#fe91e8;border:3px solid #000;border-radius:5px;box-shadow:6px 6px 0 #000;padding:5px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.faqCard_faqCardHeader__M8TSw{display:flex;justify-content:space-between;cursor:pointer}.faqCard_faqCard__XImvu{margin-top:32px;margin-bottom:32px}.faqCard_faqCard__XImvu h1{font-size:20px;margin-bottom:24px}.page_main__CcSqo{align-items:center;font-family:var(--font-roboto)}.page_docWrapper__B7JLk,.page_main__CcSqo{display:flex;flex-direction:column;width:100%;padding:32px}.page_docWrapper__B7JLk{max-width:800px;gap:24px;margin-top:20px;margin-bottom:20px}.page_docWrapper__B7JLk h1{background-color:#f8cb46;border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000;padding:20px;transition:all .3s ease-in-out;margin-bottom:48px}.page_docWrapper__B7JLk h2{background-color:#91a8eb;border:6px solid #000;border-radius:10px;box-shadow:6px 6px 0 #000;padding:10px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_docWrapper__B7JLk h2:hover{transform:translate(-5px,-5px);box-shadow:8px 8px 0 #000}.page_docWrapper__B7JLk h3{background-color:#fe91e8;border:3px solid #000;border-radius:5px;box-shadow:6px 6px 0 #000;padding:5px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_main__A4cMf{align-items:center;font-family:var(--font-roboto)}.page_docWrapper__FbGIS,.page_main__A4cMf{display:flex;flex-direction:column;width:100%;padding:32px}.page_docWrapper__FbGIS{max-width:800px;gap:24px;margin-top:20px;margin-bottom:20px}.page_docWrapper__FbGIS h1{background-color:#f8cb46;border:6px solid #000;border-radius:20px;box-shadow:12px 12px 0 #000;padding:20px;transition:all .3s ease-in-out;margin-bottom:48px}.page_docWrapper__FbGIS h2{background-color:#91a8eb;border:6px solid #000;border-radius:10px;box-shadow:6px 6px 0 #000;padding:10px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}.page_docWrapper__FbGIS h2:hover{transform:translate(-5px,-5px);box-shadow:8px 8px 0 #000}.page_docWrapper__FbGIS h3{background-color:#fe91e8;border:3px solid #000;border-radius:5px;box-shadow:6px 6px 0 #000;padding:5px;transition:all .3s ease-in-out;margin-top:24px;width:max-content}
### File: next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

### File: src/app/roadmap/page.module.css
.main{
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    padding: 32px;
    font-family: var(--font-roboto);
}

.docWrapper{
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 24px;
    margin-top: 20px;
    margin-bottom: 20px;
    padding: 32px;
}

.docWrapper h1{
    background-color: #f8cb46;
    border: 6px solid #000;
    border-radius: 20px;
    box-shadow: 12px 12px 0 #000;
    padding: 20px;
    transition: all 0.3s ease-in-out;
    margin-bottom: 48px;
}

/* .docWrapper h1:hover{
    transform: translate(-5px, -5px);
    box-shadow: 17px 17px 0 #000;
} */

.docWrapper h2{
    background-color: #91a8eb;
    border: 6px solid #000;
    border-radius: 10px;
    box-shadow: 6px 6px 0 #000;
    padding: 10px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

.docWrapper h2:hover{
    transform: translate(-5px, -5px);
    box-shadow: 8px 8px 0 #000;
}

.docWrapper h3{
    background-color: #fe91e8;
    border: 3px solid #000;
    border-radius: 5px;
    box-shadow: 6px 6px 0 #000;
    padding: 5px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

### File: src/app/roadmap/page.tsx
import Button from "@/components/button/button";
import styles from "./page.module.css";
import Link from "next/link";

export default function Roadmap() {
  return (
    <main className={styles.main}>
      <div className={styles.docWrapper}>
        <h1>Cxmpute Roadmap & Future Work</h1>
        <p>
          Before we dive into the exciting details of our roadmap, imagine this:
          building Cxmpute is like creating a futuristic metropolis where every idle
          computer is a vibrant power plant, lighting up a digital cityscape with untapped energy.
          Our journey is guided by a clear blueprint that transforms vision into reality—one inspiring
          step at a time.
        </p>
        <h2>Provider Onboarding: Rallying the Pioneers</h2>
        <p>
          Every great city needs its architects. In our case, we’re inviting individuals and enterprises alike
          to join as compute providers. Think of it as assembling a team of trailblazers, each contributing
          their spare compute power to build a robust, globally distributed network. By sharing your idle
          cycles, you’re not just earning rewards—you’re powering the future of decentralized computing.
        </p>
        <p>
          <Link href="/download">
            <Button text="Join as a Provider" backgroundColor="#20a191" />
          </Link>
        </p>
        <h2>User Engagement: Sparking a Lively Community</h2>
        <p>
          What’s a city without its bustling streets? We’re creating a vibrant, demand-driven ecosystem where
          developers, AI researchers, and enterprises come together to collaborate and innovate.
          Our goal is to make Cxmpute as accessible and valuable as a neighborhood café where ideas flow
          as freely as coffee.
        </p>
        <p>
          <Link href="/dashboard">
            <Button text="Get Involved as a User" backgroundColor="#fe91e8" />
          </Link>
        </p>
        <h2>Software Development: Crafting a Seamless Experience</h2>
        <p>
          Just like a well-designed city needs smooth roads and clear signs, our software development phase
          ensures that every interface, API, and tool works in harmony. We’re finalizing and optimizing our
          platform for high performance and seamless integration—so every journey on our network is as smooth
          as a scenic drive through a digital wonderland.
        </p>
        <h2>Closed Beta Launch: Testing the Blueprint</h2>
        <p>
          Every new metropolis goes through a trial run, and our closed beta is that crucial first public
          stroll. This stage is all about testing performance, security, and user experience. Feedback from
          our early explorers will serve as our compass, guiding improvements and setting the stage for the next big leap.
        </p>
        <h2>Public Mainnet Launch: Opening the Gates</h2>
        <p>
          The day is coming when our doors swing wide open. With the public mainnet launch, decentralized
          compute services will be available to everyone, marking the official start of a new era.
          It’s like the grand opening of a city where every resident—whether a provider or a user—can contribute
          to and benefit from the collective power of the network.
        </p>
        <h2>Future Expansion: Building Tomorrow, Today</h2>
        <p>
          Our roadmap doesn’t end with the mainnet launch. We’re already dreaming bigger: expanding service offerings,
          reinforcing security protocols, and forging strategic partnerships that propel Cxmpute into new realms of innovation.
          With community feedback and decentralized governance at the heart of our journey, the future is a canvas waiting
          to be painted with bold, revolutionary ideas.
        </p>
        <p>
          Ready to be a part of this vibrant future? Whether you’re here to contribute or to harness the power of decentralized
          computing, join us as we build a smarter, more connected world—one idle cycle at a time.
        </p>
        <Link href="/">
          <Button text="Back to Home" backgroundColor="#20a191" />
        </Link>
      </div>
    </main>
  );
}

### File: src/app/user/user.module.css

### File: src/app/user/page.tsx
import styles from './user.module.css';

export default function UserPage() {
    return (
        <main className={styles.main}>
            <h1>User Page</h1>
        </main>
    );
}
### File: src/app/models/models.module.css
.container {
  padding: 2rem;
  /* background-color: var(--cxmpute-lightyellow); */
}

.hero{
    height: 50vh;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
}
.hero h1{
  margin-bottom: 20px;
}

.heroContent,
.content{
    max-width: 1200px;
    margin: 0 auto;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.title {
  font-size: 1.5rem;
  font-weight: 600;
  color: #333;
}

.statsBar {
  display: flex;
  align-items: center;
  gap: 1rem;
  color: #666;
  font-size: 0.9rem;
}

.resetButton {
  background: none;
  border: none;
  color: #2563eb;
  cursor: pointer;
  font-size: 0.9rem;
}

.filterBar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.searchContainer {
  position: relative;
  flex-grow: 1;
  max-width: 300px;
}

.searchIcon {
  position: absolute;
  left: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #6b7280;
}

.searchInput {
  width: 100%;
  padding: 0.75rem 1rem 0.75rem 2.5rem;
  border-radius: 0.375rem;
  background-color: #f9fafb;
  font-size: 0.875rem;
  border: 3px solid #000;  
}

.viewOptions {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.sortContainer {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  margin-right: 1rem;
  color: #6b7280;
  font-size: 0.875rem;
}

.viewButton {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 2rem;
  height: 2rem;
  border: 1px solid #e5e7eb;
  border-radius: 0.375rem;
  background-color: white;
  color: #6b7280;
  cursor: pointer;
}

.viewButton.active {
  background-color: #f3f4f6;
  color: #111827;
}

.modelsGrid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 1.5rem;
}

.modelsList {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.modelCard {
  display: flex;
  flex-direction: column;
  padding: 1.25rem;
  border: 1px solid #e5e7eb;
  border-radius: 0.5rem;
  background-color: white;
  border: 6px solid #000;
  box-shadow: 12px 12px 0 #000;
  transition: transform 0.3s, box-shadow 0.3s;
}

.modelCard:hover {
    transform: translate(-5px, -5px);
    box-shadow: 17px 17px 0 #000;
}

.modelHeader {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 0.75rem;
}

.modelNameContainer {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.modelName {
  font-size: 1.125rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.infoButton {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  cursor: pointer;
  color: #6b7280;
  text-decoration: none;
}

.infoIcon {
  font-size: 1rem;
}

.modelMeta {
  font-size: 0.875rem;
  color: #6b7280;
}

.tokenCount {
  background-color: #f3f4f6;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.75rem;
}

.modelDescription {
  margin: 0 0 1rem 0;
  font-size: 0.875rem;
  color: #4b5563;
  line-height: 1.5;
  flex-grow: 1;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.tags {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.categoryTag {
  font-size: 0.75rem;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  background-color: #e0f2fe;
  color: #0369a1;
}

.inputTag {
  font-size: 0.75rem;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  background-color: #f3e8ff;
  color: #7e22ce;
}

.outputTag {
  font-size: 0.75rem;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  background-color: #dcfce7;
  color: #15803d;
}

.modelFooter {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.75rem;
  color: #6b7280;
}

.creatorInfo {
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.creatorLink {
  color: #2563eb;
  text-decoration: none;
}

.creatorLink:hover {
  text-decoration: underline;
}

.modelStats {
  display: flex;
  gap: 0.75rem;
}

.contextSize {
  display: inline-block;
}

@media (max-width: 768px) {
  .modelsGrid {
    grid-template-columns: 1fr;
  }
  
  .header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
  
  .filterBar {
    flex-direction: column;
    align-items: flex-start;
    gap: 1rem;
  }
  
  .searchContainer {
    width: 100%;
    max-width: none;
  }
  
  .viewOptions {
    width: 100%;
    justify-content: space-between;
  }
}

.mainheader{
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 32px;
}

.logo{
  display: flex;
  align-items: center;
  cursor: pointer;
}

.menu ul{
  display: flex;
  gap: 24px;
  list-style: none;
}

.mainheader h1{
  font-size: 20px;
}

/* ▼▼▼ NEW STYLES for category filter ▼▼▼ */
.categoryFilter {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
  margin-left: 1rem;      /* keeps a bit of separation from search box */
}

.categoryButton {
  border-radius: 0.375rem;
  margin-right: 10px;
  background: transparent;
  font-size: 0.875rem;
  cursor: pointer;
  border: none;
}

/* .activeCategory {
  background-color: #f3f4f6;
  color: #111827;
} */


@media (max-width: 768px) {
  .mainheader {
    flex-direction: column;
    gap: 0.75rem;
  }

  .menu ul {
    flex-wrap: wrap;
    justify-content: center;
  }

  /* .details {
    margin-top: 1.5rem;
  } */
   .hero {
    height: 50vh;
   }
}

.heroBottom{
  margin-top: 30px;
}

.logoImages{
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  justify-content: center;
  pointer-events: none;
}

.backgroundPattern {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: 
    radial-gradient(circle, rgba(150, 100, 255, 0.10) 2px, transparent 2px) 0 0 / 40px 40px,
    radial-gradient(circle, rgba(255, 100, 200, 0.10) 2px, transparent 2px) 20px 20px / 40px 40px;
  opacity: 0.8;
  pointer-events: none;
}
### File: src/app/models/page.tsx
'use client';

import { useState } from 'react';
import { models } from '@/lib/references';
import styles from './models.module.css';
import { Search, Info } from 'lucide-react';
import Image from 'next/image';
import Button from '@/components/button/button';

const cxmputeGreen = '#20a191';
const cxmputePurple = '#91a8eb';
const cxmputeRed = "#d64989";
const cxmputeOrange = "#f76707";
const cxmputeYellow = "#f8cb46";

export default function ModelsPage() {
  // text search
  const [filterText, setFilterText] = useState('');

  // new category selector  ────────────────┐
  const [category, setCategory] = useState<'all' | 'embeddings' | 'text' | 'vision' | 'code' | 'video' | 'audio'>('all');
  //                                          └───────────────────────────────────────┘

  // combined filter
  const filteredModels = models.filter((model) => {
    const matchesText =
      model.Name.toLowerCase().includes(filterText.toLowerCase()) ||
      model.description.toLowerCase().includes(filterText.toLowerCase()) ||
      model.Category.toLowerCase().includes(filterText.toLowerCase());

    const matchesCategory =
      category === 'all' || model.Category.toLowerCase() === category;

    return matchesText && matchesCategory;
  });


  return (
    <div className={styles.container}>
      <div className={styles.backgroundPattern}></div>

      {/* ─────────────────────────── NAV / HERO ─────────────────────────── */}
      <header className={styles.mainheader}>
        <div className={styles.logo} onClick={() => (window.location.href = '/')}>
          <Image src="/images/1.png" alt="cxmpute logo" height={70} width={70} />
          <h1>CXMPUTE</h1>
        </div>

        <div className={styles.menu}>
          <ul>
            
            <li>
              <a href="/docs">
                <Button text="DOCUMENTATION" backgroundColor={cxmputePurple} />
              </a>
            </li>
            <li>
              <a href="/dashboard">
                <Button text=" DASHBOARD" backgroundColor={cxmputeGreen} />
              </a>
            </li>
            <li>
              <a href="/download">
                <Button text="BECOME A PROVIDER" backgroundColor={cxmputeYellow} />
              </a>
            </li>
          </ul>
        </div>
      </header>

      <div className={styles.hero}>
        <div className={styles.heroContent}>
          <h1 className={styles.heroTitle}>Your multi-model, multi-modal, multi-lingual inference platform.</h1>
          <p className={styles.heroDescription}>
            All your AI models in one API—LLM, TTS, image gen, instantly.
          </p>
          <div className={styles.heroBottom}>
          <h3 className={styles.logoTitle}>Featuring models from:</h3>
            <div className={styles.logoImages}>
              <Image src="/images/google.png" alt="google logo" height={70} width={70} />
              <Image src="/images/qwen.png" alt="qwen logo" height={70} width={70} />
              <Image src="/images/ibm.png" alt="ibm logo" height={70} width={70} />
              <Image src="/images/deepseek.png" alt="deepseek logo" height={70} width={70} />
              <Image src="/images/meta.png" alt="meta logo" height={70} width={70} />
              <Image src="/images/mistral.png" alt="mistral logo" height={70} width={70} />
            </div>
          </div>
        </div>
      </div>

      {/* ─────────────────────────── MAIN CONTENT ─────────────────────────── */}
      <div className={styles.content}>

        {/* search / sort / category / view toggles */}
        <div className={styles.filterBar}>
          {/* search box */}
          <div className={styles.searchContainer}>
            <Search className={styles.searchIcon} size={16} />
            <input
              type="text"
              placeholder="Filter models"
              className={styles.searchInput}
              value={filterText}
              onChange={(e) => setFilterText(e.target.value)}
            />
          </div>

          {/* new category buttons */}
          <div className={styles.categoryFilter}>
            {(['all', 'embeddings', 'text', 'vision', 'code', 'video', 'audio'] as const).map((c) => (
              <div
                key={c}
                className={`${styles.categoryButton} ${
                  category === c ? styles.activeCategory : ''
                }`}
                onClick={() => setCategory(c)}
              >
                <Button text={
                    c === 'all' ? 'All' : c.charAt(0).toUpperCase() + c.slice(1)} 
                    backgroundColor={c === 'all' ? cxmputeGreen 
                        : c === 'embeddings' ? cxmputeOrange 
                        : c === 'text' ? cxmputePurple 
                        : c === 'vision' ? cxmputeYellow 
                        : c === 'code' ? cxmputeRed
                        : c === 'video' ? cxmputePurple
                        : c === 'audio' ? cxmputeOrange
                        : cxmputeRed}
                />
              </div>
            ))}
          </div>

        </div>

        {/* model cards */}
        <div
          className={ styles.modelsGrid }
        >
          {filteredModels.map((model, index) => (
            <div key={index} className={styles.modelCard} >
              {/* header */}
              <div className={styles.modelHeader}>
                <div className={styles.modelNameContainer}>
                  <a href={`/models/${model.slug}`} className={styles.modelLink}>
                    <h3 className={styles.modelName}>{model.Name}</h3>
                  </a>
                  {model.blogUrl && (
                    <a
                      href={model.blogUrl}
                      target="_blank"
                      rel="noopener noreferrer"
                      className={styles.infoButton}
                    >
                      <Info size={16}/>
                    </a>
                  )}
                </div>

                <div className={styles.modelMeta}>
                  {model.vectorSize && (
                    <span className={styles.tokenCount}>
                      {model.vectorSize} dimensions
                    </span>
                  )}
                  {!model.vectorSize && model.outputLength && (
                    <span className={styles.tokenCount}>
                      {model.outputLength}
                    </span>
                  )}
                </div>
              </div>

              {/* description */}
              <p className={styles.modelDescription}>{model.description}</p>

              {/* tags */}
              <div className={styles.tags}>
                {model.Category && (
                  <span className={styles.categoryTag}>{model.Category}</span>
                )}
                {model.InputModalities.map((m, idx) => (
                  <span key={`in-${idx}`} className={styles.inputTag}>
                    {m}
                  </span>
                ))}
                {model.OutputModalities.map((m, idx) => (
                  <span key={`out-${idx}`} className={styles.outputTag}>
                    {m}
                  </span>
                ))}
              </div>

              {/* footer */}
              <div className={styles.modelFooter}>
                <div className={styles.creatorInfo}>
                  by{' '}
                  <a href={model.creatorUrl} target="_blank" className={styles.creatorLink}>
                    {model.Creator}
                  </a>
                </div>
                <div className={styles.modelStats}>
                  {model.contextSize && (
                    <span className={styles.contextSize}>
                      {model.contextSize} context
                    </span>
                  )}
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

### File: src/app/models/[slug]/page.module.css
/* ─────────────────────────────
   CXMPUTE – Model detail page
   ───────────────────────────── */

/* ---------- Root layout ---------- */
.container {
  padding: 2rem;
  min-height: 100vh;
  /* background: var(--cxmpute-green, transparent); */
  box-sizing: border-box;
  max-width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  opacity: 1;
}
.backgroundPattern {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: 
    radial-gradient(circle, rgba(150, 100, 255, 0.10) 2px, transparent 2px) 0 0 / 40px 40px,
    radial-gradient(circle, rgba(255, 100, 200, 0.10) 2px, transparent 2px) 20px 20px / 40px 40px;
  opacity: 0.8;
  pointer-events: none;
}
/* ---------- Header ---------- */
.mainheader {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 32px;
  flex-wrap: wrap;
  row-gap: 0.75rem;
}

.logo {
  display: flex;
  align-items: center;
  cursor: pointer;
}

.mainheader h1 {
  font-size: 20px;
  margin-left: 0.5rem;
}

.menu ul {
  list-style: none;
  display: flex;
  flex-wrap: wrap;
  gap: 24px;
  margin: 0;
  padding: 0;
}

/* ---------- Grid layout ---------- */
.grid {
  display: flex;
  flex-direction: column;
  gap: 2rem;
  margin-top: 2rem;
  width: 100%;
  max-width: 700px !important;
  box-sizing: border-box;
}

/* ---------- Card-style section base ---------- */
.hero,
.contentCard {
  opacity: 1;
  border: 6px solid #000;
  border-radius: 20px;
  box-shadow: 10px 10px 0 #000;
  max-width: 100%;
  box-sizing: border-box;
  background-color: white !important;

}

.hero { 
  text-align: center; 
  padding: 40px;
}

.contentCard {
  padding: 0;
  overflow: hidden;
}

.title {
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 1rem;
}

/* ---------- Meta & tags ---------- */
.meta {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  font-size: 0.875rem;
  color: #6b7280;
  margin-bottom: 1rem;
  justify-content: center;
}

.metaItem span {
  font-weight: 600;
  color: #111827;
  margin-right: 0.25rem;
}

.creatorLink {
  color: #2563eb;
  text-decoration: none;
}
.creatorLink:hover { text-decoration: underline; }

.tags {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  justify-content: center;
}

.categoryTag,
.inputTag,
.outputTag {
  font-size: 0.75rem;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
}
.categoryTag { background: #e0f2fe; color: #0369a1; }
.inputTag    { background: #f3e8ff; color: #7e22ce; }
.outputTag   { background: #dcfce7; color: #15803d; }

/* ---------- Tab System ---------- */
.tabBar {
  display: flex;
  padding: 1rem;
  margin-bottom: 0;
  gap: 1rem;
}

.tabContent {
  padding: 2rem;
}

/* ---------- Markdown helpers ---------- */
.markdown :is(p, h1, h2, h3, h4, h5, h6, ul, ol, pre, blockquote) {
  margin-bottom: 1rem;
}

.markdown ul,
.markdown ol {
  margin-left: 1.5rem;
}

.markdown pre {
  overflow-x: auto;
  background: #111827;
  color: #f3f4f6;
  padding: 1rem;
  border-radius: 10px;
}

.markdown a {
  color: #2563eb;
  word-break: break-all;
}

.markdown img {
  max-width: 100%;
  height: auto;
}

/* Keep long tokens from stretching the layout */
.markdown,
.pre {
  overflow-wrap: break-word;
  word-break: break-word;
}

/* ---------- Playground container ---------- */
.playgroundContainer {
  display: flex;
  flex-direction: column;
}

.runButtonContainer {
  display: flex;
  margin: 1rem 0;
}

/* ---------- Playground controls ---------- */
.textarea,
.input {
  width: 100%;
  padding: 0.75rem 1rem;
  font: inherit;
  border-radius: 8px;
  border: 2px solid #d1d5db;
  margin-bottom: 1rem;
  color: #111827;
  background: #f8fafc;
  box-sizing: border-box;
  margin-top: 0.5rem;
}

.textarea {
  min-height: 120px;
  resize: vertical;
}

.textarea::placeholder,
.input::placeholder {
  color: #9ca3af;
}

.textarea:focus,
.input:focus {
  outline: none;
  border-color: #20a191;
  box-shadow: 0 0 0 2px rgba(32, 161, 145, 0.2);
}

.small {
  margin-top: 0.25rem;
  font-size: 0.75rem;
  color: #6b7280;
}

/* ---------- Results Section ---------- */
.resultsSection {
  margin-top: 1rem;
  padding-top: 1.5rem;
  border-top: 1px solid #e5e7eb;
}

.resultsSection h3 {
  margin-bottom: 1rem;
  font-size: 1.25rem;
  text-align: center;
}

/* ---------- Result / code block ---------- */
.pre {
  margin-top: 1rem;
  background: #111827;
  color: #f3f4f6;
  padding: 1rem;
  border-radius: 10px;
  overflow-x: auto;
  font-size: 0.875rem;
  max-width: 100%;
  box-sizing: border-box;
}

/* ---------- Media player ---------- */
.video,
.audio {
  display: block;
  max-width: 100%;
  margin: 0 auto;
}

/* ---------- Select ---------- */
.select {
  width: 100%;
  padding: 0.75rem 1rem;
  font: inherit;
  border-radius: 8px;
  border: 2px solid #d1d5db;
  margin-bottom: 1rem;
  color: #111827;
  background: #f8fafc;
  box-sizing: border-box;
  appearance: none;
}

.select:focus {
  outline: none;
  border-color: #20a191;
  box-shadow: 0 0 0 2px rgba(32, 161, 145, 0.2);
}

/* ---------- Blog link ---------- */
.blogLink {
  display: inline-block;
  color: #2563eb;
  text-decoration: none;
  font-weight: 500;
  margin-top: 0.5rem;
}

.blogLink:hover {
  text-decoration: underline;
}

/* ---------- Responsive adaptations ---------- */
@media (max-width: 768px) {
  .container {
    padding: 1rem;
    overflow-x: hidden;
  }

  .grid { gap: 1.5rem; }

  .hero,
  .contentCard {
    border-width: 4px;
    box-shadow: 6px 6px 0 #000;
  }
  
  .hero {
    padding: 28px 20px;
  }

  .tabContent {
    padding: 1.5rem 1rem;
  }
  
  .tabBar {
    flex-direction: column;
    padding: 0.75rem;
    gap: 0.5rem;
  }
}

@media (max-width: 480px) {
  .container { padding: 0.75rem; }

  .hero,
  .contentCard {
    border-width: 3px;
    box-shadow: 4px 4px 0 #000;
  }
  
  .hero {
    padding: 20px 16px;
  }

  .tabContent {
    padding: 1rem 0.75rem;
  }
  
  .title {
    font-size: 1.5rem;
  }
}

/* ---------- Final safeguard ---------- */
.grid,
.hero,
.contentCard,
.markdown pre,
.pre {
  max-width: 100%;
  min-width: 0;
  box-sizing: border-box;
}


### File: src/app/models/[slug]/page.tsx
/* eslint-disable @typescript-eslint/no-explicit-any */
'use client';

import { notFound } from 'next/navigation';
import Image from 'next/image';
import Link from 'next/link';
import ReactMarkdown from 'react-markdown';
import { use, useState } from 'react';

import { models } from '@/lib/references';
import Button from '@/components/button/button';
import styles from './page.module.css';

const cxmputeGreen  = '#20a191';
const cxmputePurple = '#91a8eb';
// const cxmputePink   = '#fe91e8';
const cxmputeOrange = '#ff8c00';
// const cxmputeGray   = '#6b7280';

// Handy: change the host at build-/run-time → NEXT_PUBLIC_ORCH_BASE_URL
const BASE_URL = '';
const voiceOptions = [ 'af', 'af_bella', 'af_nicole', 'af_sarah', 'af_sky', 'am_adam', 'am_michael', 'bf_emma', 'bf_isabella', 'bm_george', 'bm_lewis']

export default function ModelDetailPage({
  params,
}: {
  params: Promise<{ slug: string }>;
}) {
  const { slug }  = use(params);
  const model     = models.find((m) => m.slug === slug);

  if (!model) notFound();

  /* ────────── state for UI and "Playground" ────────── */
  const [activeTab, setActiveTab] = useState('docs'); // 'docs', 'description', 'playground'
  const [input,    setInput]   = useState('');
  const [imageUrl, setImage]   = useState('');
  const [voice,    setVoice]   = useState('af_bella');
  const [loading,  setLoading] = useState(false);
  const [response, setResp]    = useState<any>(null);
  const [blobUrl,  setBlobUrl] = useState<string | null>(null);

  /* choose endpoint + body template from the model category */
  const handleRun = async () => {
    setLoading(true);
    setResp(null);
    setBlobUrl(null);

    try {
      let endpoint = '';
      let body: any = { model: model.Name };     // default property

      switch (model.Category) {
        case 'embeddings':
          endpoint      = '/api/v1/embeddings';
          body.input    = input.includes('\n')
            ? input.split('\n').filter(Boolean)
            : input;
          break;

        case 'image':
          endpoint      = '/api/v1/image';
          body          = { prompt: input, width: 512, height: 512 };
          break;

        case 'video':
          endpoint      = '/api/v1/video';
          body          = { prompt: input, size: '832*480' };
          break;

        case 'audio':
          endpoint      = '/api/v1/tts';
          body          = { text: input, voice };
          break;

        case 'vision': // falls through to chat/completions but can send image-url, too
        case 'text':
        case 'code':
        case 'math':
        default:
          endpoint      = '/api/v1/chat/completions';
          body          = {
            model: model.Name,
            stream: false,
            messages: [
              { role: 'system', content: 'You are a helpful assistant.' },
              {
                role   : 'user',
                content: imageUrl
                  ? [
                      { type: 'text',      text: input },
                      { type: 'image_url', image_url: { url: imageUrl } },
                    ]
                  : input,
              },
            ],
          };
      }

      const res = await fetch(`${BASE_URL}${endpoint}`, {
        method : 'POST',
        headers: {
          'Content-Type' : 'application/json',
          // ⭐️ DEV ONLY: fake creds so the call doesn't error out immediately
          'Authorization': 'Bearer debug-key',
          'X-User-Id'    : 'debug-playground',
        },
        body: JSON.stringify(body),
      });

      if (!res.ok) {
        const errText = await res.text();
        throw new Error(`${res.status} – ${errText}`);
      }

      // binary streams (image / audio / video) → blob URL
      if (['image', 'video', 'audio'].includes(model.Category)) {
        const blob   = await res.blob();
        const url    = URL.createObjectURL(blob);
        setBlobUrl(url);
        setResp(null);
      } else {
        const json   = await res.json();
        setResp(json);
      }
    } catch (e: any) {
      setResp({ error: e.message });
    } finally {
      setLoading(false);
    }
  };

  /* ─────────────────────────────── render ─────────────────────────────── */
  return (
    <div className={styles.container}>
      {/* ───────────── HEADER ───────────── */}
      <div className={styles.backgroundPattern}></div>
      <header className={styles.mainheader}>
        <div className={styles.logo} onClick={() => (window.location.href = '/')}>
          <Image src="/images/1.png" alt="cxmpute logo" height={70} width={70} />
          <h1>CXMPUTE</h1>
        </div>

        <nav className={styles.menu}>
          <ul>
            <li>
              <Link href="/models">
                <Button text="ALL MODELS" backgroundColor={cxmputeOrange} />
              </Link>
            </li>
            <li>
              <a href="/docs">
                <Button text="DOCUMENTATION" backgroundColor={cxmputePurple} />
              </a>
            </li>
            <li>
              <a href="/dashboard">
                <Button text="DASHBOARD" backgroundColor= "var(--cxmpute-slate)" />
              </a>
            </li>
            <li>
              <a href="/download">
                <Button text="BECOME A PROVIDER" backgroundColor= "var(--cxmpute-yellow)" />
              </a>
            </li>
          </ul>
        </nav>
      </header>

      <div className={styles.grid}>
        {/* ───────────── MODEL CARD ───────────── */}
        <section className={styles.hero}>
          <h1 className={styles.title}>{model.Name}</h1>

          <div className={styles.meta}>
            <div className={styles.metaItem}><span>Category:</span> {model.Category}</div>
            <div className={styles.metaItem}>
              <span>Creator:</span>{' '}
              <a href={model.creatorUrl} target="_blank" rel="noopener noreferrer" className={styles.creatorLink}>
                {model.Creator}
              </a>
            </div>

            {model.contextSize && (
              <div className={styles.metaItem}>
                <span>Context size:</span> {model.contextSize}
              </div>
            )}
            {model.vectorSize && (
              <div className={styles.metaItem}>
                <span>Vector dim:</span> {model.vectorSize}
              </div>
            )}
            {model.outputLength && !model.vectorSize && (
              <div className={styles.metaItem}>
                <span>Output length:</span> {model.outputLength}
              </div>
            )}
          </div>

          {/* Tags */}
          <div className={styles.tags}>
            <span className={styles.categoryTag}>{model.Category}</span>
            {model.InputModalities.map((m, idx) => (
              <span key={`in-${idx}`} className={styles.inputTag}>{m}</span>
            ))}
            {model.OutputModalities.map((m, idx) => (
              <span key={`out-${idx}`} className={styles.outputTag}>{m}</span>
            ))}
          </div>
        </section>

        {/* ───────────── CONTENT CARD WITH TABS ───────────── */}
        <section className={styles.contentCard}>
          {/* Tab Navigation */}
          <div className={styles.tabBar}>
            <div onClick={() => setActiveTab('docs')}>
              <Button 
                text="DOCUMENTATION" 
                backgroundColor={activeTab === 'docs' ? cxmputeGreen : "var(--cxmpute-slate)"} 
              />
            </div>
            <div onClick={() => setActiveTab('description')}>
              <Button 
                text="DESCRIPTION" 
                backgroundColor={activeTab === 'description' ? cxmputeGreen :  "var(--cxmpute-slate)"}
              />
            </div>
            <div onClick={() => setActiveTab('playground')}>
              <Button 
                text="TRY IT" 
                backgroundColor={activeTab === 'playground' ? cxmputeGreen :  "var(--cxmpute-slate)"}
              />
            </div>
          </div>

          {/* Tab Content */}
          <div className={styles.tabContent}>
            {/* Documentation Tab */}
            {activeTab === 'docs' && (
              <div className={styles.markdown}>
                <ReactMarkdown>{model.docs}</ReactMarkdown>
              </div>
            )}

            {/* Description Tab */}
            {activeTab === 'description' && (
              <div className={styles.markdown}>
                <ReactMarkdown>{model.description}</ReactMarkdown>
                
                {model.blogUrl && (
                  <a href={model.blogUrl} target="_blank" rel="noopener noreferrer" className={styles.blogLink}>
                    Read the full blog&nbsp;post →
                  </a>
                )}
              </div>
            )}

            {/* Playground Tab */}
            {activeTab === 'playground' && (
              <div className={styles.playgroundContainer}>
                {/* input controls depend on the category */}
                {model.Category === 'embeddings' && (
                  <>
                    <textarea
                      className={styles.textarea}
                      placeholder="Enter one or more lines of text…"
                      value={input}
                      onChange={(e) => setInput(e.target.value)}
                    />
                    <p className={styles.small}>Tip: multiple lines → multiple embeddings.</p>
                  </>
                )}

                {['text', 'code', 'math', 'vision'].includes(model.Category) && (
                  <>
                    <textarea
                      className={styles.textarea}
                      placeholder="Ask something…"
                      value={input}
                      onChange={(e) => setInput(e.target.value)}
                    />
                    {model.Category === 'vision' && (
                      <input
                        className={styles.input}
                        type="text"
                        placeholder="Optional image URL"
                        value={imageUrl}
                        onChange={(e) => setImage(e.target.value)}
                      />
                    )}
                  </>
                )}

                {model.Category === 'image' && (
                  <input
                    className={styles.input}
                    type="text"
                    placeholder="Enter prompt…"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                  />
                )}

                {model.Category === 'video' && (
                  <input
                    className={styles.input}
                    type="text"
                    placeholder="Enter prompt…"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                  />
                )}

                {model.Category === 'audio' && (
                  <>
                    <input
                      className={styles.input}
                      type="text"
                      placeholder="Enter text to speak…"
                      value={input}
                      onChange={(e) => setInput(e.target.value)}
                    />

                    {/* voice selector */}
                    <select
                      className={styles.select}
                      value={voice}
                      onChange={(e) => setVoice(e.target.value)}
                    >
                      {voiceOptions.map((v) => (
                        <option key={v} value={v}>
                          {v}
                        </option>
                      ))}
                    </select>
                  </>
                )}

                <div className={styles.runButtonContainer}>
                  <Button
                    text={loading ? 'Running…' : 'Run'}
                    backgroundColor={cxmputeGreen}
                    disabled={loading || !input.trim()}
                    onClick={handleRun}
                  />
                </div>

                {/* Results Section */}
                {(blobUrl !== null || response) && (
                  <div className={styles.resultsSection}>
                    {blobUrl !== null && (
                      <>
                        {['image', 'video'].includes(model.Category) && <h3>Generated Media</h3>}
                        {model.Category === 'audio' && <h3>Generated Audio</h3>}
                        {['image', 'video'].includes(model.Category) && (
                          <video
                            src={blobUrl}
                            controls
                            width={512}
                            className={styles.video}
                            onLoadedMetadata={() => {
                              const video = document.querySelector('video');
                              if (video) {
                                video.currentTime = 0;
                                video.play();
                              }
                            }}
                          />
                        )}
                      </>
                    )}

                    {blobUrl && model.Category === 'audio' && (
                      <audio src={blobUrl} controls className={styles.audio} />
                    )}

                    {response && (
                      <pre className={styles.pre}>{JSON.stringify(response, null, 2)}</pre>
                    )}
                  </div>
                )}
              </div>
            )}
          </div>
        </section>
      </div>
    </div>
  );
}

### File: src/app/page.module.css
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;



  min-height: 100svh;
  font-family: var(--font-roboto);
  background-color: #f9f5f2;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {

}

@media (max-width: 600px) {
  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

.header{
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 32px;
}

.logo{
  display: flex;
  align-items: center;
}

.menu ul{
  display: flex;
  gap: 24px;
  list-style: none;
}

.header h1{
  font-size: 20px;
}

.hero{
  display: flex;
  width: 100%;
  justify-content: center;
  align-items: center;
  padding: 32px;
}

.heroLeft{
  width: 50%;
}

.heroLeft h1{
  font-size: 56px;
}

.heroLeft h3{
  margin-bottom: 8px;
}

.heroLeft p{
  margin-top: 20px;
  margin-bottom: 20px;
  /* max-width: 80%; */
}

.heroRight{
  position: relative;
  width: 500px;
  height: 500px;
}

.heroButtons{
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
}

.whoIsCxmputeFor{
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
}

.whoIsCxmputeForCards{
  display: flex;
  gap: 24px;
  padding: 32px;
  padding-top: 0;
  width: 100%;
  flex-wrap: wrap;
  justify-content: center;
}

.whoIsCxmputeForCardImage{
  width: 100px;
  height: 100px;
  position: relative;
  border: 6px solid #000;
  border-radius: 10px;
  margin-bottom: 24px;
}

.imageWrapper{
  margin: 5px;
  position: relative;
  height: 80px;
  width: 80px;
}


.imageWrapper2{
  margin: 20px;
  position: relative;
  height: 300px;
  width: 300px;
}


.whoIsCxmputeForCard {
  width: 300px;
  padding: 20px;
  background: #fff;
  border: 6px solid #000;
  box-shadow: 12px 12px 0 #000;
  transition: transform 0.3s, box-shadow 0.3s;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.whoIsCxmputeForCard:hover {
  transform: translate(-5px, -5px);
  box-shadow: 17px 17px 0 #000;
}

.whoIsCxmputeForCard__title {
  font-size: 32px;
  font-weight: 900;
  color: #000;
  /* text-transform: uppercase; */
  margin-bottom: 15px;
  display: block;
  position: relative;
  overflow: hidden;
}

.whoIsCxmputeForCard__title::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: 0;
  width: 90%;
  height: 3px;
  background-color: #000;
  transform: translateX(-100%);
  transition: transform 0.3s;
}

.whoIsCxmputeForCard:hover .whoIsCxmputeForCard__title::after {
  transform: translateX(0);
}

.whoIsCxmputeForCard__content {
  font-size: 16px;
  line-height: 1.4;
  color: #000;
  margin-bottom: 20px;
}

.whoIsCxmputeForCard__form {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.whoIsCxmputeForCard__form input {
  padding: 10px;
  border: 3px solid #000;
  font-size: 16px;
  font-family: inherit;
  transition: transform 0.3s;
  width: calc(100% - 26px); /* Adjust for padding and border */
}

.whoIsCxmputeForCard__form input:focus {
  outline: none;
  transform: scale(1.05);
  background-color: #000;
  color: #ffffff;
}

.whoIsCxmputeForCard__button {
  border: 3px solid #000;
  background: #000;
  color: #fff;
  padding: 10px;
  font-size: 16px;
  left: 20%;
  font-weight: bold;
  text-transform: uppercase;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: transform 0.3s;
  width: 50%;
  height: auto;
}

.whoIsCxmputeForCard__button::before {
  content: "SELECT";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 105%;
  background-color: var(--select-bg-color, #20a191);
  color: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  transform: translateY(100%);
  transition: transform 0.3s;
}

.whoIsCxmputeForCard__button:hover::before {
  transform: translateY(0);
}

.whoIsCxmputeForCard__button:active {
  transform: scale(0.95);
}

@keyframes glitch {
  0% {
    transform: translate(2px, 2px);
  }
  25% {
    transform: translate(-2px, -2px);
  }
  50% {
    transform: translate(-2px, 2px);
  }
  75% {
    transform: translate(2px, -2px);
  }
  100% {
    transform: translate(2px, 2px);
  }
}

.glitch {
  animation: glitch 0.3s infinite;
}

.identitySpecific{
  width: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  /* min-height: 10vh; */
  height: auto;
  padding: 16px 32px;
}

/* .specificIdentity{
  width: 100%;
  display: flex;
} */

.ISLeft{
  width: 40%;
  /* color: #f8cb46; */
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.ISLeft p{
  max-width: 80%;
}

.ISLeft h1{
  font-size: 56px;
}

.ISLeft span{
  margin-top: 10px;
  font-size: 12px;
}

.ISRight{
  width: 60%;
  display: flex;
  flex-wrap: wrap;
  gap: 30px;
  justify-content: flex-end;
}

.ISBottom{
  display: flex;
  gap: 10px;
}

.idenitytSpecificContainer{
  display: flex;
  flex-direction: row;
}

.idenitytSpecificInput__container {
  position: relative;
  background: #f0f0f0;
  padding: 20px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  gap: 15px;
  border: 4px solid #000;
  max-width: 350px;
  transition: all 400ms cubic-bezier(0.23, 1, 0.32, 1);
  transform-style: preserve-3d;
  perspective: 1000px;
  box-shadow: 10px 10px 0 #000;
  border-radius: 10px;
}

/* .idenitytSpecificInput__container:hover {
  transform: rotateX(5deg) rotateY(1deg) scale(1.05);
  box-shadow: 25px 25px 0 -5px var(--specific-feature-color), 25px 25px 0 0 #000;
} */

.shadow__idenitytSpecificInput {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  left: 0;
  bottom: 0;
  z-index: -1;
  transform: translateZ(-50px);
  background: linear-gradient(
    45deg,
    rgba(255, 107, 107, 0.4) 0%,
    rgba(255, 107, 107, 0.1) 100%
  );
  filter: blur(20px);
}

.idenitytSpecificInput__button__shadow {
  cursor: pointer;
  border: 3px solid #000;
  background: var(--specific-feature-color);
  transition: all 400ms cubic-bezier(0.23, 1, 0.32, 1);
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px;
  transform: translateZ(20px);
  position: relative;
  z-index: 3;
  font-weight: bold;
  text-transform: uppercase;
  /* height: 50px;
  width: 50px; */
}

.idenitytSpecificInput__button__shadow:hover {
  background: var(--specific-feature-color);
  transform: translateZ(10px) translateX(-5px) translateY(-5px);
  box-shadow: 5px 5px 0 0 #000;
}

.idenitytSpecificInput__button__shadow svg {
  fill: #000;
  width: 25px;
  height: 25px;
}

.idenitytSpecificInput__search {
  width: 100%;
  outline: none;
  border: 3px solid #000;
  padding: 15px;
  font-size: 18px;
  background: #fff;
  color: #000;
  transform: translateZ(10px);
  transition: all 400ms cubic-bezier(0.23, 1, 0.32, 1);
  position: relative;
  z-index: 3;
  font-family: "Roboto", Arial, sans-serif;
  letter-spacing: -0.5px;
  
}

.idenitytSpecificInput__search::placeholder {
  color: #666;
  font-weight: bold;
  text-transform: uppercase;
}

.idenitytSpecificInput__search:hover,
.idenitytSpecificInput__search:focus {
  background: #f0f0f0;
  transform: translateZ(20px) translateX(-5px) translateY(-5px);
  box-shadow: 5px 5px 0 0 #000;
}

.idenitytSpecificInput__container::before {
  content: var(--specific-feature, "FEATURE");
  position: absolute;
  top: -15px;
  left: 20px;
  background: var(--specific-feature-color);
  color: #000;
  font-weight: bold;
  padding: 5px 10px;
  font-size: 14px;
  transform: translateZ(25px);
  z-index: 4;
  border: 2px solid #000;
  
}

/* .ISRight .idenitytSpecificInput__container{
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
} */
.idenitytSpecificInput__container h1{
  font-weight: 600;
}

.protected{
  width: 100%;
  display: flex;
  justify-content: center;
  padding: 54px;
}

.protectedContainer{
  width: 100%;
  display: flex; 
  align-items: center;
  justify-content: center;
  gap: 20px;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 32px;
  max-width: 1300px;
  background-color: #d4d4cb;
  border: 6px solid #000;
  border-radius: 20px;
  box-shadow: 12px 12px 0 #000;

}

.protectedImageContainer{
  width: 50%;
  height: auto;
  background-color: #20a191;
  border: 6px solid #000;
  border-radius: 20px;
}

.protectedTextContainer h1{
  font-size: 56px;
  margin-bottom: 20px;
}

.testimonials{
  width: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 54px;
}

.testimonials h2{
  /* font-size: 56px; */
  margin-bottom: 20px;
  width: 100%;
  text-align: center;
  font-size: 48px;
}

.testimonialsContainer {
  width: 100%;
  display: flex; 
  gap: 20px;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 32px;
  max-width: 1300px;
  border-radius: 20px;
  overflow-x: auto;
  scroll-snap-type: x mandatory;
  -webkit-overflow-scrolling: touch;
}

.testimonial {
  background-color: var(--testimonial-color);
  border: 6px solid #000;
  padding: 48px;
  min-width: 300px; /* Ensures each card has a base width */
  max-width: 800px;
  font-size: 20px;
  flex-shrink: 0;
  scroll-snap-align: start;
  border-radius: 10px;
  box-shadow: 12px 12px 0 #000;
  transition: transform 0.3s, box-shadow 0.3s;
}

.testimonial:hover {
  transform: translate(-5px, -5px);
  box-shadow: 17px 17px 0 #000;
}


.architecture{
  width: 100%;
  padding: 54px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.architectureContainer{
  width: 100%;
  display: flex; 
  gap: 20px;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 32px;
  max-width: 1300px;
  border-radius: 20px;
  /* background-color: #d64989;
  border: 6px solid #000;
  box-shadow: 12px 12px 0 #000; */
}

.ALeft, .ARight{
  width: 50%;
  height: auto;
}

.ALeft h1{
  font-size: 56px;
}

.architectureLayer{
  border: 6px solid #000;
  background-color: var(--architecture-layer-color);
  margin-bottom: 20px;
  border-radius: 10px;
  box-shadow: 6px 6px 0 #000;
  transition: transform 0.3s, box-shadow 0.3s;
  padding: 20px;
}

.architectureLayer:hover {
  transform: translate(-2.5px, -2.5px);
  box-shadow: 10px 10px 0 #000;
}

.token{
  width: 100%;
  padding: 54px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.tokenContainer{
  width: 100%;
  display: flex; 
  align-items: center;
  gap: 20px;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 32px;
  max-width: 1300px;
  border-radius: 20px;
  background-color: #d64989;
  border: 6px solid #000;
  box-shadow: 12px 12px 0 #000;
}


.cxptToken{
  height: 500px;
  width: 500px;
  border: 6px solid #000;
  border-radius: 50%;
  box-shadow: 12px 12px 0 #000;
  position: relative;
  transition: transform 0.3s, box-shadow 0.3s;
}

.cxptToken:hover {
  transform: translate(-5px, -5px);
  box-shadow: 17px 17px 0 #000;
}

.blog{
  width: 100%;
  padding: 54px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.blogContainer{
  width: 100%;

  gap: 20px;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 32px;
  max-width: 1400px;
}

.blogCards{
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  justify-content: center;
}

.blogCard{
  background-color: var(--blog-card-color);
  border: 6px solid #000;
  padding: 24px;
  min-width: 280px; /* Ensures each card has a base width */
  max-width: 300px;
  font-size: 20px;
  flex-shrink: 0;
  border-radius: 10px;
  box-shadow: 12px 12px 0 #000;
  transition: transform 0.3s, box-shadow 0.3s;

}

.blogCard h1{
  font-size: 32px;
}

.blogCard p{
  font-size: 18px;
  margin-top: 10px;
  margin-bottom: 10px;
}

.blogCard:hover {
  transform: translate(-5px, -5px);
  box-shadow: 17px 17px 0 #000;
}

.blogTitle{
  background-color: #20a191;
  width: max-content;
  padding: 10px;
  border-radius: 10px;
  border : 6px solid #000;
  box-shadow: 6px 6px 0 #000;
  transition: transform 0.3s, box-shadow 0.3s;
  margin-bottom: 24px;
}

.blogTitle:hover {
  transform: translate(-2.5px, -2.5px);
  box-shadow: 10px 10px 0 #000;
}

.blogCardImage{
  width: 200px;
  height: 200px;
  margin-bottom: 20px;
  border-radius: 10px;
  position: relative;
}

.faq{
  width: 100%;
  padding: 54px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.faqContainer{
  width: 100%;
  gap: 20px;
  margin-top: 20px;
  margin-bottom: 20px;
  padding: 32px;
  max-width: 800px;
}

.faqCardHeader{
  display: flex;
  justify-content: space-between;
}

.mapt{
  width: 100%;
  padding: 54px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding-top: 0;
}

.mapContainer{
  width: 100%;
  gap: 20px;
  margin-top: 20px;
  margin-bottom: 20px;
  max-width: 2000px;
  position: relative;
}

.mapTextOverlay{
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  /* color: #fff; */
}

.mapTextOverlay h1{
  /* font-size: 32px; */
  margin-bottom: 20px;
  text-align: center;
}

.mapOverlayImage{
  position: relative;
  height: 100px;
  width: 100px;
}

.footer{
  width: 100%;
  padding: 54px;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding-bottom: 0%;
}


.footerContainer{
  width: 100%;
  gap: 20px;
  margin-top: 20px;
  padding: 32px;
  max-width: 1300px;
  display: flex;
  background-color: #20a191;
  height: 40vh;
  border-radius: 20px 20px 0 0;
  border: 6px solid #000;
  border-bottom: none;
  justify-content: space-between;
}

.footerSocialLinks{
  display: flex;
}

.footerSocialLink{
  background-color: #f8cb46;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-right: 10px;
  transition: transform 0.3s, box-shadow 0.3s;
  box-shadow: 4px 4px 0 #000;
  border: 2px solid #000;
  cursor: pointer;
  transition : transform 0.3s, box-shadow 0.3s;
}

.footerSocialLink:hover {
  transform: translate(-2.5px, -2.5px);
  box-shadow: 7px 7px 0 #000;
}

.footerRight{
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: flex-end;
}

.footerButtons{
  display: flex;
  gap: 20px;
}

/* 320px, 480px, 768px, 992px, 1200px */

/* 1200px breakpoint */
@media (max-width: 1200px) {
  .heroRight {
    width: 400px;
    height: 400px;
  }

  .ALeft h1 {
    font-size: 48px;
  }

  .ISLeft h1 {
    font-size: 48px;
  }
}

/* 992px breakpoint */
@media (max-width: 992px) {
  /* Hero section */
  .hero {
    flex-direction: column;
    align-items: center;
    text-align: center;
  }
  .heroLeft {
    width: 100%;
    margin-bottom: 20px;
  }
  .heroRight {
    width: 100%;
    height: 400px;
  }

  /* Architecture, token, blog layouts */
  .architectureContainer,
  .tokenContainer,
  .blogContainer,
  .footerContainer {
    flex-direction: column;
    align-items: center;
  }

  .architectureLayer,
  .blogCard,
  .cxptToken,
  .protectedContainer {
    margin: 0 auto 20px auto;
  }

  .ALeft, .ARight {
    width: 100%;
  }

  .cxptToken {
    margin: 0 auto;
  }

  /* Identity-specific containers */
  .ISLeft, .ISRight {
    width: 100%;
  }
  .ISRight {
    justify-content: center;
  }
}

/* 768px breakpoint */
@media (max-width: 768px) {
  /* Resizing text for smaller screens */
  .heroLeft h1,
  .ISLeft h1,
  .ALeft h1,
  .protectedTextContainer h1,
  .tokenContainer .ALeft h1 {
    font-size: 36px;
  }

  .heroLeft p,
  .ISLeft p,
  .protectedTextContainer p,
  .architectureLayer p,
  .blogCard p {
    font-size: 16px;
  }

  .whoIsCxmputeForCard__title {
    font-size: 24px;
  }

  /* Adjust card widths */
  .whoIsCxmputeForCard {
    width: 100%;
    margin: 0 auto;
  }

  /* Footer container layout */
  .footerContainer {
    height: auto;
  }

  .menu ul{
    display: flex;
    flex-direction: column;
  }

  .heroButtons{
    flex-direction: column;
    display: flex;
  }

  .whoIsCxmputeFor h1{
    text-align: center;
  }

  .idenitytSpecificContainer{
    flex-direction: column;
    gap: 20px;
  }

  .protectedContainer{
    flex-direction: column;
  }

  .protected{
    padding: 10px;
  }

  .protectedImageContainer{
    width: 100%;
  }

  .imageWrapper2{
    margin: 0;
  }

  .testimonial{
    width: 200px;
    padding: 10px;
  }

  .testimonials{
    padding: 10px;
  }

  .cxptToken{
    width: 200px;
    height: 200px;
  }

  .blogContainer{
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .blogTitle{
    max-width: 300px;
  }

  .token, .architecture{
    padding: 10px;
  }

  .footer{
    padding: 10px;
  }

  .footerSocialLinks{
    flex-wrap: wrap;
    margin-bottom: 20px;
  }

  .footerSocialLink{
    margin-bottom: 10px;
  }
}

/* 480px breakpoint */
@media (max-width: 480px) {
  /* Reduce padding and gap for tighter space */
  .hero,
  .whoIsCxmputeForCards,
  .testimonialsContainer,
  .architectureContainer,
  .tokenContainer,
  .blogContainer,
  .faqContainer {
    padding: 16px;
  }

  /* Make images smaller */
  .heroRight,
  .imageWrapper2,
  .cxptToken {
    width: 100%;
    height: 300px;
  }

  /* Stack or center text */
  .heroLeft h1,
  .heroLeft h3,
  .ISLeft h1,
  .ISLeft h3 {
    text-align: center;
  }

  .ISLeft p {
    margin: 0 auto;
    text-align: center;
  }

  /* Footer layout */
  .footerContainer {
    flex-direction: column;
    align-items: center;
  }
  .footerRight {
    align-items: center;
  }
  .footerButtons {
    flex-direction: column;
    gap: 10px;
  }
  .header{
    flex-direction: column;
  }

  .menu{
    display: none;
  }

  .cxptToken{
    width: 200px;
    height: 200px;
  }

  
}

/* 320px breakpoint */
@media (max-width: 320px) {
  /* Further reduce font sizes */
  .heroLeft h1,
  .ISLeft h1 {
    font-size: 28px;
  }
  .heroLeft p,
  .ISLeft p {
    font-size: 14px;
  }

  /* Narrow testimonials */
  .testimonialsContainer {
    padding: 8px;
  }
  .testimonial {
    padding: 24px;
    min-width: 250px;
    font-size: 16px;
  }

  /* Blog cards layout */
  .blogCards {
    flex-direction: column;
    align-items: center;
  }
  .blogCard {
    max-width: 280px;
  }

  /* Footer social icons */
  .footerSocialLink {
    width: 35px;
    height: 35px;
  }
}


.backgroundPattern {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: 
    radial-gradient(circle, rgba(150, 100, 255, 0.10) 2px, transparent 2px) 0 0 / 40px 40px,
    radial-gradient(circle, rgba(255, 100, 200, 0.10) 2px, transparent 2px) 20px 20px / 40px 40px;
  opacity: 0.8;
  pointer-events: none;
}

.backgroundPattern {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: 
    radial-gradient(circle, rgba(150, 100, 255, 0.10) 2px, transparent 2px) 0 0 / 40px 40px,
    radial-gradient(circle, rgba(255, 100, 200, 0.10) 2px, transparent 2px) 20px 20px / 40px 40px;
  opacity: 0.8;
  pointer-events: none;
}
### File: src/app/docs/page.module.css
.main{
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    padding: 32px;
    font-family: var(--font-roboto);
}

.docWrapper{
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 24px;
    margin-top: 20px;
    margin-bottom: 20px;
    padding: 32px;
}

.docWrapper h1{
    background-color: #91a8eb;
    border: 6px solid #000;
    border-radius: 20px;
    box-shadow: 12px 12px 0 #000;
    padding: 20px;
    transition: all 0.3s ease-in-out;
    margin-bottom: 48px;
}

/* .docWrapper h1:hover{
    transform: translate(-5px, -5px);
    box-shadow: 17px 17px 0 #000;
} */

.docWrapper h2{
    background-color: #91a8eb;
    border: 6px solid #000;
    border-radius: 10px;
    box-shadow: 6px 6px 0 #000;
    padding: 10px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

.docWrapper h2:hover{
    transform: translate(-5px, -5px);
    box-shadow: 8px 8px 0 #000;
}

.docWrapper h3{
    background-color: #fe91e8;
    border: 3px solid #000;
    border-radius: 5px;
    box-shadow: 6px 6px 0 #000;
    padding: 5px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

### File: src/app/docs/page.tsx
import Button from "@/components/button/button";
import styles from "./page.module.css";
import Link from "next/link";

export default function Docs() {
  return (
    <main className={styles.main}>
      <div className={styles.docWrapper}>
        <h1>Cxmpute Documentation</h1>
        <p>
          Hey there! Our comprehensive Cxmpute docs are coming soon. We’re busy putting together all the details you need to unlock the full potential of our platform. In the meantime, fill out our form to be the first to know when our docs go live and to get the latest updates.
        </p>
        <p>
          <a href="https://tally.so/r/w86DQY" target="_blank" rel="noopener noreferrer">
            <Button text="Notify Me!" backgroundColor="#20a191" />
          </a>
        </p>
        <Link href="/">
          <Button text="Back to Home" backgroundColor="#20a191" />
        </Link>
      </div>
    </main>
  );
}

### File: src/app/dashboard/dashboard.module.css
.container{
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  gap: 20px;
  align-items: center;
  padding: 20px;
  width: 100%;
  position: relative;
  background-color: #f9f5f2;
  overflow: hidden;
}

.backgroundPattern {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 0;
  background: 
    radial-gradient(circle, rgba(150, 100, 255, 0.10) 2px, transparent 2px) 0 0 / 40px 40px,
    radial-gradient(circle, rgba(255, 100, 200, 0.10) 2px, transparent 2px) 20px 20px / 40px 40px;
  opacity: 0.8;
  pointer-events: none;
}

.titleCard{
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  position: relative;
  z-index: 1;
}

.logo{
  display: flex;
  align-items: center;
}

.buttonLogout, .buttonLogin {
  box-shadow: 5px 5px 0px black;
  border: 2px solid black;
  box-shadow: 5px 5px 0px black;
  border-radius: 7px;
  padding: 0.3rem 0.5rem;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  background-color: var(--cxmpute-purple);
  font-weight: 700;
  font-size: 0.9rem;
  position: relative;
  z-index: 1;
}

.buttonLogout:hover, .buttonLogin:hover {
  box-shadow: 0 0 0 black;
  transform: translateY(3px) translateX(3px);
}

.icon {
  width: 24px;
  height: 24px;
  transition: all 0.3s ease-in-out;
}

.logo h1{
  font-size: 1.3rem;
}

### File: src/app/dashboard/page.tsx
// app/dashboard/page.tsx
import Dashboard from "@/components/dashboard/Dashboard";
import { auth, login, logout } from "../actions";          // adjust path if needed
import styles from "./dashboard.module.css";
import Image from "next/image";
import Link from "next/link";

export default async function DashboardPage() {
  const user = await auth();          // SSR session check

  return (
    <main className={styles.container}>
      <div className={styles.backgroundPattern} />

      <div className={styles.titleCard}>
        <Link className={styles.logo} href="/">
          <Image src="/images/1.png" alt="cxmpute logo" height={70} width={70} />
          <h1>CXMPUTE</h1>
        </Link>

        {/* ↴ Auth buttons */}
        {user ? (
          <form action={logout}>
            <button type="submit" className={styles.buttonLogout}>
              Log&nbsp;out
              <svg className={styles.icon} viewBox="0 0 24 24" fill="currentColor">
                <path
                  fillRule="evenodd"
                  d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm4.28 10.28a.75.75 0 000-1.06l-3-3a.75.75 0 10-1.06 1.06l1.72 1.72H8.25a.75.75 0 000 1.5h5.69l-1.72 1.72a.75.75 0 101.06 1.06l3-3z"
                  clipRule="evenodd"
                />
              </svg>
            </button>
          </form>
        ) : (
          <form action={login}>
            <button type="submit" className={styles.buttonLogin}>
              Log&nbsp;in
              <svg className={styles.icon} viewBox="0 0 24 24" fill="currentColor">
                <path
                  fillRule="evenodd"
                  d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm4.28 10.28a.75.75 0 000-1.06l-3-3a.75.75 0 10-1.06 1.06l1.72 1.72H8.25a.75.75 0 000 1.5h5.69l-1.72 1.72a.75.75 0 101.06 1.06l3-3z"
                  clipRule="evenodd"
                />
              </svg>
            </button>
          </form>
        )}
      </div>

      {/* Interactive dashboard */}
      {user && <Dashboard subject={user.properties} />}
    </main>
  );
}
### File: src/app/101/101.module.css
.main{
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    padding: 32px;
    font-family: var(--font-roboto);
}

.docWrapper{
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 24px;
    margin-top: 20px;
    margin-bottom: 20px;
    padding: 32px;
}

.docWrapper h1{
    background-color: #f8cb46;
    border: 6px solid #000;
    border-radius: 20px;
    box-shadow: 12px 12px 0 #000;
    padding: 20px;
    transition: all 0.3s ease-in-out;
    margin-bottom: 48px;
}

/* .docWrapper h1:hover{
    transform: translate(-5px, -5px);
    box-shadow: 17px 17px 0 #000;
} */

.docWrapper h2{
    background-color: #91a8eb;
    border: 6px solid #000;
    border-radius: 10px;
    box-shadow: 6px 6px 0 #000;
    padding: 10px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

.docWrapper h2:hover{
    transform: translate(-5px, -5px);
    box-shadow: 8px 8px 0 #000;
}

.docWrapper h3{
    background-color: #fe91e8;
    border: 3px solid #000;
    border-radius: 5px;
    box-shadow: 6px 6px 0 #000;
    padding: 5px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

### File: src/app/101/page.tsx
import Button from "@/components/button/button";
import styles from "./101.module.css";
import Link from "next/link";

export default function Home() {
    return (
        <main className={styles.main}>
            <div className={styles.docWrapper}>
                <h1>Cxmpute 101: What is Cxmpute?</h1>
                <p>Before we dive into Cxmpute 101, let’s start with an analogy to understand idle compute power. Imagine your computer as a power plant with extra capacity sitting idle most of the time. Cxmpute is like a digital power grid that taps into that unused energy and turns it into valuable compute power for everyone. And don’t worry—your personal data stays secure while your machine contributes to a global network.</p>
                <h2>What Is Cxmpute?</h2>
                <em>Cxmpute rewards you for sharing your idle compute resources.</em>
                <p>At Cxmpute, our mission is to create a network where everyone wins. Whether you need powerful compute resources or have idle cycles to spare, Cxmpute makes it simple for you to participate. Turn your underused computer into a revenue-generating asset while developers and enterprises gain access to scalable, cost-effective compute power.</p>
                <p>Getting started is easy—a few clicks, and your device joins a secure, decentralized network. You remain in full control, choosing exactly when to share your resources without any impact on your personal data or system performance.</p>
                <h2>How does it work?</h2>
                <p>Cxmpute connects those who need extra compute power with providers who have it. When a developer, company, or researcher requires additional processing capacity, the network automatically matches their request with available resources. This seamless system powers a range of applications, from AI model inference and data analysis to serverless computing.</p>
                <p>Cxmpute offers several key services:</p>
                <ul>
                    <li><strong>Virtual Machines:</strong> Rent customizable VMs optimized for CPU, GPU, memory, and storage.</li>
                    <li><strong>Serverless Compute:</strong> A decentralized alternative to traditional cloud functions.</li>
                    <li><strong>Decentralized AI Inference:</strong> Run AI models efficiently using distributed compute power.</li>
                    <li><strong>Distributed Machine Learning:</strong> Scale machine learning workloads across a global network.</li>
                    <li><strong>Agxnt - AI Agents-as-a-Service:</strong> Access modular AI agents to automate tasks and boost productivity.</li>
                </ul>
                <h2>Why Is Cxmpute a Game-Changer?</h2>
                <h3>For Providers</h3>
                <p>Earn rewards by monetizing your idle compute cycles. Whether you’re an individual or run a professional data center, you decide when and how to participate, and you’re directly compensated for your contributions.</p>
                <h3>For Users</h3>
                <p>Access powerful, flexible computing resources without being tied to a centralized cloud provider. Enjoy cost-effective, scalable solutions that empower innovation and democratize access to high-performance compute power.</p>
                <h2>Why Didn’t a Solution Like Cxmpute Exist Sooner?</h2>
                <p>Two reasons: technology and vision. Traditional systems rely on massive centralized data centers, leaving little room for individual participation. With advances in decentralized protocols and blockchain, Cxmpute is ushering in a new era—one that puts control and rewards directly into the hands of everyday users.</p>
                <p>By harnessing the untapped potential of idle compute power, Cxmpute is reshaping the computing economy. The benefits generated by sharing your resources are returned directly to you, fostering a more equitable and innovative future.</p>
                <Link href='/'>
                    <Button text="Back to Home" backgroundColor={'#20a191'} />
                </Link>
            </div>
        </main>
    );
}
### File: src/app/actions.ts
"use server"

import { redirect } from "next/navigation"
import { headers as getHeaders, cookies as getCookies } from "next/headers"
import { subjects } from "../../auth/subjects"
import { client, setTokens } from "./auth"

export async function auth() {
  const cookies = await getCookies()
  const accessToken = cookies.get("access_token")
  const refreshToken = cookies.get("refresh_token")

  if (!accessToken) {
    return false
  }

  const verified = await client.verify(subjects, accessToken.value, {
    refresh: refreshToken?.value,
  })

  if (verified.err) {
    return false
  }
  if (verified.tokens) {
    await setTokens(verified.tokens.access, verified.tokens.refresh)
  }

  return verified.subject
}

export async function login() {
  const cookies = await getCookies()
  const accessToken = cookies.get("access_token")
  const refreshToken = cookies.get("refresh_token")

  if (accessToken) {
    const verified = await client.verify(subjects, accessToken.value, {
      refresh: refreshToken?.value,
    })
    if (!verified.err && verified.tokens) {
      await setTokens(verified.tokens.access, verified.tokens.refresh)
      redirect("/")
    }
  }

  const headers = await getHeaders()
  const host = headers.get("host")
  const protocol = host?.includes("localhost") ? "http" : "https"
  const { url } = await client.authorize(`${protocol}://${host}/api/callback`, "code")
  redirect(url)
}

export async function logout() {
  const cookies = await getCookies()
  cookies.delete("access_token")
  cookies.delete("refresh_token")

  redirect("/")
}
### File: src/app/download/page.module.css
.main{
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    padding: 32px;
    font-family: var(--font-roboto);
}

.docWrapper{
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 24px;
    margin-top: 20px;
    margin-bottom: 20px;
    padding: 32px;
}

.docWrapper h1{
    background-color: #f8cb46;
    border: 6px solid #000;
    border-radius: 20px;
    box-shadow: 12px 12px 0 #000;
    padding: 20px;
    transition: all 0.3s ease-in-out;
    margin-bottom: 48px;
}

/* .docWrapper h1:hover{
    transform: translate(-5px, -5px);
    box-shadow: 17px 17px 0 #000;
} */

.docWrapper h2{
    background-color: #91a8eb;
    border: 6px solid #000;
    border-radius: 10px;
    box-shadow: 6px 6px 0 #000;
    padding: 10px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

.docWrapper h2:hover{
    transform: translate(-5px, -5px);
    box-shadow: 8px 8px 0 #000;
}

.docWrapper h3{
    background-color: #fe91e8;
    border: 3px solid #000;
    border-radius: 5px;
    box-shadow: 6px 6px 0 #000;
    padding: 5px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

### File: src/app/download/page.tsx
import Button from "@/components/button/button";
import styles from "./page.module.css";
import Link from "next/link";

export default function Download() {
  return (
    <main className={styles.main}>
      <div className={styles.docWrapper}>
        <h1>Download Cxmpute</h1>
        <p>
          Hey there! The Cxmpute provider app is in the works and will be available soon. In the meantime, sign up to get the download link and receive the latest, most exciting updates as soon as we go live. We can’t wait to welcome you to the Cxmpute family!
        </p>
        <p>
          <a href="https://tally.so/r/w86DQY" target="_blank" rel="noopener noreferrer">
            <Button text="Keep Me in the Loop" backgroundColor="#20a191" />
          </a>
        </p>
        <Link href="/">
          <Button text="Back to Home" backgroundColor="#20a191" />
        </Link>
      </div>
    </main>
  );
}

### File: src/app/layout.tsx
import type { Metadata } from "next";
import { Geist, Geist_Mono, Roboto_Mono, Roboto } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

const robotoMono = Roboto_Mono({
  variable: "--font-roboto-mono",
  subsets: ["latin"],
});

const roboto = Roboto({
  variable: "--font-roboto",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Cxmpute - The World Datacenter",
  description: "Redefining the utility of idle hardware.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} ${robotoMono.variable} ${roboto.variable}`}>
        {children}
      </body>
    </html>
  );
}

### File: src/app/c3d/threejs/threejs.module.css
.tt3d{
    width: 100%;
    height: 100vh;
}

.tt3d *::-webkit-scrollbar {
    display: none;
}

.inputContainer{
    position: absolute;
    bottom: 50px;
    left: 0;
    right: 0;
    margin-left: auto;
    margin-right: auto;
    width: 100%;
    max-width: 700px;
    /* background-color: #f9f5f2; */
    background-color: #ffffff;
    z-index: 9999;
    padding: 20px;
    border: 2px solid black;
    box-shadow: 5px 5px 0px black;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 20px;
}

.input{
    width: 100%;
    height: 50px;
    padding: 10px;
    border-radius: 12px;
    border: 2px solid black;
    /* box-shadow: 2px 2px 0px black; */
    background-color: #fff;
    /* color: #ffffff; */
}

.inputFooter{
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

.leftButtons button{
    background-color: var(--cxmpute-green);
    border: none;
    outline: none;
    /* color: #ffffff; */
    border: 2px solid black;
    box-shadow: 3px 3px 0px black;
    padding: 5px 10px;
    border-radius: 12px;
    cursor: pointer;
    color: #000;
    margin-right: 10px;
    transition: all 0.3s ease;

}


.leftButtons button:hover{
    box-shadow: 0 0 0 black;
    transform: translateY(3px) translateX(3px);
}
.rightButtons{
    display: flex;
    gap: 10px;
}

.toggleButton{
    background-color: var(--cxmpute-purple) !important;
}
### File: src/app/c3d/threejs/page.tsx
/* ---------------------------------------------------------
 *  src/app/c3d/threejs/page.tsx
 * --------------------------------------------------------*/
"use client";

import {
  SandpackProvider,
  SandpackLayout,
  SandpackPreview,
  SandpackCodeEditor,
  useSandpack,
  type SandpackPreviewRef
} from "@codesandbox/sandpack-react";
import { useRef, useState, useCallback, useEffect } from "react";
import styles from "./threejs.module.css";
import { Undo2, Redo2, Code2 } from "lucide-react";
import Button from "@/components/button/button";

const DEFAULT_CODE = `export default function App(): JSX.Element {
  return (
    <div className="flex flex-col justify-center items-center h-[100vh] bg-[#f9f5f2]">
      <div className="max-w-[800px] flex flex-col gap-3 p-2">
        <img src="https://i.postimg.cc/4yPxCKr9/dolphinhero.png" width="200" />
        <h1 className="text-[60px] font-bold">Text to 3D (threejs)</h1>
        <p className="text-slate-800 text-lg">Generate 3D react components from prompts.</p>
        <h2 className="text-slate-800">Made with ❤️ by C3D</h2>
        <p className="text-slate-600">
          C3D is a research initiative by{" "}
          <a href="https://cxmpute.cloud/" target="_blank" className="text-rose-600">
            cxmpute.cloud
          </a>{" "}
          that aims to bridge text and 3D creation through AI research, providing open tooling, infrastructure, benchmarks, and model finetunes to make sophisticated 3D generation accessible to everyone.
        </p>

        <a
          href="https://cxmpute.cloud/"
          target="_blank"
          className="
            text-[0.9rem]
            w-fit
            border-2 border-black rounded-[7px]
            px-[0.5rem] py-[0.3rem]
            bg-[#91a8eb]
            shadow-[5px_5px_0px_black]
            flex items-center justify-center gap-2
            font-bold text-center cursor-pointer
            transition-all duration-300 ease-in-out
            hover:shadow-[0_0_0_black]
            hover:translate-x-[3px] hover:translate-y-[3px]
          "
        >
          Learn more about cxmpute.cloud
        </a>
      </div>
    </div>
  );
}`

export default function ThreeJSPage() {
  /** This ref is shared with the SandpackPreview so we can screenshot. */
  const previewRef = useRef<SandpackPreviewRef | null>(null);

  /* ------------------------------------------------------------------
   *  Inner component – lives INSIDE <SandpackProvider>
   * ----------------------------------------------------------------*/
  const Playground = () => {
    const { sandpack, listen } = useSandpack();
    const [prompt, setPrompt] = useState("");
    const [busy, setBusy] = useState(false);
    const [isHovering, setIsHovering] = useState(false);
    const abortControllerRef = useRef<AbortController | null>(null);
    const [codeVisisble, setCodeVisible] = useState(true);

    // Clean up any lingering abort controllers on unmount
    useEffect(() => {
      return () => {
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
        }
      };
    }, []);

    /** Capture the iframe content */
    const captureIframeContent = async (): Promise<string> => {
      if (!previewRef.current) return "";
      
      try {
        const client = await previewRef.current.getClient();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const iframe = (client as any).iframe as HTMLIFrameElement | undefined;
        
        if (!iframe || !iframe.contentWindow) return "";
        
        // Use the iframe's document to create a canvas
        return new Promise((resolve) => {
          // Create a message channel for secure communication with the iframe
          const channel = new MessageChannel();
          
          // Set up the listener for the response
          channel.port1.onmessage = (event) => {
            resolve(event.data || "");
            channel.port1.close();
          };
          
          // Inject a script into the iframe that will capture the content
          const script = iframe.contentDocument?.createElement('script');
          if (script) {
            script.textContent = `
              // Define a function to capture the screen
              function captureScreen() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const width = document.documentElement.clientWidth || window.innerWidth;
                const height = document.documentElement.clientHeight || window.innerHeight;
                
                canvas.width = width;
                canvas.height = height;
                
                // Draw the current view to the canvas
                ctx.drawImage(document, 0, 0, width, height);
                
                // Return the data URL
                return canvas.toDataURL('image/png').split(',')[1];
              }
              
              // Send the captured image back via the message channel
              window.onmessage = function(event) {
                if (event.data === 'capture') {
                  try {
                    const imageData = captureScreen();
                    event.ports[0].postMessage(imageData);
                  } catch (e) {
                    event.ports[0].postMessage('');
                  }
                }
              };
            `;
            iframe.contentDocument?.head.appendChild(script);
            
            // Request the screenshot
            iframe.contentWindow?.postMessage('capture', '*', [channel.port2]);
          } else {
            resolve("");
          }
        });
      } catch (error) {
        console.error("Failed to capture iframe content:", error);
        return "";
      }
    };

    /** Main generation loop */
    const run = useCallback(async () => {
      // If already running, abort the current operation
      if (busy) {
        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
          abortControllerRef.current = null;
          setBusy(false);
          return;
        }
      }

      /** Wait for the bundler to emit a single `"done"` message. */
      const waitForDone = () =>
        new Promise<void>((resolve) => {
          const stop = listen((msg) => {
            if (msg.type === "done") {
              stop();
              resolve();
            }
          });
        });

      if (!prompt.trim()) return;
      setBusy(true);
      
      // Create a new AbortController for this operation
      abortControllerRef.current = new AbortController();
      const signal = abortControllerRef.current.signal;

      try {
        let code = "";
        for (let i = 0; i < 4; i++) {
          // Check if the operation was aborted
          if (signal.aborted) {
            throw new DOMException("Aborted", "AbortError");
          }

          if (i > 0) {
            // 1️⃣ inject candidate code and wait for rebuild
            sandpack.updateFile("/App.tsx", code);
            await waitForDone();
          }

          // 2️⃣ take screenshot (after first render)
          let screenshot = "";
          if (i > 0) {
            screenshot = await captureIframeContent();
          }

          // 3️⃣ collect compile errors
          const compileErrors = sandpack.error ? [sandpack.error.message] : [];

          // Check again if operation was aborted before making API call
          if (signal.aborted) {
            throw new DOMException("Aborted", "AbortError");
          }

          // 4️⃣ call OpenAI edge route
          const res = await fetch("/api/iterate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              prompt: `The current page code is ${DEFAULT_CODE}. The user prompt is "${prompt}".`,
              screenshotBase64: screenshot,
              compileErrors,
              iteration: i
            }),
            signal // Pass the abort signal to the fetch call
          }).then((r) => r.json() as Promise<{ code: string; finished: boolean }>);

          code = res.code;
          if (res.finished) break;
        }

        // final candidate → editor
        sandpack.updateFile("/App.tsx", code);
      } catch (err) {
        // Handle abort error gracefully
        if (err instanceof DOMException && err.name === "AbortError") {
          console.log("Operation was aborted");
        } else {
          console.error("Error during generation:", err);
        }
      } finally {
        setBusy(false);
        abortControllerRef.current = null;
      }
    }, [prompt, sandpack, listen, busy]);


    return (
      <>
        {/* Sandpack UI -------------------------------------------------- */}
        <SandpackLayout>
          <SandpackPreview
            ref={previewRef}
            style={{ height: "100vh", border: "none" }}
            // actionsChildren={
            //   <button onClick={() => setCodeVisible(!codeVisisble)} className={styles.codeButton}>
            //     Toggle Code
            //   </button>
            // }
            showRefreshButton
            showRestartButton
          />

          {codeVisisble && <SandpackCodeEditor
            style={{ height: "100vh" }}
            showLineNumbers
            showTabs
            wrapContent
          />}
        </SandpackLayout>

        {/* Prompt overlay ---------------------------------------------- */}
        <div className={styles.inputContainer}>
          <input
            className={styles.input}
            value={prompt}
            disabled={busy}
            onChange={(e) => setPrompt(e.target.value)}
            placeholder="What imagination will you make reality?"
          />

          <div className={styles.inputFooter}>
            <div className={styles.leftButtons}>
              <button
                className={styles.toggleButton}
                onClick={() => setCodeVisible(!codeVisisble)}
              >
                <Code2 size={16} />
              </button>
              <button
                className={styles.undoButton}
                onClick={() => window.history.back()}
              >
                <Undo2 size={16} />
              </button>
              <button
                className={styles.redoButton}
                onClick={() => window.history.forward()}
              >
                <Redo2 size={16} />
              </button>
              
            </div>

            <div className={styles.rightButtons}>
              <div
                className={styles.c3dbtn}
                onClick={() => window.open("/", "_blank")}
              >
                <Button text="cxmpute.cloud" backgroundColor="var(--cxmpute-purple)" />
              </div>
              <div
                className={`${styles.inputButton} ${busy ? styles.busyButton : ''}`}
                onClick={run}
                onMouseEnter={() => busy && setIsHovering(true)}
                onMouseLeave={() => setIsHovering(false)}
              >
                
                  <Button 
                    text={busy 
                      ? isHovering ? "Kill" : "Generating…" 
                      : "Submit"} 
                    backgroundColor="#20a191" 
                  />
              </div>
            </div>
          </div>
        </div>
      </>
    );
  };
  /* ---------------------------  end <Playground/> ------------------- */

  return (
    <div className={styles.tt3d}>
      <SandpackProvider
        template="react-ts"
        theme="light"
        customSetup={{
          dependencies: {
            three: "0.161.0",
            "@react-three/fiber": "latest",
            "@react-three/drei": "latest",
          }
        }}
        files={{
          "/App.tsx": DEFAULT_CODE,
          "/index.tsx": {
            code: `
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App";
createRoot(document.getElementById("root")!).render(
  <StrictMode><App /></StrictMode>
);`,
            readOnly: true,
            hidden: true
          }
        }}
        options={{
          externalResources: ["https://cdn.tailwindcss.com"]
        }}
      >
        <Playground />
      </SandpackProvider>
    </div>
  );
}
### File: src/app/api/v1/video/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/video/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectVideoProvision,
  checkVideoHealth,
  removeVideoProvision,
  updateVideoMetadata,
  updateVideoServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers":
        "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // 1) Validate user
    const authHeader = req.headers.get("authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json(
        { error: "Missing or invalid authorization header" },
        { status: 401 }
      );
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0 /* or some credits cost */);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 2) Parse body => { prompt, size, sample_shift, etc. }
    const body = await req.json();
    const {
      prompt,
      size,
      ckpt_dir,
      sample_shift,
      sample_guide_scale,
      offload_model,
      t5_cpu,
      ...options
    } = body || {};

    if (!prompt || !size) {
      return NextResponse.json(
        { error: 'Missing required fields "prompt" and "size".' },
        { status: 400 }
      );
    }

    // 3) Select a healthy "video" node from the Media table
    //    Suppose your model is "wan2.1" or "wan1.3B" – we can pass it, or just do "video" if you store that as the model
    const model = "wan2.1"; // Or body.model if you want the user to specify
    let isHealthy = false;
    let attempts = 0;
    let provision: any;
    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectVideoProvision(model); // random
        isHealthy = await checkVideoHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeVideoProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting video provision:", err);
        return NextResponse.json({ error: "No video provision available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy video provision found" }, { status: 503 });
    }

    // 4) Forward request
    const startTime = Date.now();
    const nodeResp = await fetch(`${provision.provisionEndpoint}/video`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        prompt,
        size,
        ckpt_dir,
        sample_shift,
        sample_guide_scale,
        offload_model,
        t5_cpu,
        ...options,
      }),
    });
    if (!nodeResp.ok) {
      const errorText = await nodeResp.text();
      return NextResponse.json(
        { error: `Node error: ${errorText}` },
        { status: nodeResp.status }
      );
    }

    // The node returns an MP4 as a stream
    const endTime = Date.now();
    const latency = endTime - startTime;

    // 5) Update daily usage => endpoint="/video"
    await updateVideoMetadata(latency);

    // 6) Update service usage => item["/video"] if we have a serviceTitle
    if (serviceTitle) {
      await updateVideoServiceMetadata(serviceTitle, serviceUrl);
    }

    // 7) Reward
    await rewardProvider(provision.providerId, 0.01);

    // 8) Return the MP4 in a streaming pass-through, with CORS
    return new Response(nodeResp.body, {
      status: 200,
      headers: {
        "Content-Type": "video/mp4",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err) {
    console.error("Error in /video route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/v1/embeddings/route.ts
// app/api/embeddings/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectEmbeddingsProvision,
  checkEmbeddingsHealth,
  removeEmbeddingsProvision,
  updateEmbeddingsMetadata,
  updateEmbeddingsServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // 1) Extract headers & validate
    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Missing or invalid authorization header" }, { status: 401 });
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0 /* credits needed? */);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 2) Parse body
    const body = await req.json();
    const { model, input, truncate, keep_alive, ...options } = body || {};

    if (!model || !input) {
      return NextResponse.json({ error: "Missing required parameter: model, input" }, { status: 400 });
    }

    // 3) Select a healthy embeddings node
    let isHealthy = false;
    let attempts = 0;
    let provision: any;

    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectEmbeddingsProvision(model);
        isHealthy = await checkEmbeddingsHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeEmbeddingsProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting embeddings provision:", err);
        return NextResponse.json({ error: "No embeddings provision available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy embeddings provision found" }, { status: 503 });
    }

    // 4) Forward request
    const payload = {
      model,
      input,
      ...(truncate !== undefined && { truncate }),
      ...(keep_alive !== undefined && { keep_alive }),
      ...options,
    };

    const startTime = Date.now();
    const response = await fetch(`${provision.provisionEndpoint}/embeddings`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!response.ok) {
      const errorText = await response.text();
      return NextResponse.json({ error: `Node error: ${errorText}` }, { status: response.status });
    }

    const data = await response.json();
    // data has { model, embeddings, total_duration, load_duration, prompt_eval_count }

    const endTime = Date.now();
    const latency = endTime - startTime + (data.load_duration ?? 0);
    
    // 6) Update metadata
    await updateEmbeddingsMetadata(latency);

    // 7) Update service metadata if we have a serviceTitle
    if (serviceTitle) {
      await updateEmbeddingsServiceMetadata(serviceTitle, serviceUrl);
    }

    // 8) Reward provider
    await rewardProvider(provision.providerId, 0.01);

    // 9) Return with CORS
    return new NextResponse(JSON.stringify(data), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err) {
    console.error("Error in /embeddings route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

### File: src/app/api/v1/chat/completions/route.ts
// app/api/chat/completions/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectProvision,
  checkProvisionHealth,
  removeProvision,
  updateMetadata,
  updateServiceMetadata,
  rewardProvider,
} from "@/lib/utils"; 

const CREDITS_NEEDED = 0;

export async function POST(req: NextRequest) {
  try {
    // 1) Auth
    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return NextResponse.json(
        { error: "Missing or invalid authorization header" },
        { status: 401 }
      );
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";

    // 2) Optional service metadata
    const serviceTitle = req.headers.get("X-Title");
    const serviceUrl = req.headers.get("HTTP-Referer");

    // 3) Validate API key
    const { valid, reason } = await validateApiKey(userId, apiKey, CREDITS_NEEDED);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 4) Parse body
    const body = await req.json();
    const { model, messages, stream, response_format, functions, ...options } = body;

    if (!model || !messages) {
      return NextResponse.json(
        { error: "Missing required parameter: model or messages" },
        { status: 400 }
      );
    }

    // 5) Get a healthy provision
    const startTime = Date.now();
    let provision: any;
    let isHealthy = false;
    let attempts = 0;

    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectProvision(model);
        isHealthy = await checkProvisionHealth(provision.provisionEndpoint);
        if (!isHealthy) {
          if (attempts === 2) {
            await removeProvision(provision.provisionId);
          }
          attempts++;
        }
      } catch (error) {
        console.error("Error selecting provision:", error);
        return NextResponse.json(
          { error: "No provisions available for the requested model" },
          { status: 503 }
        );
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy provisions available" }, { status: 503 });
    }

    // 6) Build payload
    const payload: any = { model, messages, ...options };
    if (response_format) {
      if (typeof response_format === "string") {
        payload.format = response_format;
      } else if (typeof response_format === "object") {
        payload.format = JSON.stringify(response_format);
      }
    }
    if (functions) {
      payload.tools = functions;
    }

    // 7) Forward the request
    if (stream) {
      // Streaming case
      const response = await fetch(`${provision.provisionEndpoint}/chat/completions`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ...payload, stream: true }),
      });
      if (!response.ok) {
        const errorText = await response.text();
        return NextResponse.json({ error: `Node returned error: ${errorText}` }, { status: response.status });
      }

      let finalChunk: any = null;
      let latency = 0;

      const transformStream = new TransformStream({
        transform(chunk, controller) {
          controller.enqueue(chunk);

          const text = new TextDecoder().decode(chunk);
          const lines = text.split("\n");
          for (const line of lines) {
            if (latency === 0) {
              const currentTime = Date.now();
              latency = currentTime - startTime;
            }
            if (line.startsWith("data:")) {
              const jsonStr = line.replace("data: ", "").trim();
              if (jsonStr) {
                try {
                  const parsed = JSON.parse(jsonStr);
                  finalChunk = parsed; // update with the latest SSE chunk
                } catch {
                  // ignore
                }
              }
            }
          }
        },
        async flush() {
          let inputTokens = 0;
          let outputTokens = 0;
          let timeTaken = 0;
          if (finalChunk) {
            if (typeof finalChunk.eval_count === "number") {
              outputTokens = finalChunk.eval_count;
              timeTaken += finalChunk.eval_duration;
            }
            if (typeof finalChunk.prompt_eval_count === "number") {
              inputTokens = finalChunk.prompt_eval_count;
              timeTaken += finalChunk.prompt_eval_duration;
            }
            latency += finalChunk.load_duration;
          }

          const tps = (inputTokens + outputTokens) / timeTaken;
          await updateMetadata(model, model, inputTokens, outputTokens, latency, tps);

          if (serviceTitle && serviceUrl) {
            await updateServiceMetadata(
              serviceTitle,
              serviceUrl,
              "/chat/completions",
              model,
              inputTokens,
              outputTokens
            );
          }
          await rewardProvider(provision.providerId, 0.01);
        },
      });

      return new Response(response.body?.pipeThrough(transformStream), {
        headers: {
          "Content-Type": "text/event-stream",
          "Cache-Control": "no-cache",
          "Connection": "keep-alive",
          // CORS
          "Access-Control-Allow-Origin": "*",
        },
      });
      
    } else {
      // Non-streaming
      const response = await fetch(`${provision.provisionEndpoint}/chat/completions`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!response.ok) {
        const errorText = await response.text();
        return NextResponse.json({ error: `Node returned error: ${errorText}` }, { status: response.status });
      }

      const chatResponse = await response.json();
      const endTime = Date.now();
      const latency = endTime - startTime + (chatResponse.load_duration ?? 0);

      const inputTokens =
        typeof chatResponse.prompt_eval_count === "number"
          ? chatResponse.prompt_eval_count
          : 0;
      const outputTokens =
        typeof chatResponse.eval_count === "number" ? chatResponse.eval_count : 0;

      const timeTaken = (chatResponse.prompt_eval_duration ?? 0) + (chatResponse.eval_duration ?? 0);
      const tps = (inputTokens + outputTokens) / timeTaken;

      await updateMetadata(model, model, inputTokens, outputTokens, latency, tps);

      if (serviceTitle && serviceUrl) {
        await updateServiceMetadata(
          serviceTitle,
          serviceUrl,
          "/chat/completions",
          model,
          inputTokens,
          outputTokens
        );
      }
      await rewardProvider(provision.providerId, 0.01);

      return new NextResponse(JSON.stringify(chatResponse), {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          // CORS
          "Access-Control-Allow-Origin": "*",
        },
      });
      
    }
  } catch (error) {
    console.error("Error in /chat/completions route:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

export async function OPTIONS() {
    return new NextResponse(null, {
      status: 200,
      headers: {
        // Allow all origins
        "Access-Control-Allow-Origin": "*",
        // Specify which headers are allowed or use '*'
        "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
        // Which methods are allowed
        "Access-Control-Allow-Methods": "POST, OPTIONS",
      },
    });
  }
  
### File: src/app/api/v1/trade/route.ts
// src/app/api/v1/trade/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBClient,
  PutItemCommand,
  QueryCommand,
  UpdateItemCommand,
  ConditionalCheckFailedException,
} from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { v4 as uuidv4 } from "uuid";
import type {
  Order,
  OrderStatus,
  // OrderSide, // Removed as not directly used, covered by Order type
  TradingMode,
  TraderRecord,
  MarketOrder, // Import specific types for the switch
  LimitOrder,
  PerpOrder,
  FutureOrder,
  OptionOrder,
} from "@/lib/interfaces";
import { Resource } from "sst"; // Assuming SST Resources are globally available

// --- Constants ---
// Ignore TS errors for Resource properties as requested
const ORDERS_TABLE = Resource.OrdersTable.name;
const TRADERS_TABLE = Resource.TradersTable.name;
const FEE_BPS = 100; // 0.5%

// --- DynamoDB Client ---
const ddb = new DynamoDBClient({});

// --- Helper Functions ---
const pkMarketMode = (market: string, mode: TradingMode) => `MARKET#${market}#${mode.toUpperCase()}`;
// const pkTraderMode = (traderId: string, mode: TradingMode) => `TRADER#${traderId}#${mode.toUpperCase()}`; // Removed as unused in this file's logic

/**
 * Authenticates a trader using their Access Key (traderAk/userAk).
 * @param req - The NextRequest object.
 * @returns The authenticated trader's ID.
 * @throws Will throw an error representable as a NextResponse if authentication fails.
 */
async function authenticateTrader(req: NextRequest): Promise<string> {
  const traderAk = req.headers.get("X-Trader-Ak");

  if (!traderAk) {
    console.warn("Trade API Authentication Error: Missing X-Trader-Ak header");
    throw NextResponse.json({ error: "Missing X-Trader-Ak header" }, { status: 401, headers: { 'Access-Control-Allow-Origin': '*' } });
  }

  try {
    const resp = await ddb.send(
      new QueryCommand({
        TableName: TRADERS_TABLE,
        IndexName: "ByAk", // GSI PK=userAk (ensure this matches your setup)
        KeyConditionExpression: "userAk = :ak", // Adjust attribute name if needed
        ExpressionAttributeValues: marshall({ ":ak": traderAk }),
        Limit: 1,
        // ProjectionExpression: "traderId, #st", // Only fetch needed fields
        // ExpressionAttributeNames: { "#st": "status" },
      })
    );

    if (!resp.Items || resp.Items.length === 0) {
      console.warn(`Trade API Authentication Error: Trader AK not found: ${traderAk.substring(0, 8)}...`);
      throw NextResponse.json({ error: "Invalid Trader Access Key" }, { status: 401, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    const trader = unmarshall(resp.Items[0]) as TraderRecord;

    // Optional: Check trader status
    if (trader.status && trader.status !== "ACTIVE") {
       console.warn(`Trade API Authentication Error: Trader ${trader.traderId} is not active (status: ${trader.status})`);
       throw NextResponse.json({ error: "Trader account is not active" }, { status: 403, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    // Return the core traderId (UUID part)
    if (!trader.traderId) {
        console.error(`Trade API Authentication Error: Found record for AK but missing traderId: ${traderAk.substring(0, 8)}...`, trader);
        throw NextResponse.json({ error: "Internal authentication error" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    return trader.traderId;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (error: any) {
    // Handle potential DynamoDB errors during lookup
    if (!(error instanceof NextResponse)) { // Don't re-wrap our specific errors
        console.error(`Trade API Authentication Error: DDB lookup failed for AK ${traderAk.substring(0, 8)}...:`, error);
        throw NextResponse.json({ error: "Authentication service error" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
    }
    throw error; // Re-throw NextResponse errors
  }
}

// --- CORS Preflight Handler ---
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*", // Allow any origin
      "Access-Control-Allow-Methods": "GET, POST, DELETE, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, X-Trader-Ak", // Allow necessary headers
    },
  });
}

// --- POST /api/v1/trade (Create Order) ---
export async function POST(req: NextRequest) {
  let authenticatedTraderId: string;
  try {
    authenticatedTraderId = await authenticateTrader(req);
  } catch (error) {
    if (error instanceof NextResponse) return error;
    return NextResponse.json({ error: "Authentication failed" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
  }

  try {
    const now = Date.now();
    // Use `any` for initial parsing, then validate and cast within the switch
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const body: any = await req.json();
    const orderId = uuidv4().replace(/-/g, "");
    const sk = `TS#${orderId}`;

    // Validate mode
    if (!body.mode || (body.mode !== "REAL" && body.mode !== "PAPER")) {
      return NextResponse.json({ error: "invalid or missing 'mode' (REAL or PAPER)" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
    }
    const mode: TradingMode = body.mode;

    // Validate common required fields
    if (!body.orderType || !body.market || !body.side || !body.qty || typeof body.qty !== 'number' || body.qty <= 0) {
      return NextResponse.json({ error: "invalid payload: missing or invalid required fields (orderType, market, side, qty)" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
    }
     if (!["BUY", "SELL"].includes(body.side)) {
        return NextResponse.json({ error: "invalid payload: 'side' must be BUY or SELL" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    let order: Order;

    // Use switch statement for type safety and validation
    switch (body.orderType) {
      case "MARKET":
        order = {
          // No ...body spread here, explicitly assign fields
          orderId,
          sk,
          traderId: authenticatedTraderId,
          orderType: "MARKET",
          market: body.market,
          side: body.side,
          qty: body.qty,
          filledQty: 0,
          createdAt: now,
          status: "OPEN",
          feeBps: FEE_BPS,
        } satisfies MarketOrder; // Use 'satisfies' for type checking without casting
        break;

      case "LIMIT":
      case "PERP": // Assuming PERP has same fields as LIMIT for now
        if (body.price === undefined || typeof body.price !== 'number' || body.price <= 0) {
          return NextResponse.json({ error: `price required and must be positive for ${body.orderType} orders` }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
        }
        order = {
          orderId,
          sk,
          traderId: authenticatedTraderId,
          orderType: body.orderType, // Can be LIMIT or PERP
          market: body.market,
          side: body.side,
          qty: body.qty,
          price: body.price,
          filledQty: 0,
          createdAt: now,
          status: "OPEN",
          feeBps: FEE_BPS,
        } satisfies LimitOrder | PerpOrder; // Allow either type
        break;

      case "FUTURE":
         if (body.price === undefined || typeof body.price !== 'number' || body.price <= 0) {
            return NextResponse.json({ error: "price required and must be positive for FUTURE orders" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
         }
         if (body.expiryTs === undefined || typeof body.expiryTs !== 'number' || body.expiryTs <= now) {
            return NextResponse.json({ error: "expiryTs required and must be in the future for FUTURE orders" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
        }
        order = {
          orderId,
          sk,
          traderId: authenticatedTraderId,
          orderType: "FUTURE",
          market: body.market,
          side: body.side,
          qty: body.qty,
          price: body.price,
          expiryTs: body.expiryTs,
          filledQty: 0,
          createdAt: now,
          status: "OPEN",
          feeBps: FEE_BPS,
        } satisfies FutureOrder;
        break;

      case "OPTION":
         if (body.price === undefined || typeof body.price !== 'number' || body.price <= 0) { // Premium
            return NextResponse.json({ error: "price (premium) required and must be positive for OPTION orders" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
         }
          if (body.expiryTs === undefined || typeof body.expiryTs !== 'number' || body.expiryTs <= now) {
            return NextResponse.json({ error: "expiryTs required and must be in the future for OPTION orders" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
        }
        if (body.strike === undefined || typeof body.strike !== 'number' || body.strike <= 0) {
            return NextResponse.json({ error: "strike price required and must be positive for OPTION orders" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
        }
        if (!body.optionType || !["CALL", "PUT"].includes(body.optionType)) {
            return NextResponse.json({ error: "optionType ('CALL' or 'PUT') required for OPTION orders" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
        }
        order = {
          orderId,
          sk,
          traderId: authenticatedTraderId,
          orderType: "OPTION",
          market: body.market,
          side: body.side,
          qty: body.qty,
          price: body.price,
          strike: body.strike,
          expiryTs: body.expiryTs,
          optionType: body.optionType,
          filledQty: 0,
          createdAt: now,
          status: "OPEN",
          feeBps: FEE_BPS,
        } satisfies OptionOrder;
        break;

      default:
        return NextResponse.json({ error: `Unsupported orderType: ${body.orderType}` }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    const pk = pkMarketMode(order.market, mode);

    // Save the order
    await ddb.send(
      new PutItemCommand({
        TableName: ORDERS_TABLE,
        Item: marshall({ pk, ...order, mode }, { removeUndefinedValues: true }),
        ConditionExpression: "attribute_not_exists(pk) AND attribute_not_exists(sk)",
      })
    );

    // Return the created order details
    return new NextResponse(JSON.stringify({ ...order, pk, mode }), {
      status: 201, // Created
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*", // Add CORS header
      },
    });

  } catch (err) {
    if (err instanceof ConditionalCheckFailedException) {
      return NextResponse.json(
        { error: "Order creation conflict (possible duplicate)" },
        { status: 409, headers: { 'Access-Control-Allow-Origin': '*' } }
      );
    }
    console.error("POST /api/v1/trade error:", err);
    return NextResponse.json({ error: "Internal server error creating order" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
  }
}

// --- DELETE /api/v1/trade (Cancel Order) ---
export async function DELETE(req: NextRequest) {
  let authenticatedTraderId: string;
  try {
    authenticatedTraderId = await authenticateTrader(req);
  } catch (error) {
     if (error instanceof NextResponse) return error;
     return NextResponse.json({ error: "Authentication failed" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
  }

  try {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const body: any = await req.json();
    const orderId = body?.orderId;

    if (!orderId || typeof orderId !== 'string') {
      return NextResponse.json({ error: "Missing or invalid 'orderId' in request body" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    // 1. Find the order using the GSI
    const queryResp = await ddb.send(
      new QueryCommand({
        TableName: ORDERS_TABLE,
        IndexName: "ByOrderId",
        KeyConditionExpression: "orderId = :id",
        ExpressionAttributeValues: marshall({ ":id": orderId }),
        Limit: 1,
        // Project necessary fields including pk, sk, traderId, status
        ProjectionExpression: "pk, sk, traderId, #s",
        ExpressionAttributeNames: { "#s": "status" },
      })
    );

    if (!queryResp.Items || queryResp.Items.length === 0) {
      return NextResponse.json({ error: "Order not found" }, { status: 404, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    const order = unmarshall(queryResp.Items[0]) as { pk: string; sk: string; traderId: string; status: OrderStatus };

    // 2. Authorization Check
    if (order.traderId !== authenticatedTraderId) {
      console.warn(`Cancel Order Auth Error: Trader ${authenticatedTraderId} attempted to cancel order ${orderId} belonging to ${order.traderId}`);
      return NextResponse.json({ error: "Forbidden: You can only cancel your own orders" }, { status: 403, headers: { 'Access-Control-Allow-Origin': '*' } });
    }

    // 3. Check if cancellable
    if (order.status !== "OPEN" && order.status !== "PARTIAL") {
      return NextResponse.json(
        { error: `Cannot cancel order in status: ${order.status}` },
        { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } }
      );
    }

    // 4. Attempt to cancel using atomic update
    await ddb.send(
      new UpdateItemCommand({
        TableName: ORDERS_TABLE,
        Key: marshall({ pk: order.pk, sk: order.sk }),
        ConditionExpression: "#s IN (:open, :partial)", // Atomicity check
        UpdateExpression: "SET #s = :cancelled, updatedAt = :ts", // Add updatedAt timestamp
        ExpressionAttributeNames: { "#s": "status" },
        ExpressionAttributeValues: marshall({
          ":open": "OPEN",
          ":partial": "PARTIAL",
          ":cancelled": "CANCELLED",
          ":ts": Date.now(),
        }),
      })
    );

    return new NextResponse(JSON.stringify({ ok: true, message: `Order ${orderId} cancelled.` }), {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*", // Add CORS header
        },
    });

  } catch (err) {
    if (err instanceof ConditionalCheckFailedException) {
      return NextResponse.json(
        { error: "Order status changed during cancellation (likely already filled/cancelled)" },
        { status: 409, headers: { 'Access-Control-Allow-Origin': '*' } }
      );
    }
    let orderId = 'unknown';
    try { orderId = (await req.clone().json()).orderId ?? 'unknown'; } catch {} // Safely try to get orderId for logging
    console.error(`DELETE /api/v1/trade (orderId: ${orderId}) error:`, err);
    return NextResponse.json({ error: "Internal server error cancelling order" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
  }
}

// --- GET /api/v1/trade (Get Orders) ---
export async function GET(req: NextRequest) {
  let authenticatedTraderId: string;
  try {
    authenticatedTraderId = await authenticateTrader(req);
  } catch (error) {
     if (error instanceof NextResponse) return error;
     return NextResponse.json({ error: "Authentication failed" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
  }

  try {
    const market = req.nextUrl.searchParams.get("market") ?? undefined;
    const status = req.nextUrl.searchParams.get("status") ?? undefined;
    const modeParam = req.nextUrl.searchParams.get("mode");

    if (!modeParam || (modeParam !== "REAL" && modeParam !== "PAPER")) {
        return NextResponse.json({ error: "query parameter 'mode' (REAL or PAPER) is required" }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
    }
    const mode = modeParam as TradingMode;

    // Prepare query using ByTraderMode GSI
    const pkPrefix = market ? pkMarketMode(market, mode) : `MARKET#`; // Adjust prefix based on market filter

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const queryParams: any = {
        TableName: ORDERS_TABLE,
        IndexName: "ByTraderMode", // GSI: PK=traderId, SK=pk
        KeyConditionExpression: "traderId = :t AND begins_with(pk, :pkPrefix)",
        ExpressionAttributeValues: {
            ":t": authenticatedTraderId,
            ":pkPrefix": pkPrefix,
        },
        ScanIndexForward: false, // Get most recent first
    };

    // Add optional status filter using FilterExpression
    if (status) {
        const validStatuses = ["OPEN", "PARTIAL", "FILLED", "CANCELLED", "EXPIRED"];
        const upperStatus = status.toUpperCase();
        if (!validStatuses.includes(upperStatus)) {
             return NextResponse.json({ error: `Invalid status filter value. Must be one of: ${validStatuses.join(', ')}` }, { status: 400, headers: { 'Access-Control-Allow-Origin': '*' } });
        }
        queryParams.FilterExpression = "#s = :st";
        queryParams.ExpressionAttributeNames = { "#s": "status" };
        queryParams.ExpressionAttributeValues[":st"] = upperStatus;
    }

    // Marshall ExpressionAttributeValues before sending
    queryParams.ExpressionAttributeValues = marshall(queryParams.ExpressionAttributeValues);

    const resp = await ddb.send(new QueryCommand(queryParams));
    const orders = (resp.Items ?? []).map((item) => unmarshall(item));

     return new NextResponse(JSON.stringify(orders), {
        status: 200,
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*", // Add CORS header
        },
    });

  } catch (err) {
    console.error("GET /api/v1/trade error:", err);
     return NextResponse.json({ error: "Internal server error fetching orders" }, { status: 500, headers: { 'Access-Control-Allow-Origin': '*' } });
  }
}
### File: src/app/api/v1/providers/delete/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/providers/delete/route.ts

import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  GetCommand,
  DeleteCommand
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { 
  ProviderRecord, 
  ProvisionRecord
} from "@/lib/interfaces";

// Create DynamoDB clients
const rawDdbClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(rawDdbClient);

/**
 * CORS preflight handling
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Methods": "POST, DELETE, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // Parse the incoming JSON
    const body = await req.json();
    const {
      provisionId,
      providerAk // Provider API key
    } = body || {};

    // Validate required fields
    if (!provisionId || !providerAk) {
      return NextResponse.json({
        error: "Missing required fields: provisionId, providerAk"
      }, { status: 400 });
    }

    // 1. Verify the provision exists
    const provisionResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId },
      })
    );

    if (!provisionResp.Item) {
      return NextResponse.json({ error: "Provision not found." }, { status: 404 });
    }

    const provision = provisionResp.Item as ProvisionRecord;
    const providerId = provision.providerId;

    if (!providerId) {
      return NextResponse.json({ error: "Provision has no associated provider." }, { status: 400 });
    }

    // 2. Verify the provider API key
    const providerResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );

    if (!providerResp.Item) {
      return NextResponse.json({ error: "Provider not found." }, { status: 404 });
    }

    const provider = providerResp.Item as ProviderRecord;
    if (provider.apiKey !== providerAk) {
      return NextResponse.json({ error: "Invalid provider API key." }, { status: 401 });
    }

    // 3. First make sure the provision is removed from all service pools
    // This is important to do before deleting the provision itself
    await removeFromAllPools(provisionId);

    // 4. Delete the provision from the Provisions Table
    await docClient.send(
      new DeleteCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId }
      })
    );

    // 5. Return success
    return NextResponse.json({ 
      success: true,
      message: `Successfully deleted provision ${provisionId}`
    }, { status: 200 });

  } catch (err: any) {
    console.error("Error in /providers/delete route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

// Also support DELETE HTTP method for idempotent deletion
export async function DELETE(req: NextRequest) {
  return POST(req);
}

/**
 * Remove a provision from all possible service pool tables
 */
async function removeFromAllPools(provisionId: string): Promise<void> {
  const poolTables = [
    Resource.LLMProvisionPoolTable.name,
    Resource.EmbeddingsProvisionPoolTable.name,
    Resource.ScrapingProvisionPoolTable.name,
    Resource.MoonProvisionPoolTable.name,
    Resource.MediaProvisionPoolTable.name,
    Resource.TTSProvisionPoolTable.name
  ];

  for (const table of poolTables) {
    try {
      // Check if the provision exists in this table
      const response = await docClient.send(
        new GetCommand({
          TableName: table,
          Key: { provisionId }
        })
      );
      
      if (response.Item) {
        // If it exists, delete it
        await docClient.send(
          new DeleteCommand({
            TableName: table,
            Key: { provisionId }
          })
        );
      }
    } catch (err) {
      console.error(`Error removing provision ${provisionId} from ${table}:`, err);
      // Continue with other tables even if one fails
    }
  }
}
### File: src/app/api/v1/providers/start/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/providers/start/route.ts

import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  GetCommand,
  ScanCommand
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { 
  ProviderRecord, 
  ProvisionRecord, 
  DeviceDiagnostics 
} from "@/lib/interfaces";
import { SystemProvisionReference } from "@/lib/privateutils";

// Create DynamoDB clients
const rawDdbClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(rawDdbClient);

/**
 * CORS preflight handling
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

/**
 * Determines the tier level based on VRAM capacity
 * @param vramMB VRAM in megabytes
 */
function determineVRAMTier(vramMB: number): number {
  if (vramMB < 4096) return 1;      // Level 1: 1-4GB
  if (vramMB < 8192) return 2;      // Level 2: 4-8GB
  if (vramMB < 22528) return 3;     // Level 3: 8-22GB
  return 4;                          // Level 4: 22GB+
}

/**
 * Gets the current count of provisions for each endpoint/model
 */
async function getProvisionCounts() {
  const tables = [
    { name: Resource.LLMProvisionPoolTable.name, type: "llm" },
    { name: Resource.EmbeddingsProvisionPoolTable.name, type: "embeddings" },
    { name: Resource.ScrapingProvisionPoolTable.name, type: "scraping" },
    { name: Resource.MoonProvisionPoolTable.name, type: "moon" },
    { name: Resource.MediaProvisionPoolTable.name, type: "media" },
    { name: Resource.TTSProvisionPoolTable.name, type: "tts" }
  ];

  const counts: Record<string, number> = {};

  // Scan each table and count items
  for (const table of tables) {
    const response = await docClient.send(
      new ScanCommand({
        TableName: table.name,
        Select: "COUNT"
      })
    );
    
    // For LLM and other model-specific tables, we need to count by model
    if (table.type === "llm" || table.type === "embeddings" || table.type === "tts") {
      const modelCounts = await getModelCounts(table.name);
      Object.assign(counts, modelCounts);
    } else if (table.type === "media") {
      const mediaTypeAndModelCounts = await getMediaCounts(table.name);
      Object.assign(counts, mediaTypeAndModelCounts);
    } else {
      // For non-model tables, just use the total count
      counts[table.type] = response.Count || 0;
    }
  }

  return counts;
}

/**
 * Gets the count of provisions for each model in a table
 */
async function getModelCounts(tableName: string): Promise<Record<string, number>> {
  const modelCounts: Record<string, number> = {};
  
  // Use a scan operation with a projection to get just the models
  const response = await docClient.send(
    new ScanCommand({
      TableName: tableName,
      ProjectionExpression: "model"
    })
  );

  // Count by model
  if (response.Items) {
    for (const item of response.Items) {
      const model = item.model;
      modelCounts[model] = (modelCounts[model] || 0) + 1;
    }
  }

  return modelCounts;
}

/**
 * Gets the count of media provisions by model and type
 */
async function getMediaCounts(tableName: string): Promise<Record<string, number>> {
  const counts: Record<string, number> = {};
  
  // Get all items to count by model and type
  const response = await docClient.send(
    new ScanCommand({
      TableName: tableName,
      ProjectionExpression: "model, #type",
      ExpressionAttributeNames: { "#type": "type" }
    })
  );

  // Count by model and type
  if (response.Items) {
    for (const item of response.Items) {
      const key = `${item.type}-${item.model}`; // e.g., "image-stable diffusion 2.1"
      counts[key] = (counts[key] || 0) + 1;
    }
  }

  return counts;
}

/**
 * Calculate which services to spin up based on device capabilities
 */
async function calculateServices(deviceDiagnostics: DeviceDiagnostics): Promise<string[]> {
  // Get available resources
  const availableVRAM = deviceDiagnostics.compute.gpu?.memory || 0;
  const availableStorage = deviceDiagnostics.compute.storage?.free || 0;
  
  // Determine the tier based on VRAM
  const tier = determineVRAMTier(availableVRAM);
  
  // Get current provision counts
  const currentCounts = await getProvisionCounts();
  
  // Filter endpoints/models based on tier and resources
  let eligibleServices = SystemProvisionReference.filter(service => {
    // Filter by tier
    const serviceTier = determineVRAMTier(service.vramRequired);
    
    // Only consider services in this tier or lower
    if (serviceTier > tier) return false;
    
    // Check if we have enough VRAM and storage
    return (
      service.vramRequired <= availableVRAM && 
      service.storageRequired <= availableStorage
    );
  });

  // If no eligible services at this tier, try to bump down
  if (eligibleServices.length === 0) {
    // Try lower tiers
    let currentTier = tier;
    while (currentTier > 1 && eligibleServices.length === 0) {
      currentTier--;
      eligibleServices = SystemProvisionReference.filter(service => {
        const serviceTier = determineVRAMTier(service.vramRequired);
        return (
          serviceTier === currentTier && 
          service.vramRequired <= availableVRAM && 
          service.storageRequired <= availableStorage
        );
      });
    }
    
    // If still no eligible services, add /scrape as fallback
    if (eligibleServices.length === 0) {
      return ["/scrape"];
    }
  }

  // Calculate the fulfilled percentage for each eligible service
  const fulfillmentRates = eligibleServices.map(service => {
    const modelKey = service.model ? service.model : service.endpoint;
    const currentCount = currentCounts[modelKey] || 0;
    const fulfillmentPercentage = (currentCount / service.provisionTargetNumber) * 100;
    
    return {
      endpoint: service.endpoint,
      model: service.model,
      currentCount,
      targetCount: service.provisionTargetNumber,
      fulfillmentPercentage,
      vramRequired: service.vramRequired,
      storageRequired: service.storageRequired
    };
  });

  // Sort by fulfillment rate (lowest first) to prioritize underserved endpoints
  fulfillmentRates.sort((a, b) => a.fulfillmentPercentage - b.fulfillmentPercentage);
  
  // In case of tie (same percentage), randomly shuffle those entries
  const lowestPercentage = fulfillmentRates[0]?.fulfillmentPercentage;
  const tiedServices = fulfillmentRates.filter(s => s.fulfillmentPercentage === lowestPercentage);
  
  if (tiedServices.length > 1) {
    // Fisher-Yates shuffle of tied services
    for (let i = tiedServices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [tiedServices[i], tiedServices[j]] = [tiedServices[j], tiedServices[i]];
    }
  }

  const selectedServices: string[] = [];
  let remainingVRAM = availableVRAM;
  let remainingStorage = availableStorage;
  
  // Use lowest fulfillment services first, or a tied random one
  const servicesToTry = tiedServices.length > 0 ? tiedServices : fulfillmentRates;
  
  for (const service of servicesToTry) {
    // Check if we have enough resources for this service
    if (
      service.vramRequired <= remainingVRAM && 
      service.storageRequired <= remainingStorage
    ) {
      // Format the service identifier
      const serviceId = service.model ?? service.endpoint.replace(/\//g, "");
        
      selectedServices.push(serviceId);
      
      // Deduct resources
      remainingVRAM -= service.vramRequired;
      remainingStorage -= service.storageRequired;
      
      // If we can't fit any more services, stop
      if (remainingVRAM < 100 || remainingStorage < 100) { // 100MB as minimum threshold
        break;
      }
      
      // Try to add more services
      const additionalServices = await calculateAdditionalServices(
        remainingVRAM, 
        remainingStorage, 
        currentCounts
      );
      
      selectedServices.push(...additionalServices);
      break;
    }
  }
  
  // If we couldn't allocate any service, use /scrape as fallback
  if (selectedServices.length === 0) {
    return ["/scrape"];
  }
  
  return selectedServices;
}

/**
 * Calculate additional services after selecting the primary one
 */
async function calculateAdditionalServices(
  remainingVRAM: number, 
  remainingStorage: number,
  currentCounts: Record<string, number>
): Promise<string[]> {
  const additionalServices: string[] = [];
  
  // Filter by remaining resources
  let candidates = SystemProvisionReference.filter(service => 
    service.vramRequired <= remainingVRAM && 
    service.storageRequired <= remainingStorage
  );
  
  // If no candidates, return empty
  if (candidates.length === 0) return [];
  
  // Sort by fulfillment rate (lowest first)
  candidates = candidates.sort((a, b) => {
    const modelKeyA = a.model ? a.model : a.endpoint;
    const modelKeyB = b.model ? b.model : b.endpoint;
    
    const countA = currentCounts[modelKeyA] || 0;
    const countB = currentCounts[modelKeyB] || 0;
    
    const percentageA = (countA / a.provisionTargetNumber) * 100;
    const percentageB = (countB / b.provisionTargetNumber) * 100;
    
    return percentageA - percentageB;
  });
  
  // Take the first candidate
  const selected = candidates[0];
  
  // Format service identifier
  const serviceId = selected.model 
    ? `${selected.endpoint}:${selected.model}`
    : selected.endpoint;
    
  additionalServices.push(serviceId);
  
  return additionalServices;
}

export async function POST(req: NextRequest) {
  try {
    // Parse the incoming JSON
    const body = await req.json();
    const {
      provisionId,
      providerAk, // Provider API key
      availableResources, // Device diagnostics object
    } = body || {};

    // Validate required fields
    if (!provisionId || !providerAk || !availableResources) {
      return NextResponse.json({
        error: "Missing required fields: provisionId, providerAk, availableResources"
      }, { status: 400 });
    }

    // 1. Verify the provision exists
    const provisionResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId },
      })
    );

    if (!provisionResp.Item) {
      return NextResponse.json({ error: "Provision not found." }, { status: 404 });
    }

    const provision = provisionResp.Item as ProvisionRecord;
    const providerId = provision.providerId;

    if (!providerId) {
      return NextResponse.json({ error: "Provision has no associated provider." }, { status: 400 });
    }

    // 2. Verify the provider API key
    const providerResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );

    if (!providerResp.Item) {
      return NextResponse.json({ error: "Provider not found." }, { status: 404 });
    }

    const provider = providerResp.Item as ProviderRecord;
    if (provider.apiKey !== providerAk) {
      return NextResponse.json({ error: "Invalid provider API key." }, { status: 401 });
    }

    // 3. Calculate services to spin up
    const servicesToSpinUp = await calculateServices(availableResources as DeviceDiagnostics);

    // 4. Return the services to spin up
    return NextResponse.json({ 
      services: servicesToSpinUp 
    }, { status: 200 });

  } catch (err: any) {
    console.error("Error in /providers/start route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

### File: src/app/api/v1/providers/start/callback/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/providers/start/callback/route.ts

import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  GetCommand,
  PutCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { 
  ProviderRecord, 
  ProvisionRecord,
  Location 
} from "@/lib/interfaces";

// Create DynamoDB clients
const rawDdbClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(rawDdbClient);

/**
 * CORS preflight handling
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // Parse the incoming JSON
    const body = await req.json();
    const {
      provisionId,
      providerAk,      // Provider API key
      startedServices, // Array of services that were successfully started
      providedUrl      // The URL where the provision is accessible
    } = body || {};

    // Validate required fields
    if (!provisionId || !providerAk || !startedServices || !startedServices.length || !providedUrl) {
      return NextResponse.json({
        error: "Missing required fields: provisionId, providerAk, startedServices, providedUrl"
      }, { status: 400 });
    }

    // 1. Verify the provision exists
    const provisionResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId },
      })
    );

    if (!provisionResp.Item) {
      return NextResponse.json({ error: "Provision not found." }, { status: 404 });
    }

    const provision = provisionResp.Item as ProvisionRecord;
    const providerId = provision.providerId;
    const location = provision.location;

    if (!providerId) {
      return NextResponse.json({ error: "Provision has no associated provider." }, { status: 400 });
    }

    // 2. Verify the provider API key
    const providerResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );

    if (!providerResp.Item) {
      return NextResponse.json({ error: "Provider not found." }, { status: 404 });
    }

    const provider = providerResp.Item as ProviderRecord;
    if (provider.apiKey !== providerAk) {
      return NextResponse.json({ error: "Invalid provider API key." }, { status: 401 });
    }

    // 3. Update the relevant provision pool tables based on started services
    for (const service of startedServices) {
      await addToAppropriatePool(service, provisionId, providedUrl, location);
    }

    // 4. Return success
    return NextResponse.json({ 
      success: true,
      message: `Successfully registered ${startedServices.length} services for provision ${provisionId}`
    }, { status: 200 });

  } catch (err: any) {
    console.error("Error in /providers/start/callback route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * Add a provision to the appropriate pool table based on the service type
 */
async function addToAppropriatePool(
  service: string, 
  provisionId: string, 
  provisionEndpoint: string,
  location?: Location
) {
  // Generate a random value for distribution (between 0 and 1)
  const randomValue = Math.random();
  
  // Parse the service identifier to determine the appropriate table
  if (service === "/scrape") {
    // Add to scraping pool
    await docClient.send(
      new PutCommand({
        TableName: Resource.ScrapingProvisionPoolTable.name,
        Item: {
          provisionId,
          randomValue,
          provisionEndpoint,
          location
        }
      })
    );
  } else if (service === "/m") {
    // Add to moon pool
    await docClient.send(
      new PutCommand({
        TableName: Resource.MoonProvisionPoolTable.name,
        Item: {
          provisionId,
          randomValue,
          provisionEndpoint,
          location
        }
      })
    );
  } else if (service.startsWith("/tts")) {
    // Parse model name if available
    const model = service.includes(":") ? service.split(":")[1] : undefined;
    
    await docClient.send(
      new PutCommand({
        TableName: Resource.TTSProvisionPoolTable.name,
        Item: {
          provisionId,
          model,
          randomValue,
          provisionEndpoint,
          location
        }
      })
    );
  } else if (service.startsWith("/image") || service.startsWith("/video")) {
    // Determine if it's image or video
    const type = service.startsWith("/image") ? "image" : "video";
    
    // Parse model name if available
    const model = service.includes(":") ? service.split(":")[1] : undefined;
    
    await docClient.send(
      new PutCommand({
        TableName: Resource.MediaProvisionPoolTable.name,
        Item: {
          provisionId,
          model,
          type,
          randomValue,
          provisionEndpoint,
          location
        }
      })
    );
  } else if (service.startsWith("/embeddings")) {
    // Parse model name if available
    const model = service.includes(":") ? service.split(":")[1] : undefined;
    
    await docClient.send(
      new PutCommand({
        TableName: Resource.EmbeddingsProvisionPoolTable.name,
        Item: {
          provisionId,
          model: model || "unknown",  // Model is required for embeddings
          randomValue,
          provisionEndpoint,
          location
        }
      })
    );
  } else if (service.startsWith("/chat/completions") || !service.includes("/")) {
    // If it's a pure model name (no slashes) or /chat/completions endpoint
    // Add to LLM pool
    
    // Parse model name
    let model = service;
    if (service.includes(":")) {
      model = service.split(":")[1];
    } else if (service.includes("/")) {
      // If it's /chat/completions, the model should be specified after ":"
      if (!service.includes(":")) {
        model = "unknown"; // Default if no model specified
      } else {
        model = service.split(":")[1];
      }
    }
    
    await docClient.send(
      new PutCommand({
        TableName: Resource.LLMProvisionPoolTable.name,
        Item: {
          provisionId,
          model,
          randomValue,
          provisionEndpoint,
          location
        }
      })
    );
  }
  // Add other service types as needed
}
### File: src/app/api/v1/providers/end/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/providers/end/route.ts

import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  GetCommand,
  DeleteCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { 
  ProviderRecord, 
  ProvisionRecord
} from "@/lib/interfaces";

// Create DynamoDB clients
const rawDdbClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(rawDdbClient);

/**
 * CORS preflight handling
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // Parse the incoming JSON
    const body = await req.json();
    const {
      provisionId,
      providerAk, // Provider API key
      services    // Optional: specific services to end, if not provided, end all
    } = body || {};

    // Validate required fields
    if (!provisionId || !providerAk) {
      return NextResponse.json({
        error: "Missing required fields: provisionId, providerAk"
      }, { status: 400 });
    }

    // 1. Verify the provision exists
    const provisionResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId },
      })
    );

    if (!provisionResp.Item) {
      return NextResponse.json({ error: "Provision not found." }, { status: 404 });
    }

    const provision = provisionResp.Item as ProvisionRecord;
    const providerId = provision.providerId;

    if (!providerId) {
      return NextResponse.json({ error: "Provision has no associated provider." }, { status: 400 });
    }

    // 2. Verify the provider API key
    const providerResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );

    if (!providerResp.Item) {
      return NextResponse.json({ error: "Provider not found." }, { status: 404 });
    }

    const provider = providerResp.Item as ProviderRecord;
    if (provider.apiKey !== providerAk) {
      return NextResponse.json({ error: "Invalid provider API key." }, { status: 401 });
    }

    // 3. Remove the provision from all relevant pool tables
    // If services are specified, we'll only remove from those pool tables
    // Otherwise, remove from all possible pool tables
    const poolTables = [
      Resource.LLMProvisionPoolTable.name,
      Resource.EmbeddingsProvisionPoolTable.name,
      Resource.ScrapingProvisionPoolTable.name,
      Resource.MoonProvisionPoolTable.name,
      Resource.MediaProvisionPoolTable.name,
      Resource.TTSProvisionPoolTable.name
    ];

    let removedCount = 0;

    // If specific services provided, map them to table names
    if (services && services.length > 0) {
      const tablesToCheck = mapServicesToTables(services);
      for (const table of tablesToCheck) {
        if (await removeFromTable(table, provisionId)) {
          removedCount++;
        }
      }
    } else {
      // Otherwise check all tables
      for (const table of poolTables) {
        if (await removeFromTable(table, provisionId)) {
          removedCount++;
        }
      }
    }

    // 4. Return success
    return NextResponse.json({ 
      success: true,
      message: `Successfully ended ${removedCount} services for provision ${provisionId}`
    }, { status: 200 });

  } catch (err: any) {
    console.error("Error in /providers/end route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

/**
 * Map service types to their respective table names
 */
function mapServicesToTables(services: string[]): string[] {
  const tables = new Set<string>();
  
  for (const service of services) {
    if (service === "/scrape") {
      tables.add(Resource.ScrapingProvisionPoolTable.name);
    } else if (service === "/m") {
      tables.add(Resource.MoonProvisionPoolTable.name);
    } else if (service.startsWith("/tts")) {
      tables.add(Resource.TTSProvisionPoolTable.name);
    } else if (service.startsWith("/image") || service.startsWith("/video")) {
      tables.add(Resource.MediaProvisionPoolTable.name);
    } else if (service.startsWith("/embeddings")) {
      tables.add(Resource.EmbeddingsProvisionPoolTable.name);
    } else if (service.startsWith("/chat/completions") || !service.includes("/")) {
      tables.add(Resource.LLMProvisionPoolTable.name);
    }
  }
  
  return Array.from(tables);
}

/**
 * Remove a provision from a specific pool table
 * @returns true if an item was removed, false if not
 */
async function removeFromTable(tableName: string, provisionId: string): Promise<boolean> {
  try {
    // First check if the provision exists in this table
    const response = await docClient.send(
      new GetCommand({
        TableName: tableName,
        Key: { provisionId }
      })
    );
    
    if (response.Item) {
      // If it exists, delete it
      await docClient.send(
        new DeleteCommand({
          TableName: tableName,
          Key: { provisionId }
        })
      );
      return true;
    }
    
    return false;
  } catch (err) {
    console.error(`Error removing provision ${provisionId} from ${tableName}:`, err);
    return false;
  }
}
### File: src/app/api/v1/providers/new/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/providers/new/route.ts

import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBClient
} from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  GetCommand,
  PutCommand
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { ProviderRecord, ProvisionRecord, DeviceDiagnostics, Location } from "@/lib/interfaces";

/**
 * 1) Create the raw DynamoDBClient
 */
const rawDdbClient = new DynamoDBClient({});

/**
 * 2) Wrap it in a DocumentClient for convenience
 */
const docClient = DynamoDBDocumentClient.from(rawDdbClient);

/**
 * CORS preflight
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers":
        "Content-Type, Authorization",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // 1) Parse the incoming JSON
    const body = await req.json();
    const {
      providerId,
      providerAk,      // The provider’s API key
      provisionId,
      provisionSpecs,  // e.g. { compute: {...}, type: "gpu" }
      location         // e.g. { country, state, city }
    } = body || {};

    // Basic required fields check
    if (!providerId || !providerAk || !provisionId || !provisionSpecs || !location) {
      return NextResponse.json({
        error: "Missing required fields: providerId, providerAk, provisionId, provisionSpecs, location"
      }, { status: 400 });
    }

    // 2) Check if the providerId + providerAk match in the ProviderTable
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },        // providerId is the PK
      })
    );

    if (!getResp.Item) {
      return NextResponse.json({ error: "Provider not found." }, { status: 404 });
    }

    const provider = getResp.Item as ProviderRecord;
    if (provider.apiKey !== providerAk) {
      return NextResponse.json({ error: "Invalid provider API key." }, { status: 401 });
    }

    // 3) Build the new provision record to store in ProvisionsTable
    const newProvision: ProvisionRecord = {
      provisionId,
      providerId,
      deviceDiagnostics: provisionSpecs as DeviceDiagnostics,
      location: location as Location
    };

    // 4) Put it in ProvisionsTable
    await docClient.send(
      new PutCommand({
        TableName: Resource.ProvisionsTable.name,
        Item: newProvision
      })
    );

    // 5) TODO: Call out to peaq here to add the provision

    // 5) Return success
    return NextResponse.json({ success: true }, { status: 200 });

  } catch (err: any) {
    console.error("Error in /providers/new route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

### File: src/app/api/v1/scrape/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/scrape/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectScrapingProvision,
  checkScrapingHealth,
  removeScrapingProvision,
  updateScrapeMetadata,
  updateScrapeServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

/** CORS preflight */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // 1) Auth
    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Missing or invalid authorization header" }, { status: 401 });
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0 /* or more credits if needed */);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 2) Parse request body => { urls, format }, etc.
    const body = await req.json();
    const { urls, format = "html", ...rest } = body || {};
    if (!Array.isArray(urls) || urls.length === 0) {
      return NextResponse.json({ error: 'Provide at least one URL in "urls" array.' }, { status: 400 });
    }

    // 3) Select a healthy scraping node
    let isHealthy = false;
    let attempts = 0;
    let provision: any;
    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectScrapingProvision(); // random
        isHealthy = await checkScrapingHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeScrapingProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting scraping provision:", err);
        return NextResponse.json({ error: "No scraping provision available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy scraping provision found" }, { status: 503 });
    }

    // 4) Forward
    const startTime = Date.now();
    const nodeResp = await fetch(`${provision.provisionEndpoint}/scrape`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ urls, format, ...rest }),
    });
    if (!nodeResp.ok) {
      const errorText = await nodeResp.text();
      return NextResponse.json({ error: `Node error: ${errorText}` }, { status: nodeResp.status });
    }
    const data = await nodeResp.json();
    const endTime = Date.now();
    const latency = endTime - startTime;

    // 5) Update daily metadata => "/scrape"
    await updateScrapeMetadata(latency);

    // 6) Update service metadata
    if (serviceTitle) {
      await updateScrapeServiceMetadata(serviceTitle, serviceUrl);
    }

    // 7) Reward
    await rewardProvider(provision.providerId, 0.01);

    // 8) Return JSON with CORS
    return new NextResponse(JSON.stringify(data), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err) {
    console.error("Error in /scrape route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/v1/image/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/image/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectImageProvision,
  checkImageHealth,
  removeImageProvision,
  updateImageMetadata,
  updateImageServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

/**
 * CORS preflight
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // 1) Extract & validate auth
    const authHeader = req.headers.get("authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Missing or invalid authorization header" }, { status: 401 });
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 2) Parse JSON body
    const body = await req.json();
    const {
      prompt,
      negativePrompt,
      numInferenceSteps = 30,
      width = 512,
      height = 512,
      ...options
    } = body;

    if (!prompt) {
      return NextResponse.json({ error: "Missing 'prompt' field." }, { status: 400 });
    }

    // 3) Select a healthy image node
    let isHealthy = false;
    let attempts = 0;
    let provision: any;
    const model = "stable-diffusion-2-1-base"; // or body.model if you want to pass a model
    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectImageProvision(model);
        isHealthy = await checkImageHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeImageProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting image provision:", err);
        return NextResponse.json({ error: "No image provision available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy image provision found" }, { status: 503 });
    }

    // 4) Build payload for the node
    const payload = {
      prompt,
      negativePrompt,
      numInferenceSteps,
      width,
      height,
      ...options,
    };

    // 5) Forward request
    const startTime = Date.now();
    const nodeResp = await fetch(`${provision.provisionEndpoint}/image`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!nodeResp.ok) {
      const errorText = await nodeResp.text();
      return NextResponse.json({ error: `Node error: ${errorText}` }, { status: nodeResp.status });
    }
    const endTime = Date.now();
    const latency = endTime - startTime;

    // 6) Update daily metadata
    await updateImageMetadata(latency);

    // 7) Update service metadata if we have a serviceTitle
    if (serviceTitle) {
      await updateImageServiceMetadata(serviceTitle, serviceUrl);
    }

    // 8) Reward provider
    await rewardProvider(provision.providerId, 0.01);

    // 9) Return the PNG from the node
    // We'll do a streaming pass-through. 
    // We'll set headers: content-type = image/png, plus CORS
    return new Response(nodeResp.body, {
      status: 200,
      headers: {
        "Content-Type": "image/png",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (error: any) {
    console.error("Error in /image route:", error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

### File: src/app/api/v1/tts/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/tts/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectTTSProvision,
  checkTTSHealth,
  removeTTSProvision,
  updateTTSMetadata,
  updateTTSServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

/** Handle CORS preflight */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers":
        "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // 1) Validate user
    const authHeader = req.headers.get("authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json(
        { error: "Missing or invalid authorization header" },
        { status: 401 }
      );
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0 /* or however many credits needed */);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 2) Parse JSON body => { text, voice? }
    const body = await req.json();
    const { text, voice = "af_bella", ...options } = body || {};

    if (!text) {
      return NextResponse.json({ error: "Missing 'text' field." }, { status: 400 });
    }

    // 3) Pick a healthy TTS node
    //    You might want to do a `model` field if you store multiple TTS models, e.g. 'onnx_82M'
    //    For now, let's just pass a hardcoded 'kokoro' or something
    const model = "kokoro"; // or body.model if you prefer
    let isHealthy = false;
    let attempts = 0;
    let provision: any;

    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectTTSProvision(model);
        isHealthy = await checkTTSHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          // remove it
          await removeTTSProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting TTS provision:", err);
        return NextResponse.json({ error: "No TTS provision available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy TTS provision found" }, { status: 503 });
    }

    // 4) Forward the request
    const startTime = Date.now();
    const nodeResp = await fetch(`${provision.provisionEndpoint}/tts`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text, voice, ...options }),
    });
    if (!nodeResp.ok) {
      const errorText = await nodeResp.text();
      return NextResponse.json({ error: `TTS node error: ${errorText}` }, { status: nodeResp.status });
    }

    // The node returns WAV data as a Buffer, e.g. "audio/wav"
    // We'll do a streaming pass-through to avoid loading the entire WAV in memory.
    const endTime = Date.now();
    const latency = endTime - startTime;

    // 5) Update daily TTS usage => endpoint="/tts"
    await updateTTSMetadata(latency);

    // 6) Update service usage
    if (serviceTitle) {
      await updateTTSServiceMetadata(serviceTitle, serviceUrl);
    }

    // 7) Reward
    await rewardProvider(provision.providerId, 0.01);

    // 8) Return the WAV with "audio/wav" and CORS
    return new Response(nodeResp.body, {
      status: 200,
      headers: {
        "Content-Type": "audio/wav",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err) {
    console.error("Error in /tts route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/v1/m/detect/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/m/detect/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectMoonProvision,
  checkMoonHealth,
  removeMoonProvision,
  updateMoonMetadata,
  updateMoonServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

/** CORS preflight */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // 1) Auth
    const authHeader = req.headers.get("authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Missing or invalid authorization header" }, { status: 401 });
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 2) Body => { imageUrl?, imageBase64?, imageUint8?, target? }
    const body = await req.json();
    const { target, ...rest } = body;
    if (!target) {
      return NextResponse.json({ error: "Missing 'target' field." }, { status: 400 });
    }
    // Also ensure at least one of imageUrl, imageBase64, imageUint8
    if (!body.imageUrl && !body.imageBase64 && !body.imageUint8) {
      return NextResponse.json({ error: "Must provide imageUrl, imageBase64, or imageUint8" }, { status: 400 });
    }

    // 3) Select node
    let isHealthy = false;
    let attempts = 0;
    let provision: any;
    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectMoonProvision();
        isHealthy = await checkMoonHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeMoonProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting moon node for /m/detect:", err);
        return NextResponse.json({ error: "No moon node available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy moon node found" }, { status: 503 });
    }

    // 4) Forward
    const startTime = Date.now();
    const resp = await fetch(`${provision.provisionEndpoint}/m/detect`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ target, ...rest }),
    });
    if (!resp.ok) {
      const errorText = await resp.text();
      return NextResponse.json({ error: `Node error: ${errorText}` }, { status: resp.status });
    }
    const data = await resp.json();
    const endTime = Date.now();
    const latency = endTime - startTime;

    // 5) Update metadata => "/m/detect"
    await updateMoonMetadata("/m/detect", latency);

    // 6) Service metadata
    if (serviceTitle) {
      await updateMoonServiceMetadata(serviceTitle, serviceUrl, "/m/detect");
    }

    // 7) Reward
    await rewardProvider(provision.providerId, 0.01);

    // 8) Return JSON with CORS
    return new NextResponse(JSON.stringify(data), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err: any) {
    console.error("Error in /m/detect route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/v1/m/caption/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/m/caption/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectMoonProvision,
  checkMoonHealth,
  removeMoonProvision,
  updateMoonMetadata,
  updateMoonServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

  /**
   * Handles HTTP POST requests for the /m/caption endpoint.
   *
   * This function performs the following operations:
   * 1. Authenticates the request using the authorization header and validates the API key.
   * 2. Parses the request body to extract image data and length, returning errors for missing fields.
   * 3. Attempts to select a healthy moon node to handle the request, with retries for unhealthy nodes.
   * 4. Forwards the request to the selected moon node's /m/caption endpoint and processes the response.
   * 5. Updates moon metadata with the latency of the request.
   * 6. Updates service metadata if a service title is provided.
   * 7. Rewards the provider of the selected moon node.
   * 8. Returns the response from the moon node as JSON, or an error response if an exception occurs.
   *
   * @param req - The incoming HTTP request object.
   * @returns A NextResponse object containing the result of the operation.
   */
export async function POST(req: NextRequest) {
  try {
    // Validate user
    // ... same pattern as /m/query ...
    const authHeader = req.headers.get("authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Missing or invalid authorization header" }, { status: 401 });
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // Parse body => { imageUrl?, imageBase64?, length? }
    const body = await req.json();
    if (!body.imageUrl && !body.imageBase64 && !body.imageUint8) {
      return NextResponse.json({ error: "Must provide one of imageUrl, imageBase64, imageUint8" }, { status: 400 });
    }

    // Select node
    let isHealthy = false;
    let attempts = 0;
    let provision: any;
    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectMoonProvision();
        isHealthy = await checkMoonHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeMoonProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting moon for /m/caption:", err);
        return NextResponse.json({ error: "No moon node available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy moon node found" }, { status: 503 });
    }

    // Forward request
    const startTime = Date.now();
    const resp = await fetch(`${provision.provisionEndpoint}/m/caption`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    if (!resp.ok) {
      const errorText = await resp.text();
      return NextResponse.json({ error: `Node error: ${errorText}` }, { status: resp.status });
    }
    const data = await resp.json();
    const endTime = Date.now();
    const latency = endTime - startTime;

    // update metadata => "/m/caption"
    await updateMoonMetadata("/m/caption", latency);

    // service metadata
    if (serviceTitle) {
      await updateMoonServiceMetadata(serviceTitle, serviceUrl, "/m/caption");
    }

    // reward
    await rewardProvider(provision.providerId, 0.01);

    // return JSON
    return new NextResponse(JSON.stringify(data), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err: any) {
    console.error("Error in /m/caption route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/v1/m/point/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/m/point/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectMoonProvision,
  checkMoonHealth,
  removeMoonProvision,
  updateMoonMetadata,
  updateMoonServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

/**
 * Handle CORS preflight requests.
 * Responds with a 200 and allows all origins, headers, and methods.
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

/**
 * Handles HTTP POST requests for the /m/point endpoint.
 * 
 * This function performs the following operations:
 * 1. Authenticates the request using the authorization header and validates the API key.
 * 2. Parses the request body to extract image data and a target field, returning errors for missing fields.
 * 3. Attempts to select a healthy moon node to handle the request, with retries for unhealthy nodes.
 * 4. Forwards the request to the selected moon node's /m/point endpoint and processes the response.
 * 5. Updates moon metadata with the latency of the request.
 * 6. Updates service metadata if a service title is provided.
 * 7. Rewards the provider of the selected moon node.
 * 8. Returns the response from the moon node as JSON, or an error response if an exception occurs.
 * 
 * @param req - The incoming HTTP request object.
 * @returns A NextResponse object containing the result of the operation.
 */

export async function POST(req: NextRequest) {
  try {
    // 1) Auth
    const authHeader = req.headers.get("authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Missing or invalid authorization header" }, { status: 401 });
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // 2) parse => { imageUrl?, imageBase64?, imageUint8?, target? }
    const body = await req.json();
    const { target, ...rest } = body;
    if (!target) {
      return NextResponse.json({ error: "Missing 'target' field." }, { status: 400 });
    }
    if (!body.imageUrl && !body.imageBase64 && !body.imageUint8) {
      return NextResponse.json({ error: "Must provide imageUrl, imageBase64, or imageUint8" }, { status: 400 });
    }

    // 3) node
    let isHealthy = false;
    let attempts = 0;
    let provision: any;
    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectMoonProvision();
        isHealthy = await checkMoonHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeMoonProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting moon node for /m/point:", err);
        return NextResponse.json({ error: "No moon node available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy moon node found" }, { status: 503 });
    }

    // 4) forward
    const startTime = Date.now();
    const resp = await fetch(`${provision.provisionEndpoint}/m/point`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ target, ...rest }),
    });
    if (!resp.ok) {
      const errorText = await resp.text();
      return NextResponse.json({ error: `Node error: ${errorText}` }, { status: resp.status });
    }
    const data = await resp.json();
    const endTime = Date.now();
    const latency = endTime - startTime;

    // 5) update => "/m/point"
    await updateMoonMetadata("/m/point", latency);

    // 6) service
    if (serviceTitle) {
      await updateMoonServiceMetadata(serviceTitle, serviceUrl, "/m/point");
    }

    // 7) reward
    await rewardProvider(provision.providerId, 0.01);

    // 8) return JSON
    return new NextResponse(JSON.stringify(data), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err: any) {
    console.error("Error in /m/point route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/v1/m/query/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/m/query/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  validateApiKey,
  selectMoonProvision,
  checkMoonHealth,
  removeMoonProvision,
  updateMoonMetadata,
  updateMoonServiceMetadata,
  rewardProvider,
} from "@/lib/utils";

  /**
   * CORS preflight
   */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    const authHeader = req.headers.get("authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Missing or invalid authorization header" }, { status: 401 });
    }
    const apiKey = authHeader.replace("Bearer ", "");
    const userId = req.headers.get("X-User-Id") || "";
    const serviceTitle = req.headers.get("X-Title") || null;
    const serviceUrl = req.headers.get("HTTP-Referer") || null;

    const { valid, reason } = await validateApiKey(userId, apiKey, 0);
    if (!valid) {
      return NextResponse.json({ error: reason ?? "Invalid API key" }, { status: 401 });
    }

    // parse => { imageUrl?, imageBase64?, imageUint8?, question? }
    const body = await req.json();
    const { question, ...rest } = body;
    if (!question) {
      return NextResponse.json({ error: "Missing 'question' field." }, { status: 400 });
    }
    if (!body.imageUrl && !body.imageBase64 && !body.imageUint8) {
      return NextResponse.json({ error: "Must provide imageUrl, imageBase64, or imageUint8" }, { status: 400 });
    }

    let isHealthy = false;
    let attempts = 0;
    let provision: any;
    while (!isHealthy && attempts < 3) {
      try {
        provision = await selectMoonProvision();
        isHealthy = await checkMoonHealth(provision.provisionEndpoint);
        if (!isHealthy && attempts === 2) {
          await removeMoonProvision(provision.provisionId);
        }
        attempts++;
      } catch (err) {
        console.error("Error selecting moon node for /m/query:", err);
        return NextResponse.json({ error: "No moon node available" }, { status: 503 });
      }
    }
    if (!isHealthy) {
      return NextResponse.json({ error: "No healthy moon node found" }, { status: 503 });
    }

    const startTime = Date.now();
    const resp = await fetch(`${provision.provisionEndpoint}/m/query`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ question, ...rest }),
    });
    if (!resp.ok) {
      const errorText = await resp.text();
      return NextResponse.json({ error: `Node error: ${errorText}` }, { status: resp.status });
    }
    const data = await resp.json();
    const endTime = Date.now();
    const latency = endTime - startTime;

    // update => "/m/query"
    await updateMoonMetadata("/m/query", latency);

    // service
    if (serviceTitle) {
      await updateMoonServiceMetadata(serviceTitle, serviceUrl, "/m/query");
    }

    await rewardProvider(provision.providerId, 0.01);

    return new NextResponse(JSON.stringify(data), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (err: any) {
    console.error("Error in /m/query route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/paper/faucet/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/paper/faucet/route.ts
import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBClient,
  UpdateItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";
import { requireAuth } from "@/lib/auth"; // Your authentication helper
import type { TradingMode } from "@/lib/interfaces";
// import { pk } from "@/dex/matchers/matchEngine"; // Or redefine helper

const BALANCES_TABLE = Resource.BalancesTable.name;
const ddb = new DynamoDBClient({});

// Redefine or import PK helper for BalancesTable
const pkTraderMode = (traderId: string, mode: TradingMode) =>
  `TRADER#${traderId}#${mode.toUpperCase()}`;
const skAsset = (asset: string) => `ASSET#${asset.toUpperCase()}`;

// --- Configuration for Faucet ---
const FAUCET_ASSET = "USDC"; // Asset provided by the faucet
const FAUCET_AMOUNT_BASE_UNITS = "10000000000"; // e.g., 10,000 USDC with 6 decimals
const PAPER_MODE: TradingMode = "PAPER";
// --------------------------------

export async function POST(req: NextRequest) {
  let authenticatedTraderId: string;
  try {
    // --- Authentication ---
    // requireAuth should verify the request signature/token and return the traderId
    // or throw an error if authentication fails.
    const authResult = await requireAuth(req); // Modify based on your auth implementation
    // Assuming requireAuth returns an object with the traderId or similar identifier
    authenticatedTraderId = authResult.traderId; // Adjust based on your auth return value
    if (!authenticatedTraderId) {
        throw new Error("Authentication failed or traderId not returned.");
    }
    console.log(`Faucet request authenticated for traderId: ${authenticatedTraderId}`);
    // --- End Authentication ---

  } catch (authError: any) {
    console.error("Faucet Authentication Error:", authError.message);
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
      // Optional: Check if the request body contains a specific traderId and validate it matches the authenticated one
      // const { traderId: bodyTraderId } = await req.json();
      // if (bodyTraderId && bodyTraderId !== authenticatedTraderId) {
      //      return NextResponse.json({ error: "Trader ID mismatch" }, { status: 403 });
      // }

    // Construct the keys for the paper balance item
    const balancePk = pkTraderMode(authenticatedTraderId, PAPER_MODE);
    const balanceSk = skAsset(FAUCET_ASSET);

    // --- Add Funds using UpdateItem ---
    // Using ADD ensures the item is created if it doesn't exist,
    // and the balance is incremented if it does.
    // We also initialize 'pending' to 0 if the item is created.
    console.log(`Adding ${FAUCET_AMOUNT_BASE_UNITS} ${FAUCET_ASSET} to ${balancePk}`);
    await ddb.send(
      new UpdateItemCommand({
        TableName: BALANCES_TABLE,
        Key: marshall({ pk: balancePk, sk: balanceSk }),
        UpdateExpression: `
                ADD balance :amount
                SET pending = if_not_exists(pending, :zero)
            `, // Add to balance, set pending if it doesn't exist
        ExpressionAttributeValues: marshall({
          ":amount": BigInt(FAUCET_AMOUNT_BASE_UNITS), // Use BigInt for the amount
          ":zero": BigInt(0), // Use BigInt for zero
        }),
        ReturnValues: "UPDATED_NEW", // Optional: return the new balance
      })
    );

    return NextResponse.json(
        {
            success: true,
            message: `Successfully added ${parseInt(FAUCET_AMOUNT_BASE_UNITS) / 1e6} paper ${FAUCET_ASSET} to your account.`, // Format for display
            traderId: authenticatedTraderId,
            asset: FAUCET_ASSET,
            amountAdded: FAUCET_AMOUNT_BASE_UNITS
        },
        { status: 200 }
    );

  } catch (error: any) {
    console.error(`Paper Faucet Error for trader ${authenticatedTraderId}:`, error);
    // Handle potential DynamoDB errors (e.g., ProvisionedThroughputExceededException)
    return NextResponse.json({ error: "Internal server error processing faucet request." }, { status: 500 });
  }
}
### File: src/app/api/metrics/route.ts
/* app/api/metrics/route.ts
   ———————————————————————————————————————————————————————————
   Query‑string parameters
   ┌───────────────────┬─────────────────────────────┐
   │ name              │ example / default          │
   ├───────────────────┼─────────────────────────────┤
   │ market  (req¹)    │ BTC-PERP                   │
   │ type              │ intraday | daily | lifetime │
   │ from              │ 1725430800000   (ms epoch) │
   │ to                │ 1725517200000   (ms epoch) │
   └───────────────────┴─────────────────────────────┘
   ¹ `market` is required for intraday & daily. For lifetime you may omit it to get the GLOBAL row.

   Returns: JSON array (intraday/daily) or single object (lifetime)
   ——————————————————————————————————————————————————————————— */
import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBClient,
  QueryCommand,
  GetItemCommand,
} from "@aws-sdk/client-dynamodb";
import { unmarshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

/* Dynamo client (uses Lambda’s execution‑role creds) */
const ddb = new DynamoDBClient({});

/* Helpers to rebuild partition keys identical to your tables */
const pkMarket = (m: string) => `MARKET#${m}`;

/* ───────────────────────────── GET /api/metrics ─────────────────────────── */
export async function GET(req: NextRequest) {
  const url  = req.nextUrl;
  const type = url.searchParams.get("type") ?? "daily";   // default = daily
  const mkt  = url.searchParams.get("market") ?? undefined;
  const from = url.searchParams.get("from")   ?? undefined;
  const to   = url.searchParams.get("to")     ?? undefined;

  try {
    /* 1️⃣  Parameter sanity ------------------------------------------------ */
    if ((type === "intraday" || type === "daily") && !mkt) {
      return NextResponse.json(
        { error: "`market` query param is required for intraday/daily" },
        { status: 400 },
      );
    }
    if (from && isNaN(+from)) {
      return NextResponse.json({ error: "`from` must be epoch‑ms" }, { status: 400 });
    }
    if (to && isNaN(+to)) {
      return NextResponse.json({ error: "`to` must be epoch‑ms" }, { status: 400 });
    }

    /* 2️⃣  Route by `type` ------------------------------------------------- */
    switch (type) {
      /* ── intraday : 1‑min (or 5 s) buckets – 48 h retention ─────────── */
      case "intraday": {
        const fromMs = +(from ?? Date.now() - 24 * 3_600_000);     // default 24 h window
        const toMs   = +(to   ?? Date.now());

        const { Items } = await ddb.send(
          new QueryCommand({
            TableName: Resource.StatsIntradayTable.name,
            KeyConditionExpression: "pk = :pk AND sk BETWEEN :from AND :to",
            ExpressionAttributeValues: {
              ":pk":   { S: pkMarket(mkt!) },
              ":from": { S: `TS#${fromMs}` },
              ":to":   { S: `TS#${toMs}` },
            },
            ScanIndexForward: true,         // chronological asc
            ProjectionExpression:
              "sk, volume, openInterest, fees, depth1bp, depth5bp, fundingRate, impliedVol",
          }),
        );

        return NextResponse.json((Items ?? []).map(item => unmarshall(item)));
      }

      /* ── daily : YYYY‑MM‑DD rows – 12 mo retention ───────────────────── */
      case "daily": {
        const fromDay = new Date(+from || Date.now() - 30 * 86_400_000)   // 30‑d default
          .toISOString()
          .slice(0, 10);                                                  // YYYY‑MM‑DD
        const toDay = new Date(+to || Date.now())
          .toISOString()
          .slice(0, 10);

        const { Items } = await ddb.send(
          new QueryCommand({
            TableName: Resource.StatsDailyTable.name,
            KeyConditionExpression: "pk = :pk AND sk BETWEEN :from AND :to",
            ExpressionAttributeValues: {
              ":pk":   { S: pkMarket(mkt!) },
              ":from": { S: fromDay },
              ":to":   { S: toDay },
            },
            ScanIndexForward: true,
          }),
        );

        return NextResponse.json((Items ?? []).map(item => unmarshall(item)));
      }

      /* ── lifetime : single counter row ---------------------------------- */
      case "lifetime": {
        /* If market given → we treat it as a “since inception” roll‑up that
           lives in StatsLifetimeTable with pk = MARKET#XYZ; otherwise we fall
           back to the global row (KEY#GLOBAL). */
        const pk =
          mkt ? pkMarket(mkt) : "KEY#GLOBAL";
        const sk = "META";

        const { Item } = await ddb.send(
          new GetItemCommand({
            TableName: Resource.StatsLifetimeTable.name,
            Key: { pk: { S: pk }, sk: { S: sk } },
          }),
        );

        if (!Item)
          return NextResponse.json({ error: "not found" }, { status: 404 });

        return NextResponse.json(unmarshall(Item));
      }

      default:
        return NextResponse.json(
          { error: "`type` must be intraday | daily | lifetime" },
          { status: 400 },
        );
    }
  } catch (err) {
    console.error("GET /api/metrics error", err);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
### File: src/app/api/iterate/route.ts
// app/api/iterate/route.ts
import OpenAI from "openai";
import { zodResponseFormat } from "openai/helpers/zod";
import { GenResult } from "@/lib/genSchema";

const openai = new OpenAI(
  {
    apiKey: process.env.OPENAI_API_KEY,
    baseURL: '/api/v1',
  }
);

export const runtime = "edge";
export const dynamic = "force-dynamic";

export async function POST(req: Request) {
  const {
    prompt,
    screenshotBase64,
    compileErrors,
    iteration,
    cadFormat
  }: {
    prompt: string;
    screenshotBase64: string | "";
    compileErrors: string[];
    iteration: number;
    cadFormat?: boolean;
  } = await req.json();

  const systemPrompt = cadFormat 
    ? `You are an expert ReplicaCAD component generator.
       Return ONLY JSON that conforms to the schema. Focus on creating valid ReplicaCAD code.
       
       The code should:
       1. Import needed replicad functions at the top
       2. Create a 3D CAD model using ReplicaCAD APIs (draw, extrude, revolve, etc)
       3. Export the final model as default export
       
       Use features like:
       - sketch, extrude, revolve for basic shapes
       - loft, shell for advanced operations
       - fillet, chamfer for finishing touches
       - boolean operations (fuse, cut, intersect)
       
       Always write clean, well-commented code with sensible measurements.
       Return "finished": true once you've fixed all errors and the model is complete.`
    : `You are an expert React-Three-Fiber component generator. Generate a React component that renders a 3D scene or model according to the user's prompt using React-Three-Fiber and tailwind.
       You are only allowed to edit the included file, so all your code should be in the file.
       Return ONLY JSON that conforms to the schema.
       Respond with "finished": true once the task is complete.`;

  const messages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [
    {
      role: "system",
      content: `
${systemPrompt}

Return ONLY JSON that conforms to this schema:

${GenResult.toString()}

Do NOT wrap the JSON in markdown fences.`
    },
    iteration === 0
      ? { role: "user", content: prompt }
      : {
          role: "user",
          content: [
            {
              type: "text",
              text:
                compileErrors.length > 0
                  ? `❌ Build failed:\n${compileErrors.join("\n")}\nPlease fix.`
                  : "Here is a screenshot of the output. Improve it if necessary:"
            },
            ...(screenshotBase64
              ? [
                  {
                    type: "image_url",
                    image_url: { url: `data:image/png;base64,${screenshotBase64}` }
                  } as const
                ]
              : [])
          ]
        }
  ];

  const completion = await openai.beta.chat.completions.parse({
    model: "gpt-4o-mini",
    messages,
    temperature: 0.7,
    max_tokens: 800,
    response_format: zodResponseFormat(GenResult, "gen")
  });

  return Response.json(completion.choices[0].message.parsed);
}

### File: src/app/api/example/route.ts
// app/api/example/route.ts
import { NextResponse } from 'next/server';
import { NextRequest } from 'next/server';

export async function GET(request: NextRequest) {
  return NextResponse.json(
    { 
      message: 'This is a public API endpoint',
      request
    },
    {
      headers: {
        'Access-Control-Allow-Origin': '*', // Allow all domains to access
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    }
  );
}

// Handle preflight requests
export async function OPTIONS() {
  return NextResponse.json(
    {
        message: 'Hello from the OPTIONS method',
    },
    {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    }
  );
}
### File: src/app/api/providers/signup/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/providers/signup/route.ts
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  PutCommand,
  QueryCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { ProviderRecord } from "@/lib/interfaces";
import { v4 as uuidv4 } from "uuid";

/****************** 1) CREATE THE DOC CLIENT  **************************/
const rawClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(rawClient);

export async function POST(req: NextRequest) {
  try {
    // 1) Parse input
    const { email, walletAddress, walletChain } = (await req.json()) || {};

    // 2) Validate
    if (!email || !walletAddress || !walletChain) {
      return NextResponse.json(
        { error: "Missing required fields: email, walletAddress, walletChain" },
        { status: 400 }
      );
    }

    // 3) Check for existing provider with same email
    const existing = await docClient.send(
      new QueryCommand({
        TableName: Resource.ProviderTable.name,
        IndexName: "ByEmail",
        KeyConditionExpression: "providerEmail = :e",
        ExpressionAttributeValues: { ":e": email },
        Limit: 1,
      })
    );
    if (existing.Items && existing.Items.length > 0) {
      return NextResponse.json(
        { error: "Email already registered" },
        { status: 409 }
      );
    }

    // 4) Generate IDs
    const providerId = uuidv4().replace(/-/g, "");
    const providerAk = uuidv4().replace(/-/g, "");

    // 5) Build the new provider record
    const newProvider: ProviderRecord = {
      providerId,
      providerEmail: email,
      apiKey: providerAk,
      providerWalletAddress: walletAddress,
      rewards: [],
      totalRewards: 0,
    };

    // 6) Insert into the table
    await docClient.send(
      new PutCommand({
        TableName: Resource.ProviderTable.name,
        Item: newProvider,
      })
    );

    // 7) Return the newly created IDs
    return NextResponse.json(
      { providerId, apiKey: providerAk },
      { status: 200 }
    );
  } catch (err: any) {
    console.error("Error in /providers/signup route:", err);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
### File: src/app/api/providers/[providerId]/ak/reset/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// POST /api/providers/{providerId}/ak/reset
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  GetCommand,
  UpdateCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { v4 as uuidv4 } from "uuid";

const raw = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(raw);

export async function POST(
  req: NextRequest,
  { params }: { params: { providerId: string } }
) {
  const { providerId } = params;
  if (!providerId) {
    return NextResponse.json({ error: "Missing providerId" }, { status: 400 });
  }

  try {
    // 1) Fetch existing
    const get = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );
    if (!get.Item) {
      return NextResponse.json({ error: "Provider not found" }, { status: 404 });
    }

    // 2) Generate and update
    const newAk = uuidv4().replace(/-/g, "");
    await docClient.send(
      new UpdateCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
        UpdateExpression: "SET apiKey = :k",
        ExpressionAttributeValues: { ":k": newAk },
      })
    );

    return NextResponse.json({ apiKey: newAk }, { status: 200 });
  } catch (err: any) {
    console.error(err);
    return NextResponse.json({ error: "Internal error" }, { status: 500 });
  }
}
### File: src/app/api/providers/[providerId]/ak/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// GET /api/providers/{providerId}/ak
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, GetCommand } from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";

const raw = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(raw);

export async function GET(
  req: NextRequest,
  { params }: { params: { providerId: string } }
) {
  const { providerId } = params;
  if (!providerId) {
    return NextResponse.json({ error: "Missing providerId" }, { status: 400 });
  }

  try {
    const res = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );
    if (!res.Item) {
      return NextResponse.json({ error: "Provider not found" }, { status: 404 });
    }
    return NextResponse.json({ apiKey: res.Item.apiKey }, { status: 200 });
  } catch (err: any) {
    console.error(err);
    return NextResponse.json({ error: "Internal error" }, { status: 500 });
  }
}
### File: src/app/api/providers/[providerId]/[provisionId]/rerun/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/providers/[providerId]/[provisionId]/rerun/route.ts
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  GetCommand,
  UpdateCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { DeviceDiagnostics, Location } from "@/lib/interfaces";

const raw = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(raw);

/**
 * POST /api/providers/{providerId}/{provisionId}/rerun
 * Body:
 * {
 *   "deviceDiagnostics": { … },    // full DeviceDiagnostics
 *   "location"?: { … }            // optional Location update
 * }
 */
export async function POST(
  req: NextRequest,
  { params }: { params: { providerId: string; provisionId: string } }
) {
  const { providerId, provisionId } = params;
  if (!providerId || !provisionId) {
    return NextResponse.json({ error: "Missing providerId or provisionId" }, { status: 400 });
  }

  let body: any;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const { deviceDiagnostics, location } = body as {
    deviceDiagnostics?: DeviceDiagnostics;
    location?: Location;
  };

  if (!deviceDiagnostics) {
    return NextResponse.json({ error: "Missing deviceDiagnostics" }, { status: 400 });
  }

  try {
    // 1) Verify the provision exists and belongs to this provider
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId },
      })
    );
    if (!getResp.Item) {
      return NextResponse.json({ error: "Provision not found" }, { status: 404 });
    }
    if (getResp.Item.providerId !== providerId) {
      return NextResponse.json({ error: "Provision does not belong to this provider" }, { status: 403 });
    }

    // 2) Update diagnostics (and optionally location + a rerun timestamp)
    const updates: string[] = ["deviceDiagnostics = :diag", "lastRerunAt = :now"];
    const exprValues: Record<string, any> = {
      ":diag": deviceDiagnostics,
      ":now": new Date().toISOString(),
    };
    if (location) {
      updates.push("location = :loc");
      exprValues[":loc"] = location;
    }

    await docClient.send(
      new UpdateCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId },
        UpdateExpression: `SET ${updates.join(", ")}`,
        ExpressionAttributeValues: exprValues,
      })
    );

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (err: any) {
    console.error("Error in rerun route:", err);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}
### File: src/app/api/providers/[providerId]/[provisionId]/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// DELETE /api/providers/{providerId}/{provisionId}
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, DeleteCommand } from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";

const raw = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(raw);

export async function DELETE(
  req: NextRequest,
  { params }: { params: { providerId: string; provisionId: string } }
) {
  const { providerId, provisionId } = params;
  if (!providerId || !provisionId) {
    return NextResponse.json({ error: "Missing IDs" }, { status: 400 });
  }

  try {
    // Simply delete the provision
    await docClient.send(
      new DeleteCommand({
        TableName: Resource.ProvisionsTable.name,
        Key: { provisionId },
      })
    );
    return NextResponse.json({ success: true }, { status: 200 });
  } catch (err: any) {
    console.error(err);
    return NextResponse.json({ error: "Internal error" }, { status: 500 });
  }
}
### File: src/app/api/providers/[providerId]/providerAk/refresh/route.ts
import { NextResponse, NextRequest } from "next/server";
import { DynamoDBDocumentClient, UpdateCommand } from "@aws-sdk/lib-dynamodb";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { v4 as uuidv4 } from "uuid";
import { Resource } from "sst";

const doc = DynamoDBDocumentClient.from(new DynamoDBClient({}));

export async function POST(
  _req: NextRequest,
  { params }: { params: { providerId: string } },
) {
  const newAk = uuidv4().replace(/-/g, "");

  await doc.send(
    new UpdateCommand({
      TableName: Resource.ProviderTable.name,
      Key: { providerId: params.providerId },
      UpdateExpression: "SET apiKey = :a",
      ExpressionAttributeValues: { ":a": newAk },
    }),
  );

  return NextResponse.json({ providerAk: newAk });
}
### File: src/app/api/providers/[providerId]/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// DELETE /api/providers/{providerId}
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  QueryCommand,
  DeleteCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";

const raw = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(raw);

export async function DELETE(
  req: NextRequest,
  { params }: { params: { providerId: string } }
) {
  const { providerId } = params;
  if (!providerId) {
    return NextResponse.json({ error: "Missing providerId" }, { status: 400 });
  }

  try {
    // 1) Fetch all provisions belonging to this provider
    const provisions = await docClient.send(
      new QueryCommand({
        TableName: Resource.ProvisionsTable.name,
        IndexName: "ByProviderId",
        KeyConditionExpression: "providerId = :p",
        ExpressionAttributeValues: { ":p": providerId },
      })
    );

    // 2) Delete each provision record
    for (const item of provisions.Items || []) {
      await docClient.send(
        new DeleteCommand({
          TableName: Resource.ProvisionsTable.name,
          Key: { provisionId: item.provisionId },
        })
      );
    }

    // 3) Delete provider entry
    await docClient.send(
      new DeleteCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );

    // 4) TODO call out to peaq here if needed...

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (err: any) {
    console.error(err);
    return NextResponse.json({ error: "Internal error" }, { status: 500 });
  }
}
### File: src/app/api/providers/[providerId]/earnings/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// GET /api/providers/{providerId}/earnings
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, GetCommand } from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";

const raw = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(raw);

// Helper to get YYYY-MM-DD strings
function getDateStr(offsetDays = 0) {
  const d = new Date();
  d.setDate(d.getDate() - offsetDays);
  return d.toISOString().split("T")[0];
}

export async function GET(
  req: NextRequest,
  { params }: { params: { providerId: string } }
) {
  const { providerId } = params;
  if (!providerId) {
    return NextResponse.json({ error: "Missing providerId" }, { status: 400 });
  }

  try {
    const resp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );
    if (!resp.Item) {
      return NextResponse.json({ error: "Provider not found" }, { status: 404 });
    }

    // Total earnings so far
    const total = resp.Item.totalRewards ?? 0;

    // Build past 30 days earnings array
    const list = resp.Item.rewards || [];
    const earnings = Array.from({ length: 30 }).map((_, i) => {
      const day = getDateStr(i);
      const entry = list.find((r: any) => r.day === day);
      return { day, amount: entry?.amount ?? 0 };
    }).reverse();

    return NextResponse.json({ total, earnings }, { status: 200 });
  } catch (err: any) {
    console.error(err);
    return NextResponse.json({ error: "Internal error" }, { status: 500 });
  }
}
### File: src/app/api/providers/login/route.ts
// app/api/providers/login/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  QueryCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { ProviderRecord } from "@/lib/interfaces";

// instantiate a DynamoDB Document client
const rawClient = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(rawClient);

export async function POST(req: NextRequest) {
  try {
    const { email } = await req.json();

    if (!email) {
      return NextResponse.json(
        { error: "Missing required field: email" },
        { status: 400 }
      );
    }

    // Query the ProviderTable by the ByEmail GSI
    const resp = await docClient.send(
      new QueryCommand({
        TableName: Resource.ProviderTable.name,
        IndexName: "ByEmail",
        KeyConditionExpression: "providerEmail = :e",
        ExpressionAttributeValues: {
          ":e": email,
        },
        Limit: 1,
      })
    );

    if (!resp.Items || resp.Items.length === 0) {
      return NextResponse.json(
        { error: "Provider not found" },
        { status: 404 }
      );
    }

    const provider = resp.Items[0] as ProviderRecord;

    return NextResponse.json(
      { providerId: provider.providerId },
      {
        status: 200,
        headers: { "Access-Control-Allow-Origin": "*" },
      }
    );
  } catch (err: any) {
    console.error("Error in /providers/login route:", err);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
### File: src/app/api/admin/fees/route.ts
import { NextRequest, NextResponse } from "next/server";
import { ethers } from "ethers";
import {
  DynamoDBClient,
  UpdateItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { requireAdmin } from "@/lib/auth";
import { Resource } from "sst";

const {
  VAULT_ADDR,
  PEAQ_RPC_URL,
  CHAIN_ID = "3338",
  ADMIN_PK,
} = process.env;

const vaultAbi = ["function withdrawFees(address to,uint256 amt)"];

const provider = new ethers.JsonRpcProvider(PEAQ_RPC_URL!, +CHAIN_ID);
const signer   = new ethers.Wallet(ADMIN_PK!, provider);
const vault    = new ethers.Contract(VAULT_ADDR!, vaultAbi, signer);

const LIFETIME = Resource.StatsLifetimeTable.name;

/* ───────────────────────────────────────────────────────── */
export async function POST(req: NextRequest) {
  await requireAdmin();

  const { to, amt } = await req.json() as { to: string; amt: string };
  if (!ethers.isAddress(to) || !amt)
    return NextResponse.json({ error: "invalid" }, { status: 400 });

  try {
    const tx = await vault.withdrawFees(to, amt);
    await tx.wait(1);

    /* decrement outstanding fee counter (optional bookkeeping) */
    const ddb = new DynamoDBClient({});
    await ddb.send(
      new UpdateItemCommand({
        TableName: LIFETIME,
        Key: marshall({ pk: "KEY#GLOBAL", sk: "META" }),
        UpdateExpression: "ADD fees :neg",
        ExpressionAttributeValues: { ":neg": { N: "-" + amt } },
      })
    );

    return NextResponse.json({ txHash: tx.hash });
  } catch (err) {
    console.error("withdraw fees", err);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
### File: src/app/api/admin/markets/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
/* app/api/admin/markets/route.ts */
import { NextRequest, NextResponse } from "next/server";
import { ethers } from "ethers";
import {
  DynamoDBClient,
  PutItemCommand,
  UpdateItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { requireAdmin } from "@/lib/auth"; // ← your auth helper
import type { TradingMode, MarketMeta } from "@/lib/interfaces"; // Ensure TradingMode is defined
import { Resource } from "sst";

/* ─── env & contracts (Ensure these are correctly set via SST Secrets/Env) ── */
const {
  FACTORY_ADDR,
  VAULT_ADDR,
  PEAQ_RPC_URL,
  CHAIN_ID = "3338", // Default to peaq mainnet
  ADMIN_PK,          // Ensure this is securely managed (SST Secret)
} = process.env;

interface ExtendedMarketMeta extends MarketMeta {
  strike?: number;
  optionType?: "CALL" | "PUT";
}

// Basic validation for required environment variables
if (!ADMIN_PK || !PEAQ_RPC_URL || (!FACTORY_ADDR && !VAULT_ADDR)) {
    console.error("Admin Market Route Error: Missing critical environment variables (ADMIN_PK, PEAQ_RPC_URL, FACTORY_ADDR/VAULT_ADDR)");
    // Avoid throwing here during module load, handle in requests instead or log prominently
}


const factoryAbi = [
  "event SynthCreated(address indexed synth,string name,string symbol)",
  "function createSynth(string name,string symbol) returns (address)",
];
const vaultAbi = ["function registerSynth(address synth)"];

// Initialize provider and signer only if needed and env vars are present
const getSigner = () => {
    if (!ADMIN_PK || !PEAQ_RPC_URL) return null;
    try {
        const provider = new ethers.JsonRpcProvider(PEAQ_RPC_URL!, CHAIN_ID ? +CHAIN_ID : undefined);
        return new ethers.Wallet(ADMIN_PK!, provider);
    } catch (e) {
        console.error("Failed to initialize admin signer:", e);
        return null;
    }
};

const getFactory = (signer: ethers.Wallet | null) => {
    if (!signer || !FACTORY_ADDR) return null;
    return new ethers.Contract(FACTORY_ADDR, factoryAbi, signer);
};

const getVault = (signer: ethers.Wallet | null) => {
    if (!signer || !VAULT_ADDR) return null;
    return new ethers.Contract(VAULT_ADDR, vaultAbi, signer);
};


const ddb = new DynamoDBClient({});
const MARKETS_TABLE = Resource.MarketsTable.name;

/**
 * Helper: derive PK for Markets table
 * NEW: Incorporates trading mode.
 */
const pkMarketMode = (market: string, mode: TradingMode) =>
  `MARKET#${market}#${mode.toUpperCase()}`;

/* ——————————————————————— POST = create market ————————————————————————— */
export async function POST(req: NextRequest) {
  const admin = await requireAdmin(); // throws if not admin

  try {
    const body = (await req.json()) as Partial<ExtendedMarketMeta> & { mode: TradingMode };

    // --- Paper Trading Validation ---
    if (!body.mode || (body.mode !== "REAL" && body.mode !== "PAPER")) {
        return NextResponse.json(
            { error: "invalid or missing 'mode' (REAL or PAPER)" },
            { status: 400 }
        );
    }
    const mode = body.mode;
    // --- End Paper Trading Validation ---

    const {
      symbol,
      type,
      tickSize,
      lotSize,
      fundingIntervalSec, // optional
      expiryTs,           // optional (future / option)
      strike,             // optional (option)
      optionType          // optional (option)
    } = body;


    if (!symbol || !type || tickSize === undefined || lotSize === undefined)
      return NextResponse.json({ error: "invalid market payload" }, { status: 400 });

    let synthAddr: string | null = null; // Synth address only relevant for REAL mode
    let txHash: string | null = null;    // Transaction hash only for REAL mode

    // --- Conditional Blockchain Interaction ---
    if (mode === "REAL") {
        const signer = getSigner();
        const factory = getFactory(signer);
        const vault = getVault(signer);

        if (!signer || !factory || !vault || !FACTORY_ADDR || !VAULT_ADDR) {
            console.error("Admin Create Market Error: Missing signer/contracts for REAL mode interaction.");
            return NextResponse.json({ error: "server configuration error for REAL mode" }, { status: 500 });
        }

        /* 1️⃣ Deploy synth via Factory (deterministic CREATE2) */
        const asset = symbol.split("-")[0]; // e.g., "SOL"
        const synthName = `Synthetic ${asset}`;
        const synthSymbol = `s${asset.toUpperCase()}`; // Convention: sBTC, sETH

        console.log(`Creating REAL Synth: ${synthName} (${synthSymbol})`);
        const tx = await factory.createSynth(synthName, synthSymbol);
        txHash = tx.hash;
        console.log(`Tx submitted: ${txHash}, waiting for confirmation...`);
        const rcpt = await tx.wait(1); // Wait for 1 confirmation

        // Find the SynthCreated event log to get the deployed address
        const createdEvent = rcpt.logs
            ?.map((l: any) => { try { return factory.interface.parseLog(l); } catch { return null; } })
            .find((l: any) => l?.name === "SynthCreated");

        if (!createdEvent?.args?.synth) {
            console.error("Failed to find SynthCreated event in transaction receipt", rcpt);
            throw new Error("Synth creation failed: could not parse synth address from logs.");
        }
        synthAddr = createdEvent.args.synth as string;
        console.log(`Synth Deployed: ${synthAddr}`);


        /* 2️⃣ Vault whitelist the new synth address */
        console.log(`Registering Synth ${synthAddr} with Vault ${VAULT_ADDR}`);
        const registerTx = await vault.registerSynth(synthAddr);
        await registerTx.wait(1); // Wait for confirmation
        console.log(`Synth registered with Vault.`);
    } else {
        console.log(`Skipping blockchain interaction for PAPER market: ${symbol}`);
        // For PAPER mode, synthAddr remains null or you could use a placeholder if needed downstream
    }
    // --- End Conditional Blockchain Interaction ---

    /* 3️⃣ Insert Markets row (status = PAUSED until unpaused explicitly) */
    const pk = pkMarketMode(symbol, mode);
    const marketItem = {
        pk: pk,
        sk: "META",
        symbol,
        type,
        status: "PAUSED", // Always start paused
        tickSize,
        lotSize,
        fundingIntervalSec,
        expiryTs,
        strike,
        optionType,
        synth: synthAddr, // Will be null for PAPER mode
        createdAt: Date.now(),
        createdBy: admin.properties.email, // Or admin ID
        mode: mode, // Store mode explicitly as an attribute too
    };

    console.log(`Writing ${mode} market to DynamoDB: ${pk}`);
    await ddb.send(
      new PutItemCommand({
        TableName: MARKETS_TABLE,
        Item: marshall(marketItem, { removeUndefinedValues: true }),
        ConditionExpression: "attribute_not_exists(pk)", // Prevent overwriting
      })
    );

    return NextResponse.json(
        { symbol, mode, synthAddr, txHash, status: "PAUSED" }, // Return relevant info
        { status: 201 }
    );

  } catch (err: any) {
    if (err?.name === "ConditionalCheckFailedException") {
        return NextResponse.json({ error: `market ${err.message?.includes('pk') ? 'already exists' : 'creation conflict'}` }, { status: 409 });
    }
    console.error("Admin Create Market Error:", err);
    // Check for common ethers errors (e.g., insufficient funds, network issues)
     if (err.code) { // Ethers errors often have codes
       return NextResponse.json({ error: `Blockchain interaction failed: ${err.reason || err.code}` }, { status: 502 }); // Bad Gateway/Upstream Error
     }
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}

/* ——————————————————————— PATCH = pause / unpause —————————————————————— */
export async function PATCH(req: NextRequest) {
  await requireAdmin();

  const { symbol, action, mode } = (await req.json()) as {
    symbol: string;
    action: "PAUSE" | "UNPAUSE";
    mode: TradingMode; // Expect mode
  };

  // --- Validation ---
  if (!symbol || !action || !mode || (mode !== "REAL" && mode !== "PAPER")) {
    return NextResponse.json({ error: "bad request: requires symbol, action (PAUSE/UNPAUSE), and mode (REAL/PAPER)" }, { status: 400 });
  }
  // --- End Validation ---

  try {
    const pk = pkMarketMode(symbol, mode); // Construct mode-specific PK
    const newStatus = action === "PAUSE" ? "PAUSED" : "ACTIVE";

    console.log(`Admin PATCH: Setting market ${pk} status to ${newStatus}`);
    await ddb.send(
      new UpdateItemCommand({
        TableName: MARKETS_TABLE,
        Key: marshall({ pk: pk, sk: "META" }),
        UpdateExpression: "SET #s = :st",
        ConditionExpression: "attribute_exists(pk)", // Ensure market exists
        ExpressionAttributeNames: { "#s": "status" },
        ExpressionAttributeValues: marshall({ ":st": newStatus }),
      })
    );
    return NextResponse.json({ ok: true, symbol, mode, status: newStatus });
  } catch (err: any) {
     if (err?.name === "ConditionalCheckFailedException") {
        return NextResponse.json({ error: `market not found for symbol '${symbol}' and mode '${mode}'` }, { status: 404 });
    }
    console.error(`Admin Pause/Unpause Error for ${symbol} (${mode}):`, err);
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}

/* ——————————————————————— DELETE = delist market ——————————————————————— */
// Note: Delisting usually means setting status=DELISTED, not physically deleting.
// Actual deletion might orphan data unless carefully managed.
export async function DELETE(req: NextRequest) {
  await requireAdmin();

  const { symbol, mode } = (await req.json()) as {
      symbol: string;
      mode: TradingMode; // Expect mode
  };

  // --- Validation ---
   if (!symbol || !mode || (mode !== "REAL" && mode !== "PAPER")) {
    return NextResponse.json({ error: "bad request: requires symbol and mode (REAL/PAPER)" }, { status: 400 });
  }
  // --- End Validation ---


  try {
    const pk = pkMarketMode(symbol, mode); // Construct mode-specific PK
    const newStatus = "DELISTED";

    console.log(`Admin DELETE (Delist): Setting market ${pk} status to ${newStatus}`);
    await ddb.send(
      new UpdateItemCommand({
        TableName: MARKETS_TABLE,
        Key: marshall({ pk: pk, sk: "META" }),
        UpdateExpression: "SET #s = :del",
         ConditionExpression: "attribute_exists(pk)", // Ensure market exists
        ExpressionAttributeNames: { "#s": "status" },
        ExpressionAttributeValues: marshall({ ":del": newStatus }),
      })
    );
    return NextResponse.json({ ok: true, symbol, mode, status: newStatus });
  } catch (err: any) {
     if (err?.name === "ConditionalCheckFailedException") {
        return NextResponse.json({ error: `market not found for symbol '${symbol}' and mode '${mode}'` }, { status: 404 });
    }
    console.error(`Admin Delist Error for ${symbol} (${mode}):`, err);
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}
### File: src/app/api/user/[userId]/userAk/refresh/route.ts
import { NextResponse, NextRequest } from "next/server";
import { DynamoDBDocumentClient, UpdateCommand } from "@aws-sdk/lib-dynamodb";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { v4 as uuidv4 } from "uuid";
import { Resource } from "sst";

const doc = DynamoDBDocumentClient.from(new DynamoDBClient({}));
const table = Resource.UserTable.name;

export async function POST(
  _req: NextRequest,
  { params }: { params: { userId: string } },
) {
  const newAk = uuidv4().replace(/-/g, "");

  await doc.send(
    new UpdateCommand({
      TableName: table,
      Key: { userId: params.userId },
      UpdateExpression: "SET userAk = :a",
      ExpressionAttributeValues: { ":a": newAk },
    }),
  );

  return NextResponse.json({ userAk: newAk });
}
### File: src/app/api/user/[userId]/keys/[key]/route.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBDocumentClient,
  UpdateCommand,
  GetCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";

const doc = DynamoDBDocumentClient.from(new DynamoDBClient({}));
const table = Resource.UserTable.name;

export async function DELETE(
  _req: NextRequest,
  { params }: { params: { userId: string; key: string } },
) {
  const { userId, key } = params;

  // fetch existing list
  const res = await doc.send(new GetCommand({ TableName: table, Key: { userId } }));
  const list = res.Item?.apiKeys ?? [];
  const filtered = list.filter((k: any) => k.key !== key);

  await doc.send(
    new UpdateCommand({
      TableName: table,
      Key: { userId },
      UpdateExpression: "SET apiKeys = :f",
      ExpressionAttributeValues: { ":f": filtered },
    }),
  );

  return NextResponse.json({ ok: true });
}

### File: src/app/api/user/[userId]/keys/route.ts
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  UpdateCommand,
  GetCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { v4 as uuidv4 } from "uuid";

const doc = DynamoDBDocumentClient.from(new DynamoDBClient({}));
const table = Resource.UserTable.name;

export async function GET(
  _req: NextRequest,
  { params }: { params: { userId: string } },
) {
  const { userId } = params;
  const res = await doc.send(new GetCommand({ TableName: table, Key: { userId } }));
  return NextResponse.json(res.Item?.apiKeys ?? []);
}

export async function POST(req: NextRequest, { params }: { params: { userId: string } }) {
  const { userId } = params;
  const body = await req.json();

  const newKey = {
    key: uuidv4().replace(/-/g, ""),
    creditLimit: body.creditLimit ?? 10000,
    creditsLeft: body.creditLimit ?? 10000,
    permittedRoutes: body.permittedRoutes ?? ["/chat/completions"],
  };

  await doc.send(
    new UpdateCommand({
      TableName: table,
      Key: { userId },
      UpdateExpression: "SET apiKeys = list_append(if_not_exists(apiKeys, :e), :n)",
      ExpressionAttributeValues: { ":e": [], ":n": [newKey] },
    }),
  );

  return NextResponse.json(newKey, { status: 201 });
}
### File: src/app/api/user/[userId]/summary/route.ts
import { NextRequest, NextResponse } from "next/server";
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { DynamoDBDocumentClient, GetCommand } from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";

const raw = new DynamoDBClient({});
const doc = DynamoDBDocumentClient.from(raw);

export async function GET(
  _req: NextRequest,
  { params }: { params: { userId: string } },
) {
  const { userId } = params;

  const res = await doc.send(
    new GetCommand({
      TableName: Resource.UserTable.name,
      Key: { userId },
    }),
  );

  if (!res.Item)
    return NextResponse.json({ error: "User not found" }, { status: 404 });

  return NextResponse.json(
    {
      apiKeys: res.Item.apiKeys ?? [],
      credits: res.Item.credits ?? 0,
      rewards: res.Item.totalRewards ?? 0,
    },
    { status: 200 },
  );
}
### File: src/app/api/positions/route.ts
/* app/api/positions/route.ts */
import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBClient,
  QueryCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import type { TradingMode, Position } from "@/lib/interfaces"; // Ensure TradingMode is defined
import { Resource } from "sst";

const POSITIONS_TABLE = Resource.PositionsTable.name;
const ddb = new DynamoDBClient({});

/**
 * Helper: derive PK for Positions/Balances tables
 * NEW: Incorporates trading mode.
 */
const pkTraderMode = (traderId: string, mode: TradingMode) =>
  `TRADER#${traderId}#${mode.toUpperCase()}`;

/* ————————————————————————————— GET /positions ——————————————————————————— */
export async function GET(req: NextRequest) {
  const traderId = req.nextUrl.searchParams.get("traderId") ?? undefined;
  const modeParam = req.nextUrl.searchParams.get("mode") ?? undefined;
  const market = req.nextUrl.searchParams.get("market") ?? undefined; // Optional: filter by market

  // --- Validation ---
  if (!traderId) {
    return NextResponse.json(
      { error: "query parameter 'traderId' is required" },
      { status: 400 }
    );
  }
  if (!modeParam || (modeParam !== "REAL" && modeParam !== "PAPER")) {
    return NextResponse.json(
      { error: "query parameter 'mode' (REAL or PAPER) is required" },
      { status: 400 }
    );
  }
  const mode = modeParam as TradingMode;
  // --- End Validation ---

  try {
    // Construct the primary key for the query
    const pk = pkTraderMode(traderId, mode);

    // Determine KeyConditionExpression based on whether market filter is applied
    let keyCondition = "pk = :pk";
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const expressionValues: Record<string, any> = { ":pk": pk }; // Use any type for flexibility

    if (market) {
      keyCondition += " AND begins_with(sk, :marketPrefix)";
      expressionValues[":marketPrefix"] = `MARKET#${market}`; // Filter by market symbol if provided
    }

    const resp = await ddb.send(
      new QueryCommand({
        TableName: POSITIONS_TABLE,
        KeyConditionExpression: keyCondition,
        ExpressionAttributeValues: marshall(expressionValues),
        // Add FilterExpression if you want to exclude zero positions, e.g., "size <> :zero"
        // FilterExpression: "size <> :zero",
        // ExpressionAttributeValues: marshall({ ...expressionValues, ":zero": 0 }),
      })
    );

    const positions = (resp.Items ?? []).map((item) => unmarshall(item) as Position);

    return NextResponse.json(positions);

  } catch (err) {
    console.error("GET /positions error", err);
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}
### File: src/app/api/callback/route.ts
import { client, setTokens } from "../../auth"
import { type NextRequest, NextResponse } from "next/server"

export async function GET(req: NextRequest) {
  const url = new URL(req.url)
  const code = url.searchParams.get("code")

  const exchanged = await client.exchange(code!, `${url.origin}/api/callback`)

  if (exchanged.err) return NextResponse.json(exchanged.err, { status: 400 })

  await setTokens(exchanged.tokens.access, exchanged.tokens.refresh)

  return NextResponse.redirect(`${url.origin}/dashboard`)
}
### File: src/app/api/orders/[orderId]/route.ts
/* app/api/orders/[orderId]/route.ts */
import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBClient,
  QueryCommand,
  UpdateItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import type { Order } from "@/lib/interfaces"; // Assuming TradingMode is defined
import { Resource } from "sst";

const ORDERS_TABLE = Resource.OrdersTable.name;
const ddb = new DynamoDBClient({});

// PK helper is not strictly needed here as we get the full PK from the GSI lookup

/* ————————————————————————————— GET /orders/:orderId —————————————————————— */
export async function GET(
  _req: NextRequest,
  { params }: { params: { orderId: string } }
) {
  try {
    const { Items } = await ddb.send(
      new QueryCommand({
        TableName: ORDERS_TABLE,
        IndexName: "ByOrderId", // Use the GSI to find the order by its unique ID
        KeyConditionExpression: "orderId = :id",
        ExpressionAttributeValues: marshall({ ":id": params.orderId }),
        Limit: 1,
      })
    );

    if (!Items || Items.length === 0) {
      return NextResponse.json({ error: "order not found" }, { status: 404 });
    }
    // The item contains the full original data including the mode-partitioned PK
    return NextResponse.json(unmarshall(Items[0]));
  } catch (err) {
    console.error("GET /orders/:id error", err);
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}

/* ————————————————————————— DELETE /orders/:orderId (cancel) ——————————————— */
export async function DELETE(
  _req: NextRequest,
  { params }: { params: { orderId: string } }
) {
  const orderId = params.orderId;

  try {
    /* 1. Look up via the GSI to get the full PK/SK + status */
    const { Items } = await ddb.send(
      new QueryCommand({
        TableName: ORDERS_TABLE,
        IndexName: "ByOrderId",
        KeyConditionExpression: "orderId = :id",
        ExpressionAttributeValues: marshall({ ":id": orderId }),
        // ProjectionExpression: "pk, sk, #s", // Project only needed fields
        // ExpressionAttributeNames: { "#s": "status" },
        Limit: 1,
      })
    );

    if (!Items || Items.length === 0) {
      return NextResponse.json({ error: "order not found" }, { status: 404 });
    }

    // Unmarshall the full item to get pk, sk, and status
    const order = unmarshall(Items[0]) as Order & { pk: string }; // Need pk and sk from the item

    if (!order.pk || !order.sk) {
        console.error("Error fetching order details for cancellation: Missing pk or sk", order);
        return NextResponse.json({ error: "internal error fetching order details" }, { status: 500 });
    }


    // Check current status before attempting cancellation
    if (order.status !== "OPEN" && order.status !== "PARTIAL") {
      return NextResponse.json(
        { error: `cannot cancel order in status: ${order.status}` },
        { status: 400 } // Bad request - can't cancel completed/cancelled order
      );
    }

    /* 2. Atomic status flip using the retrieved PK and SK */
    await ddb.send(
      new UpdateItemCommand({
        TableName: ORDERS_TABLE,
        Key: marshall({ pk: order.pk, sk: order.sk }), // Use the exact PK/SK from the lookup
        ConditionExpression: "#s IN (:open, :partial)", // Ensure it's still cancellable
        UpdateExpression: "SET #s = :cancelled",
        ExpressionAttributeNames: { "#s": "status" },
        ExpressionAttributeValues: marshall({
          ":open": "OPEN",
          ":partial": "PARTIAL",
          ":cancelled": "CANCELLED",
        }),
      })
    );

    return NextResponse.json({ ok: true, message: `Order ${orderId} cancelled.` });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    if (err?.name === "ConditionalCheckFailedException") {
      // This means the status changed between the read (Query) and the write (Update)
      return NextResponse.json(
        { error: "order status changed during cancellation attempt (likely already filled/cancelled)" },
        { status: 409 } // Conflict
      );
    }
    console.error("DELETE /orders/:id error", err);
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}
### File: src/app/api/orders/route.ts
/* app/api/orders/route.ts */
import { NextRequest, NextResponse } from "next/server";
import {
  DynamoDBClient,
  PutItemCommand,
  QueryCommand,
  UpdateItemCommand, // Import UpdateItemCommand
} from "@aws-sdk/client-dynamodb";
import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
import { v4 as uuidv4 } from "uuid";
import type {
  LimitOrder,
  MarketOrder,
  OptionOrder,
  Order,
  TradingMode,
} from "@/lib/interfaces";
import { Resource } from "sst";

/* --- constants ---------------------------------------------------- */
const ORDERS_TABLE = Resource.OrdersTable.name;
const TRADERS_TABLE = Resource.TradersTable.name; // Added Traders table name

const ddb = new DynamoDBClient({});

/**
 * Helper: derive PK for Orders/Trades/Markets/Stats tables
 * NEW: Incorporates trading mode.
 */
const pkMarketMode = (market: string, mode: TradingMode) =>
  `MARKET#${market}#${mode.toUpperCase()}`;

/**
 * Helper: derive PK for Traders/Balances table based on mode
 */
const pkTraderMode = (traderId: string, mode: TradingMode) =>
  `TRADER#${traderId}#${mode.toUpperCase()}`;


/* ————————————————————————————————— POST /orders (create) ———————————————— */
export async function POST(req: NextRequest) {
  try {
    const now = Date.now();
    // Explicitly type the body to include mode
    const body = (await req.json()) as Partial<Order> & { mode?: TradingMode };
    const orderId = body.orderId ?? uuidv4().replace(/-/g, "");
    const sk = `TS#${orderId}`;

    // --- Paper Trading Validation ---
    if (!body.mode || (body.mode !== "REAL" && body.mode !== "PAPER")) {
      return NextResponse.json(
        { error: "invalid or missing 'mode' (REAL or PAPER)" },
        { status: 400 }
      );
    }
    const mode = body.mode; // Validated mode
    // --- End Paper Trading Validation ---

    // Rudimentary validation
    if (
      !body.traderId ||
      !body.orderType ||
      !body.market ||
      !body.side ||
      !body.qty ||
      body.qty <= 0
    ) {
      return NextResponse.json(
        { error: "invalid payload: missing required fields" },
        { status: 400 }
      );
    }

    // Price validation
    if (
      body.orderType !== "MARKET" &&
      (body.price === undefined || body.price <= 0)
    ) {
      return NextResponse.json(
        { error: "price required for non-market orders" },
        { status: 400 }
      );
    }

    // Prepare the base order object
    let order: Order;

    switch (body.orderType) {
      case "MARKET":
        order = {
          ...body,
          orderId,
          sk,
          traderId: body.traderId,
          orderType: "MARKET",
          market: body.market,
          side: body.side,
          qty: body.qty,
          filledQty: 0,
          createdAt: now,
          status: "OPEN",
          feeBps: 100,
        } as MarketOrder;
        break;
      case "LIMIT":
        order = {
          ...body,
          orderId,
          sk,
          traderId: body.traderId,
          orderType: "LIMIT",
          market: body.market,
          side: body.side,
          qty: body.qty,
          price: body.price,
          filledQty: 0,
          createdAt: now,
          status: "OPEN",
          feeBps: 100,
        } as LimitOrder;
        break;
      case "OPTION":
        order = {
          ...body,
          orderId,
          sk,
          traderId: body.traderId,
          orderType: "OPTION",
          market: body.market,
          side: body.side,
          qty: body.qty,
          price: body.price,
          strike: body.strike,
          expiryTs: body.expiryTs,
          optionType: body.optionType,
          filledQty: 0,
          createdAt: now,
          status: "OPEN",
          feeBps: 100,
        } as OptionOrder;
        break;
      // Add cases for other order types
      default:
        throw new Error(`Invalid order type: ${body.orderType}`);
    }

    // Construct the primary key including the mode
    const pk = pkMarketMode(order.market, mode);

    // --- Save the Order to DynamoDB ---
    await ddb.send(
      new PutItemCommand({
        TableName: ORDERS_TABLE,
        Item: marshall(
          {
            pk: pk, // Use the mode-partitioned PK
            ...order,
            // Explicitly add mode if you want it as a top-level attribute
            mode: mode,
          },
          { removeUndefinedValues: true }
        ),
        ConditionExpression: "attribute_not_exists(pk) AND attribute_not_exists(sk)",
      })
    );

    // --- Award Paper Points for Placing a Limit Order ---
    if (mode === "PAPER" && order.orderType === "LIMIT") {
      try {
        const pointsToAwardStr = Resource.PaperPointsLimitOrder.value ?? "1"; // Get value from secret, default to "1"
        const pointsToAward = parseInt(pointsToAwardStr, 10);

        if (!isNaN(pointsToAward) && pointsToAward > 0) {
            const traderPk = pkTraderMode(order.traderId, "PAPER"); // Target the PAPER record for the trader
            const traderSk = "META"; // Assuming sort key for trader main data is META

            console.log(`Awarding ${pointsToAward} paper points to ${traderPk} for placing limit order ${orderId}`);

            await ddb.send(
              new UpdateItemCommand({
                TableName: TRADERS_TABLE,
                Key: marshall({ pk: traderPk, sk: traderSk }),
                // Update expression:
                // - Sets paperPoints.epoch to 1 if paperPoints OR paperPoints.epoch doesn't exist.
                // - Adds pointsToAward to paperPoints.totalPoints. ADD handles non-existent number by starting from 0.
                UpdateExpression: `
                        SET paperPoints.epoch = if_not_exists(paperPoints.epoch, :initEpoch)
                        ADD paperPoints.totalPoints :points
                    `,
                ExpressionAttributeValues: marshall({
                  ":points": pointsToAward,
                  ":initEpoch": 1, // Initial epoch number
                }),
              })
            );
        } else {
             console.warn(`Invalid point value configured for PaperPointsLimitOrder: ${pointsToAwardStr}. Skipping point award for order ${orderId}.`);
        }
      } catch (pointError) {
        // Log error but don't fail the order placement itself
        console.error(`Failed to award paper points for limit order ${orderId}:`, pointError);
      }
    }
    // --- End Points Award Logic ---

    // Return the created order object
    return NextResponse.json({ ...order, pk }, { status: 201 });
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (err: any) {
    if (err?.name === "ConditionalCheckFailedException") {
      return NextResponse.json(
        { error: "order creation conflict (possible duplicate)" },
        { status: 409 }
      );
    }
    console.error("POST /orders error:", err);
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}


/* ————————————————————————————————— GET /orders (list) ————————————————— */
export async function GET(req: NextRequest) {
  const traderId = req.nextUrl.searchParams.get("traderId") ?? undefined;
  const market = req.nextUrl.searchParams.get("market") ?? undefined;
  const status = req.nextUrl.searchParams.get("status") ?? undefined;
  const modeParam = req.nextUrl.searchParams.get("mode") ?? undefined; // Get mode from query

  // --- Mode Validation ---
  if (!modeParam || (modeParam !== "REAL" && modeParam !== "PAPER")) {
    return NextResponse.json(
      { error: "query parameter 'mode' (REAL or PAPER) is required" },
      { status: 400 }
    );
  }
  const mode = modeParam as TradingMode;
  // --- End Validation ---

  try {
    // --- Query by trader (using ByTraderMode GSI) ---
    if (traderId) {
        // Construct the GSI range key prefix (which is the original PK)
        // If market is provided, filter more specifically.
        const pkPrefix = market ? pkMarketMode(market, mode) : `MARKET#`; // Filter by market-mode prefix

        const resp = await ddb.send(
          new QueryCommand({
            TableName: ORDERS_TABLE,
            IndexName: "ByTraderMode", // GSI: PK=traderId, SK=pk (original PK)
            KeyConditionExpression: "traderId = :t AND begins_with(pk, :pkPrefix)", // Query GSI PK, Filter GSI SK
            FilterExpression: status ? "#s = :st" : undefined, // Optional status filter
            ExpressionAttributeNames: status ? { "#s": "status" } : undefined,
            ExpressionAttributeValues: marshall({
              ":t": traderId,
              ":pkPrefix": pkPrefix, // Filter SK based on market/mode
              ...(status ? { ":st": status } : {}),
            }),
            // Consider adding ScanIndexForward: false for most recent orders first
          })
        );
        const items = (resp.Items ?? []).map((it) => unmarshall(it));
        return NextResponse.json(items);
    }

    // --- Query by market (using primary index) ---
    if (!market) {
      // If not querying by traderId, market becomes required for primary index query
      return NextResponse.json(
        { error: "query parameter 'market' is required when not filtering by 'traderId'" },
        { status: 400 }
      );
    }

    // Construct the full primary key for the market and mode
    const pk = pkMarketMode(market, mode);

    const resp = await ddb.send(
      new QueryCommand({
        TableName: ORDERS_TABLE,
        KeyConditionExpression: "pk = :pk", // Query by the exact market-mode PK
        FilterExpression: status ? "#s = :st" : undefined, // Optional status filter
        ExpressionAttributeNames: status ? { "#s": "status" } : undefined,
        ExpressionAttributeValues: marshall({
          ":pk": pk,
          ...(status ? { ":st": status } : {}),
        }),
         // Consider adding ScanIndexForward: false for most recent orders first
      })
    );
    const items = (resp.Items ?? []).map((it) => unmarshall(it));
    return NextResponse.json(items);

  } catch (err) {
    console.error("GET /orders error:", err);
    return NextResponse.json({ error: "internal server error" }, { status: 500 });
  }
}
### File: src/app/api/vault/deposit/route.ts
import { NextRequest, NextResponse } from "next/server";
import { ethers } from "ethers";
import {
  DynamoDBClient,
  UpdateItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";

/* ─── env single‑source‑of‑truth ─────────────────────── */
const {
  PEAQ_RPC_URL,            // e.g. `https://peaq.api.onfinality.io/public`
  VAULT_ADDR,              // deployed Vault address
  USDC_ADDR,               // bridged USDC (ERC‑20) on peaq
  SERVER_PK,               // hot wallet that pays gas (use test key on agung)
  CHAIN_ID = "3338",       // 3338 = peaq mainnet, 9990 = agung testnet
} = process.env;

/* minimal ABIs – only the functions we call */
const vaultAbi = ["function deposit(uint256 amt)"];
const erc20Abi = [
  "function allowance(address owner,address spender) view returns (uint256)",
  "function approve(address spender,uint256 amt) returns (bool)",
];

const ddb = new DynamoDBClient({});
const TABLE = Resource.BalancesTable.name;

/* ──────────────────────────────────────────────────────── */
export async function POST(req: NextRequest) {
  try {
    const { traderId, amt, permit } = (await req.json()) as {
      traderId: string;
      amt: string;                     /* raw units string, e.g. "1000000" */
      /* optional EIP‑2612 permit {v,r,s,deadline} passed from front‑end */
      permit?: { v: number; r: string; s: string; deadline: string };
    };

    if (!traderId || !amt) {
      return NextResponse.json(
        { error: "traderId & amt required" },
        { status: 400 }
      );
    }

    /* signer pays gas; vault pulls funds from trader wallet */
    const provider = new ethers.JsonRpcProvider(PEAQ_RPC_URL, +CHAIN_ID);
    const signer   = new ethers.Wallet(SERVER_PK!, provider);

    /* 1️⃣  (optional) record permit if supplied */
    const usdc  = new ethers.Contract(USDC_ADDR!, erc20Abi, provider);
    if (permit) {
      /* front‑end already called permit() in USDC; nothing to do here */
    } else {
      /* fail fast if allowance is 0 – user forgot to approve */
      const allowance = await usdc.allowance(traderId, VAULT_ADDR);
      if (allowance < BigInt(amt)) {
        return NextResponse.json(
          { error: "USDC allowance insufficient" },
          { status: 402 }
        );
      }
    }

    /* 2️⃣  craft & broadcast tx */
    const vault = new ethers.Contract(VAULT_ADDR!, vaultAbi, signer);
    const tx    = await vault.deposit(amt);
    await tx.wait(1);                                      // 1 confirmation

    /* 3️⃣ optimistically bump Balances table (chain listener will confirm) */
    await ddb.send(
      new UpdateItemCommand({
        TableName: TABLE,
        Key: marshall({ traderId, asset: "USDC" }),
        UpdateExpression: "ADD balance :b",
        ExpressionAttributeValues: { ":b": { N: amt } },
      })
    );

    return NextResponse.json({ txHash: tx.hash });
  } catch (err) {
    console.error("deposit error", err);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
### File: src/app/api/vault/withdraw/route.ts
import { NextRequest, NextResponse } from "next/server";
import { ethers } from "ethers";
import {
  DynamoDBClient,
  UpdateItemCommand,
} from "@aws-sdk/client-dynamodb";
import { marshall } from "@aws-sdk/util-dynamodb";
import { Resource } from "sst";

const {
  PEAQ_RPC_URL,
  VAULT_ADDR,
  SERVER_PK,
  CHAIN_ID = "3338",
} = process.env;

const vaultAbi = ["function withdraw(uint256 amt,bool asCxpt)"];

const ddb   = new DynamoDBClient({});
const TABLE = Resource.BalancesTable.name;

/* ──────────────────────────────────────────────────────── */
export async function POST(req: NextRequest) {
  try {
    const { traderId, amt, asCxpt = false } = (await req.json()) as {
      traderId: string;
      amt: string;        /* raw units */
      asCxpt?: boolean;
    };

    if (!traderId || !amt) {
      return NextResponse.json(
        { error: "traderId & amt required" },
        { status: 400 }
      );
    }

    const provider = new ethers.JsonRpcProvider(PEAQ_RPC_URL, +CHAIN_ID);
    const signer   = new ethers.Wallet(SERVER_PK!, provider);
    const vault    = new ethers.Contract(VAULT_ADDR!, vaultAbi, signer);

    const tx = await vault.withdraw(amt, asCxpt);
    await tx.wait(1);

    /* optimistically subtract – listener will reconcile */
    await ddb.send(
      new UpdateItemCommand({
        TableName: TABLE,
        Key: marshall({ traderId, asset: asCxpt ? "CXPT" : "USDC" }),
        UpdateExpression: "ADD balance :neg",
        ExpressionAttributeValues: { ":neg": { N: "-" + amt } },
      })
    );

    return NextResponse.json({ txHash: tx.hash });
  } catch (err) {
    console.error("withdraw error", err);
    return NextResponse.json({ error: "internal" }, { status: 500 });
  }
}
### File: src/app/maximize/page.module.css
.main{
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    padding: 32px;
    font-family: var(--font-roboto);
}

.docWrapper{
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 24px;
    margin-top: 20px;
    margin-bottom: 20px;
    padding: 32px;
}

.docWrapper h1{
    background-color: #f8cb46;
    border: 6px solid #000;
    border-radius: 20px;
    box-shadow: 12px 12px 0 #000;
    padding: 20px;
    transition: all 0.3s ease-in-out;
    margin-bottom: 48px;
}

/* .docWrapper h1:hover{
    transform: translate(-5px, -5px);
    box-shadow: 17px 17px 0 #000;
} */

.docWrapper h2{
    background-color: #91a8eb;
    border: 6px solid #000;
    border-radius: 10px;
    box-shadow: 6px 6px 0 #000;
    padding: 10px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

.docWrapper h2:hover{
    transform: translate(-5px, -5px);
    box-shadow: 8px 8px 0 #000;
}

.docWrapper h3{
    background-color: #fe91e8;
    border: 3px solid #000;
    border-radius: 5px;
    box-shadow: 6px 6px 0 #000;
    padding: 5px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

### File: src/app/maximize/page.tsx
import Button from "@/components/button/button";
import styles from "./page.module.css";
import Link from "next/link";

export default function Maximizing() {
  return (
    <main className={styles.main}>
      <div className={styles.docWrapper}>
        <h1>Maximizing Your Earnings as a Cxmpute Provider</h1>
        <p>
          Ready to boost your earnings on the Cxmpute network? Whether you’re just starting out or already part of our growing community, here are some quick tips to help you maximize your rewards and make the most of your idle compute power.
        </p>
        <h2>Get Started Now</h2>
        <p>
          The first step is simple: install the Cxmpute provider app and get mining as soon as possible. The more you mine, the more rewards you earn. Don’t wait—every minute counts in turning idle cycles into real income.
        </p>
        <p>
          <em>Tip: The earlier you join, the more mining time you get, and that means more rewards in your pocket.</em>
        </p>
        <h2>Build Your Network and Reputation</h2>
        <p>
          Cxmpute isn’t just about individual contributions—it’s a community. Invite others to join and build your social network. As you participate longer, your reputation grows, which plays a crucial role in our ecosystem.
        </p>
        <p>
          <em>Tip: Think of your reputation as a multiplier. The more trusted you become, the higher your mining rate and rewards.</em>
        </p>
        <h2>Stake Your $CXPT Token</h2>
        <p>
          While completely optional, buying and staking the $CXPT token can further boost your reputation on the network. This extra step not only reinforces your commitment but also increases your overall rewards by enhancing your mining multiplier.
        </p>
        <p>
          <em>Tip: Consider staking $CXPT as an investment in your long-term earning potential. The higher your reputation, the greater your mining efficiency and rewards.</em>
        </p>
        <h2>Reputation: Your Key Multiplier</h2>
        <p>
          At the core of our network, reputation acts as a powerful multiplier for your mining rate. Every action—mining, inviting peers, and staking tokens—contributes to a higher reputation score, ensuring that your contributions are rewarded more generously.
        </p>
        <p>
          <em>Tip: Focus on consistent participation. The longer you stay active, the more your reputation grows, which translates directly into higher earnings.</em>
        </p>
        <p>
          By installing the app, engaging with your network, and strategically staking your $CXPT tokens, you’re not just mining—you’re building a robust presence in the Cxmpute ecosystem. Start today and watch your reputation multiply, powering your journey towards maximized earnings.
        </p>
        <p>Happy mining!</p>
        <Link href="/">
          <Button text="Back to Home" backgroundColor="#20a191" />
        </Link>
      </div>
    </main>
  );
}

### File: src/app/page.tsx
"use client"

import Image from "next/image";
import styles from "./page.module.css";
import Button from "@/components/button/button";
import { useState } from "react";
import FAQCard from "@/components/faqCard/faqCard";
import Map from "@/components/map/map";

const cxmputeGreen = "#20a191";
const cxmputePink = "#fe91e8";
const cxmputeYellow = "#f8cb46";
const cxmputePurple = "#91a8eb";
// const cxmputeRed = "#d64989";
// const cxmputeSand = "#d4d4cb";
const cxmputeSlate = "#d4d4cb";
// const cxmputeBeige = "#f9f5f2";
// const cxmputeBeigerBeige = "#fdede3";


export default function Home() {

  const [identity, setIdentity] = useState("");

  // a function which instakes a string and sets the identity to it, and then scrolls to the #identitySpecific div
  const setIdentityAndScroll = (identity: string) => {
    setIdentity(identity);
    const element = document.getElementById("identitySpecific");
    element?.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <div className={styles.page}>
      <div className={styles.backgroundPattern}></div>

      <header className={styles.header}>
        <div className={styles.logo}>
          <Image src="/images/1.png" alt="cxmpute logo" height={70} width={70}/>
          <h1>CXMPUTE</h1>
        </div>
        <div className={styles.menu}>
          <ul>
            <li><a href="/download" target="_blank">
              <Button text="DOWNLOAD" backgroundColor={cxmputeYellow}/>
            </a></li>
            <li><a href="/docs" target="_blank">
              <Button text="DOCUMENTATION" backgroundColor={cxmputePurple}/>
            </a></li>
            <li><a href="/dashboard" target="_blank">
              <Button text=" DASHBOARD" backgroundColor={cxmputeGreen}/>
            </a></li>
          </ul>
        </div>
      </header>
      {/* Who is cxmpute for */}
      <div className={styles.content}>
        <div className={styles.hero}>
            <div className={styles.heroLeft}>
            <h3>Welcome to the Cxmpute network!</h3>
            <h1>Use or provide computing power, storage, and more.</h1>
            <p>Cxmpute connects providers of computing hardware with users who leverage a range of computing services.</p>
            <div className={styles.heroButtons}>
              <a href="/download" target="_blank">
              <Button text="Start earning as a provider" backgroundColor={cxmputeYellow}/>
              </a>
              <a href="/docs" target="_blank">
              <Button text="Start using Cxmpute services" backgroundColor={cxmputePink}/>
              </a>
            </div>
            <a href="/101" target="_blank">
              <Button text="Cxmpute in 90 seconds" backgroundColor={cxmputePurple}/>
            </a>
            </div>
          <div className={styles.heroRight}>
            <Image
              src="/images/dolphinhero.png"
              alt="dolphin image"
              fill
              style={{ objectFit: "contain" }}
            />
          </div>
        </div>
        <div className={styles.whoIsCxmputeFor}>
          <h3>Who is Cxmpute for?</h3>
          <h1>Here&apos;s what Cxmpute does for you:</h1>
          <p>I am a...</p>
            <div className={styles.whoIsCxmputeForCards}>
            <div className={styles.whoIsCxmputeForCard}>
              <div className={styles.whoIsCxmputeForCardImage}
              style={{ backgroundColor: cxmputePurple }}
              >
              <Image
                src="/images/code.svg"
                alt="code icon"
                fill
                style={{ objectFit: "contain" }}
              />
              </div>
              <span className={styles.whoIsCxmputeForCard__title}>Developer</span>
              <p className={styles.whoIsCxmputeForCard__content}>Access flexible, decentralized infrastructure to build, test, and deploy faster—without the limitations of traditional cloud services.</p>
              <button className={styles.whoIsCxmputeForCard__button}
                style={{ "--select-bg-color": cxmputePurple } as React.CSSProperties}
                onClick={() => setIdentityAndScroll("developer")}
              >
                That&apos;s me!
              </button>
            </div>
            <div className={styles.whoIsCxmputeForCard}>
              <div className={styles.whoIsCxmputeForCardImage}
              style={{ backgroundColor: cxmputeGreen }}
              >
              <Image
                src="/images/brain-electricity.svg"
                alt="brain icon"
                fill
                style={{ objectFit: "contain" }}
              />
              </div>
              <span className={styles.whoIsCxmputeForCard__title}>ML Engineer</span>
              <p className={styles.whoIsCxmputeForCard__content}>Train and run AI models at scale using cost-efficient in a familiar Jupyter Environment, with globally distributed compute resources designed for scale, performance, and reliability.</p>
              <button className={styles.whoIsCxmputeForCard__button}
                style={{ "--select-bg-color": cxmputeGreen } as React.CSSProperties}
                onClick={() => setIdentityAndScroll("mlEngineer")}
              >
                That&apos;s me!
              </button>
            </div>
            <div className={styles.whoIsCxmputeForCard}>
              <div className={styles.whoIsCxmputeForCardImage}
              style={{ backgroundColor: cxmputePink }}
              >
              <div className={styles.imageWrapper}>
                <Image
                  src="/images/computer.png"
                  alt="computer image"
                  fill
                  style={{ objectFit: "contain" }}
                />
              </div>
              </div>
              <span className={styles.whoIsCxmputeForCard__title}>Individual Compute Provider</span>
              <p className={styles.whoIsCxmputeForCard__content}>Monetize your idle computer resources by contributing to a decentralized network—and get rewarded for your unused power.</p>
              <button className={styles.whoIsCxmputeForCard__button}
                style={{ "--select-bg-color": cxmputePink } as React.CSSProperties}
                onClick={() => setIdentityAndScroll("individualComputeProvider")}
              >
                That&apos;s me!
              </button>
            </div>
            <div className={styles.whoIsCxmputeForCard}>
              <div className={styles.whoIsCxmputeForCardImage}
              style={{ backgroundColor: cxmputeYellow }}
              >
              <div className={styles.imageWrapper}>
                <Image
                  src="/images/server.png"
                  alt="server image"
                  fill
                  style={{ objectFit: "contain" }}
                />
              </div>
              </div>
              <span className={styles.whoIsCxmputeForCard__title}>Enterprise Compute Provider</span>
              <p className={styles.whoIsCxmputeForCard__content}>Maximize the ROI of your infrastructure by offering your datacenter capacity to a global marketplace for decentralized compute.</p>
              <button className={styles.whoIsCxmputeForCard__button}
                style={{ "--select-bg-color": cxmputeYellow } as React.CSSProperties}
                onClick={() => setIdentityAndScroll("enterpriseComputeProvider")}
              >
                That&apos;s me!
              </button>
            </div>
            </div>
        </div>
        <div className={styles.identitySpecific} id="identitySpecific">
          {identity === "" && (
            <>
            </>
          )}
          {identity === "developer" && (
            <div className={`${styles.whoIsCxmputeForCard} ${styles.idenitytSpecificContainer}`}
              style={{ 
                  width: "100%", 
                  backgroundColor: cxmputePurple, 
                  margin: "40px", 
                  maxWidth: "1300px",
                  minHeight: "60vh"
                 }}
            >
                <div className={styles.ISLeft}>
                  <h3>Cxmpute for</h3>
                  <h1>Developers</h1>
                  <p>Easy access to powerful machines that will otherwise cost you an arm and a leg.</p>
                  <a href="/services" target="_blank">
                  <Button text="Explore the full feature list" backgroundColor={cxmputeSlate}/>
                  </a>
                  <a href="/dashboard" target="_blank">
                  <Button text="Get started now" backgroundColor={cxmputeSlate}/>
                  </a>
                  <span>Or keep scrolling to learn more about Cxmpute :)</span>
                </div>
                <div className={styles.ISRight}>
                  <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"VIRTUAL MACHINES"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                  >
                    <div className={styles.ISTop}>
                    <button className={styles.idenitytSpecificInput__button__shadow}
                      style={{
                        height: "50px",
                        width: "50px",
                        marginBottom: "10px",
                        "--specific-feature-color": '#e9b50b' 
                      } as React.CSSProperties}
                    >
                      <Image
                        src="/images/code.svg"
                        alt="search icon"
                        fill
                        style={{ objectFit: "contain" }}
                      />
                    </button>
                    <p>Cxmpute offers VMs optimized for specific hardware configurations</p>
                    </div>

                    <div className={styles.ISBottom}>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      Read the docs
                    </button>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      See code examples
                    </button>
                    </div>
                  </div>
                  <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"SERVERLESS COMPUTE"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                  >
                    <div className={styles.ISTop}>
                    <button className={styles.idenitytSpecificInput__button__shadow}
                      style={{
                        height: "50px",
                        width: "50px",
                        marginBottom: "10px",
                        "--specific-feature-color": '#e9b50b' 
                      } as React.CSSProperties}
                    >
                      <Image
                        src="/images/code.svg"
                        alt="search icon"
                        fill
                        style={{ objectFit: "contain" }}
                      />
                    </button>
                    <p>Cxmpute’s Serverless service provides event-driven compute without the need to manage traditional servers.</p>
                    </div>

                    <div className={styles.ISBottom}>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      Read the docs
                    </button>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      See code examples
                    </button>
                    </div>
                  </div>
                  <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"AI INFERENCE"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                  >
                    <div className={styles.ISTop}>
                    <button className={styles.idenitytSpecificInput__button__shadow}
                      style={{
                        height: "50px",
                        width: "50px",
                        marginBottom: "10px",
                        "--specific-feature-color": '#e9b50b' 
                      } as React.CSSProperties}
                    >
                      <Image
                        src="/images/code.svg"
                        alt="search icon"
                        fill
                        style={{ objectFit: "contain" }}
                      />
                    </button>
                    <p>On-demand API endpoint for AI inference with a big library of SOTA AI models.</p>
                    </div>

                    <div className={styles.ISBottom}>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      Read the docs
                    </button>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      See code examples
                    </button>
                    </div>
                  </div>
                  <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"AI AGENTS"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                  >
                    <div className={styles.ISTop}>
                    <button className={styles.idenitytSpecificInput__button__shadow}
                      style={{
                        height: "50px",
                        width: "50px",
                        marginBottom: "10px",
                        "--specific-feature-color": '#e9b50b' 
                      } as React.CSSProperties}
                    >
                      <Image
                        src="/images/code.svg"
                        alt="search icon"
                        fill
                        style={{ objectFit: "contain" }}
                      />
                    </button>
                    <p>AI-Agents-as-a-service. Interact with agents orchestrate workflows, and execute complex tasks via GUI or API.</p>
                    </div>

                    <div className={styles.ISBottom}>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      Read the docs
                    </button>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      See code examples
                    </button>
                    </div>
                  </div>
                  <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"CODESPACES"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                  >
                    <div className={styles.ISTop}>
                    <button className={styles.idenitytSpecificInput__button__shadow}
                      style={{
                        height: "50px",
                        width: "50px",
                        marginBottom: "10px",
                        "--specific-feature-color": '#e9b50b' 
                      } as React.CSSProperties}
                    >
                      <Image
                        src="/images/code.svg"
                        alt="search icon"
                        fill
                        style={{ objectFit: "contain" }}
                      />
                    </button>
                    <p>Code Spaces provides a familiar but cloud-based development environment for coding, testing, and deploying applications. </p>
                    </div>

                    <div className={styles.ISBottom}>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      Read the docs
                    </button>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      See code examples
                    </button>
                    </div>
                  </div>
                  <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"PYTHON NOTEBOOKS"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                  >
                    <div className={styles.ISTop}>
                    <button className={styles.idenitytSpecificInput__button__shadow}
                      style={{
                        height: "50px",
                        width: "50px",
                        marginBottom: "10px",
                        "--specific-feature-color": '#e9b50b' 
                      } as React.CSSProperties}
                    >
                      <Image
                        src="/images/code.svg"
                        alt="search icon"
                        fill
                        style={{ objectFit: "contain" }}
                      />
                    </button>
                    <p>PyNotebooks allow users to run Python-based data science and machine learning workflows in an interactive environment. Access larger accelerators and environments than the competition.</p>
                    </div>

                    <div className={styles.ISBottom}>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      Read the docs
                    </button>
                    <button className={styles.idenitytSpecificInput__button__shadow}>
                      See code examples
                    </button>
                    </div>
                  </div>
                </div>
            </div>

          )}
          {identity === "mlEngineer" && (
            <div className={`${styles.whoIsCxmputeForCard} ${styles.idenitytSpecificContainer}`}
                style={{ 
                    width: "100%", 
                    backgroundColor: cxmputeGreen, 
                    margin: "40px", 
                    maxWidth: "1300px",
                    minHeight: "60vh"
                  }}
              >
                  <div className={styles.ISLeft}>
                    <h3>Cxmpute for</h3>
                    <h1>ML Engineers</h1>
                    <p>Easy access to powerful machines that will otherwise cost you an arm and a leg.</p>
                    <a href="/services" target="_blank">
                    <Button text="Explore the full feature list" backgroundColor={cxmputeSlate}/>
                    </a>
                    <a href="/dashboard" target="_blank">
                    <Button text="Get started now" backgroundColor={cxmputeSlate}/>
                    </a>
                    <span>Or keep scrolling to learn more about Cxmpute :)</span>
                  </div>
                  <div className={styles.ISRight}>
                  <div className={styles.idenitytSpecificInput__container}
                      style={{ "--specific-feature": '"PYTHON NOTEBOOKS"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                    >
                      <div className={styles.ISTop}>
                      <button className={styles.idenitytSpecificInput__button__shadow}
                        style={{
                          height: "50px",
                          width: "50px",
                          marginBottom: "10px",
                          "--specific-feature-color": '#e9b50b' 
                        } as React.CSSProperties}
                      >
                        <Image
                          src="/images/code.svg"
                          alt="search icon"
                          fill
                          style={{ objectFit: "contain" }}
                        />
                      </button>
                      <p>PyNotebooks allow users to run Python-based data science and machine learning workflows in an interactive environment. Access larger accelerators and environments than the competition.</p>
                      </div>

                      <div className={styles.ISBottom}>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        Read the docs
                      </button>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        See code examples
                      </button>
                      </div>
                    </div>
                    <div className={styles.idenitytSpecificInput__container}
                      style={{ "--specific-feature": '"VIRTUAL MACHINES"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                    >
                      <div className={styles.ISTop}>
                      <button className={styles.idenitytSpecificInput__button__shadow}
                        style={{
                          height: "50px",
                          width: "50px",
                          marginBottom: "10px",
                          "--specific-feature-color": '#e9b50b' 
                        } as React.CSSProperties}
                      >
                        <Image
                          src="/images/code.svg"
                          alt="search icon"
                          fill
                          style={{ objectFit: "contain" }}
                        />
                      </button>
                      <p>Cxmpute offers VMs optimized for specific hardware configurations</p>
                      </div>

                      <div className={styles.ISBottom}>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        Read the docs
                      </button>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        See code examples
                      </button>
                      </div>
                    </div>
                    <div className={styles.idenitytSpecificInput__container}
                      style={{ "--specific-feature": '"SERVERLESS COMPUTE"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                    >
                      <div className={styles.ISTop}>
                      <button className={styles.idenitytSpecificInput__button__shadow}
                        style={{
                          height: "50px",
                          width: "50px",
                          marginBottom: "10px",
                          "--specific-feature-color": '#e9b50b' 
                        } as React.CSSProperties}
                      >
                        <Image
                          src="/images/code.svg"
                          alt="search icon"
                          fill
                          style={{ objectFit: "contain" }}
                        />
                      </button>
                      <p>Cxmpute’s Serverless service provides event-driven compute without the need to manage traditional servers.</p>
                      </div>

                      <div className={styles.ISBottom}>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        Read the docs
                      </button>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        See code examples
                      </button>
                      </div>
                    </div>
                    <div className={styles.idenitytSpecificInput__container}
                      style={{ "--specific-feature": '"AI INFERENCE"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                    >
                      <div className={styles.ISTop}>
                      <button className={styles.idenitytSpecificInput__button__shadow}
                        style={{
                          height: "50px",
                          width: "50px",
                          marginBottom: "10px",
                          "--specific-feature-color": '#e9b50b' 
                        } as React.CSSProperties}
                      >
                        <Image
                          src="/images/code.svg"
                          alt="search icon"
                          fill
                          style={{ objectFit: "contain" }}
                        />
                      </button>
                      <p>On-demand API endpoint for AI inference with a big library of SOTA AI models.</p>
                      </div>

                      <div className={styles.ISBottom}>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        Read the docs
                      </button>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        See code examples
                      </button>
                      </div>
                    </div>
                    <div className={styles.idenitytSpecificInput__container}
                      style={{ "--specific-feature": '"AI AGENTS"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                    >
                      <div className={styles.ISTop}>
                      <button className={styles.idenitytSpecificInput__button__shadow}
                        style={{
                          height: "50px",
                          width: "50px",
                          marginBottom: "10px",
                          "--specific-feature-color": '#e9b50b' 
                        } as React.CSSProperties}
                      >
                        <Image
                          src="/images/code.svg"
                          alt="search icon"
                          fill
                          style={{ objectFit: "contain" }}
                        />
                      </button>
                      <p>AI-Agents-as-a-service. Interact with agents orchestrate workflows, and execute complex tasks via GUI or API.</p>
                      </div>

                      <div className={styles.ISBottom}>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        Read the docs
                      </button>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        See code examples
                      </button>
                      </div>
                    </div>
                    <div className={styles.idenitytSpecificInput__container}
                      style={{ "--specific-feature": '"CODESPACES"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                    >
                      <div className={styles.ISTop}>
                      <button className={styles.idenitytSpecificInput__button__shadow}
                        style={{
                          height: "50px",
                          width: "50px",
                          marginBottom: "10px",
                          "--specific-feature-color": '#e9b50b' 
                        } as React.CSSProperties}
                      >
                        <Image
                          src="/images/code.svg"
                          alt="search icon"
                          fill
                          style={{ objectFit: "contain" }}
                        />
                      </button>
                      <p>Code Spaces provides a familiar but cloud-based development environment for coding, testing, and deploying applications. </p>
                      </div>

                      <div className={styles.ISBottom}>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        Read the docs
                      </button>
                      <button className={styles.idenitytSpecificInput__button__shadow}>
                        See code examples
                      </button>
                      </div>
                    </div>
                  </div>
              </div>
          )}
          {identity === "individualComputeProvider" && (
                    <div className={`${styles.whoIsCxmputeForCard} ${styles.idenitytSpecificContainer}`}
                        style={{ 
                            width: "100%", 
                            backgroundColor: cxmputePink, 
                            margin: "40px", 
                            maxWidth: "1300px",
                            minHeight: "60vh"
                          }}
                      >
                          <div className={styles.ISLeft}>
                            <h3>Cxmpute for</h3>
                            <h1>Individuals</h1>
                            <p>Turn your idle computer into a passive income generator—earn rewards effortlessly.</p>
                            <a href="/download" target="_blank">
                            <Button text="Get started in 5 minutes" backgroundColor={cxmputeGreen}/>
                            </a>
                            <span>Or keep scrolling to learn more about Cxmpute :)</span>
                          </div>
                          <div className={styles.ISRight}>
                          <div className={styles.idenitytSpecificInput__container}
                              style={{ "--specific-feature": '"STEP 1"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                            >
                                <h1>Create an account in the dashboard</h1>
                          </div>
                          <div className={styles.idenitytSpecificInput__container}
                              style={{ "--specific-feature": '"STEP 2"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                            >
                                <h1>Download the Cxmpute Provider App</h1>
                          </div>
                          <div className={styles.idenitytSpecificInput__container}
                              style={{ "--specific-feature": '"STEP 3"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                            >
                                <h1>Follow the instructions in the app to complete the onboarding steps.</h1>
                          </div>
                          <div className={styles.idenitytSpecificInput__container}
                              style={{ "--specific-feature": '"STEP 4"', "--specific-feature-color": '#e9b50b' } as React.CSSProperties}
                            >
                                <h1>Turn on your Cxmpute provider node and start earning!</h1>
                          </div>
                          </div>
                      </div>
          )}
          {identity === "enterpriseComputeProvider" && (
            <div className={`${styles.whoIsCxmputeForCard} ${styles.idenitytSpecificContainer}`}
              style={{ 
                  width: "100%", 
                  backgroundColor: cxmputeYellow, 
                  margin: "40px", 
                  maxWidth: "1300px",
                  minHeight: "60vh"
                }}
            >
                <div className={styles.ISLeft}>
                  <h3>Cxmpute for</h3>
                  <h1>Enterprise Providers</h1>
                  <p>Whether you run a boutique data center or a vast compute network, Cxmpute empowers you to optimize resource utilization, scale seamlessly, and access new revenue streams.</p>
                  <a href="/download" target="_blank">
                  <Button text="Get started in 5 minutes" backgroundColor={cxmputeGreen}/>
                  </a>
                  <a href="/contact" target="_blank">
                  <Button text="Or contact us to book a call" backgroundColor={cxmputeGreen}/>
                  </a>
                  <span>Or keep scrolling to learn more about Cxmpute :)</span>
                </div>
                <div className={styles.ISRight}>
                <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"STEP 1"', "--specific-feature-color": cxmputePurple } as React.CSSProperties}
                  >
                      <h1>Create an account in the dashboard</h1>
                </div>
                <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"STEP 2"', "--specific-feature-color": cxmputePurple } as React.CSSProperties}
                  >
                      <h1>Download the Cxmpute Provider App</h1>
                </div>
                <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"STEP 3"', "--specific-feature-color": cxmputePurple } as React.CSSProperties}
                  >
                      <h1>Follow the instructions in the app to complete the onboarding steps.</h1>
                </div>
                <div className={styles.idenitytSpecificInput__container}
                    style={{ "--specific-feature": '"STEP 4"', "--specific-feature-color": cxmputePurple } as React.CSSProperties}
                  >
                      <h1>Turn on your Cxmpute provider node and start earning!</h1>
                </div>
                </div>
            </div>
          )}
        </div>
        <div className={styles.protected}>
          <div className={styles.protectedContainer}>
            <div className={styles.protectedImageContainer}>
              <div className={styles.imageWrapper2}>
                <Image
                  src="/images/shield.png"
                  alt="Cxmpute protects your privacy"
                  fill
                  style={{ objectFit: "contain" }}
                />
              </div>
            </div>
            <div className={styles.protectedTextContainer}>
              <h1>Cxmpute protects your privacy</h1>
              <p>At Cxmpute, our philosophy is to secure your computing resources from unauthorized use. It is impossible for Cxmpute to access your personal files or monitor your activity. Cxmpute is a network designed solely for contributing unused computing power, ensuring that your data remains private and your device stays protected while you help power the next generation of decentralized technology.</p>
            </div>
          </div>
        </div>
        <div className={styles.architecture}>
          <div className={styles.architectureContainer}>
            <div className={styles.ALeft}>
              <h1>Cxmpute Network Architecture</h1>
            </div>
            <div className={styles.ARight}>
              <div className={styles.architectureLayer}
                style={{ "--architecture-layer-color": cxmputePurple } as React.CSSProperties}
              >
                <h1>Cxmpute Core</h1>
                <p>The main hub for users to access services, manage workloads, and deploy AI models. It offers a simple interface and powerful APIs, making it easy for anyone to leverage Cxmpute’s decentralized computing.</p>
              </div>
              <div className={styles.architectureLayer}
                style={{ "--architecture-layer-color": cxmputeGreen } as React.CSSProperties}
              >
                <h1>Financial Layer</h1>
                <p>Blockchain layers for automated payments and rewards distribution. Cxmpute&apos;s multi-chain architecture allows you to participate with your preferred blockchain.</p>
              </div>
              <div className={styles.architectureLayer}
                style={{ "--architecture-layer-color": cxmputeYellow } as React.CSSProperties}
              >
                <h1>Orchestration Network Layer</h1>
                <p>Manages requests and matches users with the best providers based on pricing, hardware, and availability. It ensures smooth operation of services like serverless compute, AI inference, and distributed training.</p>
              </div>
              <div className={styles.architectureLayer}
                style={{ "--architecture-layer-color": cxmputePink } as React.CSSProperties}
              >
                <h1>Provider Network Layer</h1>
                <p>The core of Cxmpute’s infrastructure. This global network provides scalable, secure computing power for AI inference, serverless apps, and distributed workloads. Providers earn rewards by sharing their resources.</p>
              </div>
            </div>
          </div>
        </div>
        <div className={styles.token}>
          <div className={styles.tokenContainer}>
            <div className={styles.ARight}>
              <div className={styles.cxptToken}>
                <Image
                  src="/images/8.png"
                  alt="Cxmpute token"
                  fill
                  style={{ objectFit: "contain" }}
                />
              </div>
            </div>
            <div className={styles.ALeft}>
              <h1>$CXPT Token</h1>
              <p>The Cxmpute token is a utility token that lets providers optionally stake tokens to demonstrate reputation and enhance network security. It rewards users for participation and grants access to special features and services. The token is not live yet, but stay tuned for updates!</p>
            </div>
          </div>
        </div>
        <div className={styles.blog}>
          <div className={styles.blogContainer}>
            <h1 className={styles.blogTitle}>Read more: browse our latest news</h1>
            <div className={styles.blogCards}>
              <div className={styles.blogCard}>
                <div className={styles.blogCardImage}>
                  <Image
                    src="/images/8.png"
                    alt="Cxmpute blog"
                    fill
                    style={{ objectFit: "contain" }}
                  />
                </div>
                <div className={styles.blogCardText}>
                  <h1>Cxmpute 101: What is Cxmpute?</h1>
                  <p>Before we dive into Cxmpute 101, let’s start with an analogy to understand idle compute power. Imagine your computer as a power plant with extra capacity sitting idle most of the...</p>
                  <a href="/101" target="_blank">
                    <Button text="Read more" backgroundColor={cxmputeYellow} />
                  </a>
                </div>
              </div>
              <div className={styles.blogCard}>
                <div className={styles.blogCardImage}>
                  <Image
                    src="/images/6.png"
                    alt="Cxmpute blog"
                    fill
                    style={{ objectFit: "contain" }}
                  />
                </div>
                <div className={styles.blogCardText}>
                  <h1>Cxmpute Roadmap</h1>
                  <p>Our Future Vision and How We&apos;ll Get There. Our journey is guided by a clear blueprint that transforms vision into reality—one inspiring step at a time.</p>
                  <a href="/roadmap" target="_blank">
                    <Button text="Read more" backgroundColor={cxmputeYellow} />
                  </a>
                </div>
              </div>
              <div className={styles.blogCard}>
                <div className={styles.blogCardImage}>
                  <Image
                    src="/images/7.png"
                    alt="Cxmpute blog"
                    fill
                    style={{ objectFit: "contain" }}
                  />
                </div>
                <div className={styles.blogCardText}>
                  <h1>Cxmpute Services Overview</h1>
                  <p>Imagine a bustling digital marketplace where every piece of idle compute power is transformed into a vibrant service—this is the heart of Cxmpute. Today, we’re taking you on a tour of our extensive suite of services that...</p>
                  <a href="/services" target="_blank">
                    <Button text="Read more" backgroundColor={cxmputeYellow} />
                  </a>
                </div>
              </div>
              <div className={styles.blogCard}>
                <div className={styles.blogCardImage}>
                  <Image
                    src="/images/8.png"
                    alt="Cxmpute blog"
                    fill
                    style={{ objectFit: "contain" }}
                  />
                </div>
                <div className={styles.blogCardText}>
                  <h1>How to maximize your earnings as a provider</h1>
                  <p>Ready to boost your earnings on the Cxmpute network? Whether you’re just starting out or already part of our growing community, here are some quick tips to help you maximize...</p>
                  <a href="/maximize" target="_blank">
                    <Button text="Read more" backgroundColor={cxmputeYellow} />
                  </a>
                </div>
              </div>
              
            </div>
          </div>
        </div>
        <div className={styles.faq}>
          <div className={styles.faqContainer}>
            <h1>Frequently Asked Questions</h1>
            <FAQCard
              question="Is my personal data truly safe with Cxmpute?"
              answer="Absolutely. Cxmpute is built on a philosophy of strict privacy. We only harness your unused computing power and never access your personal files or monitor your online activity, ensuring your data remains completely secure."
            />
            <FAQCard
              question="Will running Cxmpute slow down my device or affect my internet speed?"
              answer="Not necessarily—you control exactly how much of your device's computing power Cxmpute uses. If you want to maximize your rewards, you can configure it to tap into more resources when you're not using your computer. For example, if you're going to bed, you can allow Cxmpute to operate at full capacity overnight, maximizing rewards without interrupting your daily activities. Conversely, if you need to use your device during the day, you can adjust the settings so that Cxmpute uses only a portion of your available power. Importantly, mining sessions only begin when you explicitly turn them on—Cxmpute is never active without your permission. The flexibility of these settings can vary by device and category, with more powerful systems generally offering greater customization. For further details on eligible devices and recommended configurations, please refer to our Get Started page."
            />
            <FAQCard
              question="How complicated is the installation and setup process?"
              answer="We’ve made it extremely user-friendly. The setup is straightforward—even if you’re not tech-savvy—thanks to our intuitive interface and step-by-step instructions. You set it up once and then watch the rewards accumulate effortlessly."
            />
            <FAQCard
              question="How does Cxmpute ensure fair rewards for my unused computing power?"
              answer="Our reward mechanism is transparent and automated. All our code is open-source and available on our GitHub. Using a robust multi-chain architecture, Cxmpute calculates rewards based on your contributed idle capacity and distributes them fairly, so you always get your due share without any extra effort."
            />
            <FAQCard
              question="What if I run into technical issues or experience downtime?"
              answer="Our dedicated support team is here to help. Contact us via our Discord if you encounter any issues. The platform is built for high reliability and is continuously monitored to address any issues swiftly, ensuring minimal disruption to your experience."
            />
            <FAQCard
              question="Can I control when and how my resources are used?"
              answer="Yes, you remain in complete control. Cxmpute leverages only your idle computing power. This means you decide when to run it, and your primary activities and system performance remain unaffected."
            />
            <FAQCard
              question="What if I have concerns about long-term reliability and support?"
              answer="We’re committed to continuous improvement and customer satisfaction. Our platform is regularly updated, and our support team is always available to assist you—ensuring you enjoy a seamless, reliable experience with Cxmpute."
            />
          </div>
        </div>

        <div className={styles.mapt}>
          <div className={styles.mapContainer}>
            <Map/>
            <div className={styles.mapTextOverlay}>
              <div className={styles.mapOverlayImage}>
                <Image
                  src="/images/3.png"
                  alt="Cxmpute Dolphin Logo"
                  fill
                  style={{ objectFit: "contain" }}
                />
              </div>
              <h1>Start earning off your computing power</h1>
              <a href="/download" target="_blank">
                <Button text="Get started" backgroundColor={cxmputeYellow} />
              </a>
            </div>
          </div>
        </div>

      </div>
      <footer className={styles.footer}>
        <div className={styles.footerContainer}>
          <div className={styles.footerLeft}>
            <div className={styles.footerImage}>
              <Image
                src="/images/8.png"
                alt="Cxmpute Dolphin Logo"
                width={150}
                height={150}
                style={{ objectFit: "contain" }}
              />
            </div>
          </div>
          <div className={styles.footerRight}>
            <div className={styles.footerSocialLinks}>
              <a
                href="https://x.com/cxmpute"
                target="_blank"
                rel="noopener noreferrer"
                className={styles.footerSocialLink}
              >
                <Image
                  src="/images/x.svg"
                  alt="Twitter"
                  width={25}
                  height={25}
                  style={{ objectFit: "contain" }}
                />
              </a>
              <a
                href="https://discord.com/invite/CJGA7B2zKT"
                target="_blank"
                rel="noopener noreferrer"
                className={styles.footerSocialLink}
              >
                <Image
                  src="/images/discord.svg"
                  alt="Discord"
                  width={25}
                  height={25}
                  style={{ objectFit: "contain" }}
                />
              </a>
              <a
                href="https://www.youtube.com/@cxmputenetwork"
                target="_blank"
                rel="noopener noreferrer"
                className={styles.footerSocialLink}
              >
                <Image
                  src="/images/youtube.svg"
                  alt="Youtube"
                  width={25}
                  height={25}
                  style={{ objectFit: "contain" }}
                />
              </a>
              <a
                href="https://github.com/unxversal"
                target="_blank"
                rel="noopener noreferrer"
                className={styles.footerSocialLink}
              >
                <Image
                  src="/images/github-circle.svg"
                  alt="Github"
                  width={25}
                  height={25}
                  style={{ objectFit: "contain" }}
                />
              </a>
              <a
                href="https://www.reddit.com/r/cxmpute/"
                target="_blank"
                rel="noopener noreferrer"
                className={styles.footerSocialLink}
              >
                <Image
                  src="/images/reddit.png"
                  alt="Reddit"
                  width={25}
                  height={25}
                  style={{ objectFit: "contain" }}
                />
              </a>

            </div>
            <div className={styles.footerButtons}>
              <a href="/download" target="_blank">
                <Button text="Get started as a provider" backgroundColor={cxmputeYellow} />
              </a>
              <a href="/dashboard" target="_blank">
                <Button text="Get started as a user" backgroundColor={cxmputeYellow} />
              </a>
            </div>
          </div>
        </div>
      </footer>
    </div>

  );
}

### File: src/app/globals.css
:root {
  --background: #ffffff;
  --foreground: #171717;
  --cxmpute-green: #20a191;
  --cxmpute-pink: #fe91e8;
  --cxmpute-yellow: #f8cb46;
  --cxmpute-purple: #91a8eb;
  --cxmpute-slate: #d4d4cb;
  --cxmpute-lightgreen: #97e1bd;
  --cxmpute-lightyellow: #f7e48c;
  --cxmpute-orange: #f76707;
  --cxmpute-red: #d64989;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
    --cxmpute-green: #20a191;
    --cxmpute-pink: #fe91e8;
    --cxmpute-yellow: #f8cb46;
    --cxmpute-purple: #91a8eb;
    --cxmpute-slate: #d4d4cb;
    --cxmpute-lightgreen: #97e1bd;
    --cxmpute-lightyellow: #f7e48c;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  height: 100%;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f9f5f2;
  color: black;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}


/* * {
  scrollbar-color: black #f9f5f2;
} */
### File: src/app/services/page.module.css
.main{
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    padding: 32px;
    font-family: var(--font-roboto);
}

.docWrapper{
    width: 100%;
    max-width: 800px;
    display: flex;
    flex-direction: column;
    gap: 24px;
    margin-top: 20px;
    margin-bottom: 20px;
    padding: 32px;
}

.docWrapper h1{
    background-color: #f8cb46;
    border: 6px solid #000;
    border-radius: 20px;
    box-shadow: 12px 12px 0 #000;
    padding: 20px;
    transition: all 0.3s ease-in-out;
    margin-bottom: 48px;
}

/* .docWrapper h1:hover{
    transform: translate(-5px, -5px);
    box-shadow: 17px 17px 0 #000;
} */

.docWrapper h2{
    background-color: #91a8eb;
    border: 6px solid #000;
    border-radius: 10px;
    box-shadow: 6px 6px 0 #000;
    padding: 10px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

.docWrapper h2:hover{
    transform: translate(-5px, -5px);
    box-shadow: 8px 8px 0 #000;
}

.docWrapper h3{
    background-color: #fe91e8;
    border: 3px solid #000;
    border-radius: 5px;
    box-shadow: 6px 6px 0 #000;
    padding: 5px;
    transition: all 0.3s ease-in-out;
    margin-top: 24px;
    width: max-content;
}

### File: src/app/services/page.tsx
import Button from "@/components/button/button";
import styles from "./page.module.css";
import Link from "next/link";

export default function ServicesOverview() {
  return (
    <main className={styles.main}>
      <div className={styles.docWrapper}>
        <h1>Services Comprehensive Overview</h1>
        <p>
          Imagine a bustling digital marketplace where every piece of idle compute power is transformed into a vibrant service—this is the heart of Cxmpute. Today, we’re taking you on a tour of our extensive suite of services that power everything from scalable virtual machines to dynamic AI chatbots. Each service is designed with the modern user in mind, whether you’re a developer, a data scientist, or an enterprise looking for innovative solutions.
        </p>
        <h2>Compute Power, Reimagined</h2>
        <h3>Virtual Machines</h3>
        <p>
          Our Virtual Machines provide a customizable, scalable compute environment, perfect for running a variety of workloads. Think of them as your personal mini data centers, optimized for specific hardware configurations and designed to deliver efficient, cost-effective performance across our decentralized network.
        </p>
        <h3>Serverless</h3>
        <p>
          With Cxmpute’s Serverless service, you can deploy applications in an event-driven manner—no need to worry about managing traditional servers. This solution scales effortlessly to meet demand, giving you more time to focus on creating amazing products.
        </p>
        <h3>Kubernetes</h3>
        <p>
          For those managing containerized applications, our Kubernetes support brings the power of large-scale container orchestration to your fingertips. It enables decentralized AI training and serverless deployments, ensuring that your applications run smoothly and flexibly across the network.
        </p>
        <h2>Empowering AI and Intelligent Workflows</h2>
        <h3>AI Agents</h3>
        <p>
          Our AI Agents are modular and intelligent—ready to tackle tasks ranging from simple automation to orchestrating complex workflows. With our Agxnt service, integrating these agents into your applications is seamless, boosting both productivity and creativity.
        </p>
        <h3>AI Inference</h3>
        <p>
          Deploy AI models without the hassle of managing infrastructure. Cxmpute’s AI Inference service provides a serverless solution for rapid, cost-efficient model execution, making it easier than ever to harness the power of AI.
        </p>
        <h3>AI Fine-tuning</h3>
        <p>
          Tailor pre-trained models to your specific needs with our AI Fine-tuning service. By decentralizing the process, you can enhance model accuracy affordably—no need for massive centralized data centers.
        </p>
        <h3>AI Training</h3>
        <p>
          When it comes to training large-scale machine learning models, our decentralized infrastructure offers a flexible, cost-efficient solution. Tap into distributed compute power to accelerate your AI training workloads.
        </p>
        <h3>Workflows</h3>
        <p>
          Streamline your processes by automating tasks that span multiple compute services. Cxmpute’s Workflows bring together various features into a cohesive system, ensuring flexibility, reliability, and scalability.
        </p>
        <h2>Revolutionizing Data and Development</h2>
        <h3>Storage &amp; Databases</h3>
        <p>
          Our storage solutions, known as Stxrage, offer decentralized, secure file storage—ideal for ensuring data integrity and avoiding single points of failure. Complementing this is our suite of database services:
        </p>
        <ul>
          <li>
            <strong>Vector Database:</strong> Optimize your AI-driven applications with efficient search and retrieval of high-dimensional data.
          </li>
          <li>
            <strong>Databases:</strong> Store and query structured data in a resilient, censorship-resistant environment.
          </li>
          <li>
            <strong>Datasets:</strong> A collaborative platform to share and store datasets, fostering open innovation and research.
          </li>
        </ul>
        <h3>Developer Tools: Code Spaces and PyNotebooks</h3>
        <p>
          Developers, rejoice! Our Code Spaces provide a cloud-based environment for coding, testing, and deploying applications with ease. Meanwhile, PyNotebooks offer an interactive, Python-driven workspace—ideal for data science and machine learning workflows that benefit from decentralized compute power.
        </p>
        <h2>Creativity Meets Technology</h2>
        <h3>Rendering</h3>
        <p>
          For the digital creators and designers among us, Cxmpute’s Rendering service brings decentralized 3D rendering capabilities to your projects. Whether you’re creating virtual worlds or simulations, enjoy faster rendering times and reduced costs by tapping into distributed compute resources.
        </p>
        <h3>AI Chat</h3>
        <p>
          And let’s not forget AI Chat—a service that integrates intelligent, conversational agents into your applications for real-time, interactive communication. This is where automation meets a human touch, elevating user engagement to new heights.
        </p>
        <p>
          Cxmpute’s comprehensive suite of services is designed to empower every user in our ecosystem. By transforming idle compute resources into powerful, scalable, and cost-effective solutions, we’re not just building a platform—we’re redefining the future of decentralized computing. Ready to explore the possibilities? Join us and harness the full potential of the Cxmpute network.
        </p>
        <Link href="/">
          <Button text="Back to Home" backgroundColor="#20a191" />
        </Link>
      </div>
    </main>
  );
}

### File: src/app/auth.ts
import { Resource } from "sst"
import { createClient } from "@openauthjs/openauth/client"
import { cookies as getCookies } from "next/headers"

export const client = createClient({
  clientID: "nextjs",
  issuer: Resource.CxmputeAuth.url
})

export async function setTokens(access: string, refresh: string) {
  const cookies = await getCookies()

  cookies.set({
    name: "access_token",
    value: access,
    httpOnly: true,
    sameSite: "lax",
    path: "/",
    maxAge: 34560000,
  })
  cookies.set({
    name: "refresh_token",
    value: refresh,
    httpOnly: true,
    sameSite: "lax",
    path: "/",
    maxAge: 34560000,
  })
}
### File: src/components/dashboard/Dashboard.tsx
"use client";

import { useEffect, useState, useMemo } from "react";
import styles from "./dashboard.module.css";

import Button from "@/components/button/button";
import Link from "next/link";
import {
  Wallet,
  KeyRound,
  BarChart3,
  Server,
  Trash2,
  RefreshCcw,
  Copy,
} from "lucide-react";

type Subject = {
  id: string;
  providerId: string;
  providerAk: string;
  userAk: string;
  userAks: string[];
  admin?: boolean;
};

type ApiKey = {
  key: string;
  creditLimit: number;
  creditsLeft: number;
  permittedRoutes: string[];
};

type EarningsPoint = { day: string; amount: number };

const ROUTES = [
  "/chat/completions",
  "/embeddings",
  "/image",
  "/tts",
  "/video",
  "/scrape",
  "/m/caption",
  "/m/query",
  "/m/detect",
  "/m/point",
];

export default function Dashboard({ subject }: { subject: Subject }) {
  /* ——————————————————— view switcher ——————————————————— */
  const [mode, setMode] = useState<"user" | "provider" | "trader">("user");

  /* ——————————————————— user state ——————————————————— */
  const [apiKeys, setApiKeys] = useState<ApiKey[]>([]);
  const [credits, setCredits] = useState<number>(0);
  const [rewards, setRewards] = useState<number>(0);

  /* ——————————————————— provider state ——————————————————— */
  const [earnings, setEarnings] = useState<EarningsPoint[]>([]);
  const totalEarnings = useMemo(
    () => earnings.reduce((s, e) => s + e.amount, 0),
    [earnings],
  );
  const [provisions, setProvisions] = useState<
    { provisionId: string; status: string }[]
  >([]);

  /* ——————————————————— modal confirm ——————————————————— */
  const [confirm, setConfirm] = useState<{
    msg: string;
    onYes: () => void;
  } | null>(null);

  /* ——————————————————— helpers ——————————————————— */
  const fetchUserData = async () => {
    const r = await fetch(`/api/user/${subject.id}/summary`);
    if (!r.ok) return;
    const j = await r.json();
    setApiKeys(j.apiKeys ?? []);
    setCredits(j.credits ?? 0);
    setRewards(j.rewards ?? 0);
  };

  const fetchProviderData = async () => {
    const r = await fetch(`/api/providers/${subject.providerId}/earnings`);
    if (r.ok) setEarnings((await r.json()).earnings ?? []);
    const p = await fetch(`/api/providers/${subject.providerId}/provisions`);
    if (p.ok) setProvisions(await p.json());
  };

  useEffect(() => {

    const fetchUserData = async () => {
        const r = await fetch(`/api/user/${subject.id}/summary`);
        if (!r.ok) return;
        const j = await r.json();
        setApiKeys(j.apiKeys ?? []);
        setCredits(j.credits ?? 0);
        setRewards(j.rewards ?? 0);
      };
    
      const fetchProviderData = async () => {
        const r = await fetch(`/api/providers/${subject.providerId}/earnings`);
        if (r.ok) setEarnings((await r.json()).earnings ?? []);
        const p = await fetch(`/api/providers/${subject.providerId}/provisions`);
        if (p.ok) setProvisions(await p.json());
      };

    if (mode === "user") fetchUserData();
    if (mode === "provider") fetchProviderData();
  }, [mode, subject.id, subject.providerId]);

  /* ——————————————————— key CRUD ——————————————————— */
  const createKey = async (form: FormData) => {
    const creditLimit = Number(form.get("credits") ?? 0);
    const permittedRoutes = form.getAll("route") as string[];
    await fetch(`/api/user/${subject.id}/keys`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ creditLimit, permittedRoutes }),
    });
    fetchUserData();
  };

  const deleteKey = (k: string) =>
    setConfirm({
      msg: "Delete this API key?",
      onYes: async () => {
        await fetch(`/api/user/${subject.id}/keys/${k}`, { method: "DELETE" });
        fetchUserData();
      },
    });

  const refreshAk = (type: "user" | "provider") =>
    setConfirm({
      msg: `Refresh ${type}Ak? Existing calls with the old key will stop working.`,
      onYes: async () => {
        const url =
          type === "user"
            ? `/api/user/${subject.id}/userAk/refresh`
            : `/api/providers/${subject.providerId}/providerAk/refresh`;
        await fetch(url, { method: "POST" });
        if (type === "user") fetchUserData();
        else fetchProviderData();
      },
    });

  /* ——————————————————— render helpers ——————————————————— */
  const mask = (k: string) => k.slice(0, 4) + " … " + k.slice(-4);

  const KeyRow = ({
    k,
    onDelete,
  }: {
    k: ApiKey;
    onDelete?: () => void;
  }) => (
    <div className={styles.keyRow}>
      <span className={styles.masked}>{mask(k.key)}</span>
      <button
        className={styles.iconBtn}
        onClick={() => navigator.clipboard.writeText(k.key)}
        title="Copy key"
      >
        <Copy size={16} />
      </button>
      {onDelete && (
        <button className={styles.iconBtn} onClick={onDelete} title="Delete">
          <Trash2 size={16} />
        </button>
      )}
    </div>
  );

  /* ——————————————————— UI blocks ——————————————————— */
  const SelectorCard = (
    <div className={styles.contentCard}>
      <h2>Dashboards</h2>
      <p>Select a view:</p>
      <div className={styles.switchButtons}>
        <button
          className={styles.switchBtn}
          onClick={() => setMode("user")}
          disabled={mode === "user"}
        >
          User dashboard
        </button>
        <button
          className={styles.switchBtn}
          onClick={() => setMode("provider")}
          disabled={mode === "provider"}
        >
          Provider dashboard
        </button>
        <Link href="/trade">
          <button className={styles.switchBtn}>Trader dashboard</button>
        </Link>
      </div>

      <div className={styles.keysBlock}>
        <h3>
          <KeyRound size={18} /> Primary keys
        </h3>

        <KeyRow
          k={{ key: subject.userAk, creditLimit: 0, creditsLeft: 0, permittedRoutes: [] }}
        />
        <button
          className={styles.iconBtn}
          onClick={() => refreshAk("user")}
          title="Refresh userAk"
        >
          <RefreshCcw size={16} />
        </button>

        <KeyRow
          k={{
            key: subject.providerAk,
            creditLimit: 0,
            creditsLeft: 0,
            permittedRoutes: [],
          }}
        />
        <button
          className={styles.iconBtn}
          onClick={() => refreshAk("provider")}
          title="Refresh providerAk"
        >
          <RefreshCcw size={16} />
        </button>
      </div>
    </div>
  );

  const UserCards = (
    <>
      {/* Rewards */}
      <div className={styles.contentCard}>
        <h2>
          <Wallet size={20} /> Rewards
        </h2>
        <p>{rewards.toLocaleString()} CXPT earned</p>
      </div>

      {/* Credits */}
      <div className={styles.contentCard}>
        <h2>
          <BarChart3 size={20} /> Credits
        </h2>
        <p>{credits.toLocaleString()} remaining</p>
      </div>

      {/* Keys */}
      <div className={styles.contentCard}>
        <h2>
          <KeyRound size={20} /> API keys
        </h2>

        {apiKeys.map((k) => (
          <KeyRow key={k.key} k={k} onDelete={() => deleteKey(k.key)} />
        ))}

        {/* create-key form */}
        <details className={styles.createBox}>
          <summary>+ Create key</summary>
          <form
            action={async (formData) => {
              await createKey(formData);
            }}
            className={styles.createForm}
          >
            <label>
              Credit limit&nbsp;
              <input
                type="number"
                name="credits"
                min={1}
                defaultValue={1000}
                required
              />
            </label>

            <label>
              Allowed routes
              <select name="route" multiple size={4}>
                {ROUTES.map((r) => (
                  <option key={r} value={r}>
                    {r}
                  </option>
                ))}
              </select>
            </label>

            <button type="submit" className={styles.switchBtn}>
              Create
            </button>
          </form>
        </details>
      </div>
    </>
  );

  const ProviderCards = (
    <>
      {/* Earnings */}
      <div className={styles.contentCard}>
        <h2>
          <Wallet size={20} /> Total earnings
        </h2>
        <p>{totalEarnings.toLocaleString()} CXPT</p>

        <svg width="100%" height="60" viewBox="0 0 120 60">
          <polyline
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            points={earnings
              .map((e, i) => {
                const x = (i / Math.max(earnings.length - 1, 1)) * 120;
                const max = Math.max(...earnings.map((d) => d.amount), 1);
                const y = 60 - (e.amount / max) * 50 - 5;
                return `${x},${y}`;
              })
              .join(" ")}
          />
        </svg>
      </div>

      {/* Provisions */}
      <div className={styles.contentCard}>
        <h2>
          <Server size={20} /> Provisions
        </h2>

        {provisions.map((p) => (
          <div key={p.provisionId} className={styles.provisionRow}>
            <span>{p.provisionId}</span>
            <em>{p.status}</em>
            <button
              className={styles.iconBtn}
              onClick={() =>
                setConfirm({
                  msg: "Delete this provision?",
                  onYes: async () => {
                    await fetch(
                      `/api/providers/${subject.providerId}/provisions/${p.provisionId}`,
                      { method: "DELETE" },
                    );
                    fetchProviderData();
                  },
                })
              }
            >
              <Trash2 size={14} />
            </button>
          </div>
        ))}

        {provisions.length === 0 && <p>No active provisions.</p>}
      </div>
    </>
  );

  /* ——————————————————— JSX ——————————————————— */
  return (
    <div className={styles.container}>
      {/* original header + docs link */}
      <div className={styles.header}>
        <h1>Welcome to Cxmpute.cloud!</h1>
        <p>Read more about getting started:</p>
        <Link href="/docs">
          <Button text="Documentation" backgroundColor="var(--cxmpute-purple)" />
        </Link>
      </div>

      {/* selector card (first, outside grid) */}
      {SelectorCard}

      {/* grid cards */}
      <div className={styles.grid}>
        {mode === "user" && UserCards}
        {mode === "provider" && ProviderCards}

        {/* original “promo” cards always stay */}
        <div className={styles.contentCard}>
          <h2>Large-Language / Vision-Language Models</h2>
          <p>Explore open-source LLMs & VLMs available for inference.</p>
          <Link href="/models">
            <Button text="Explore" backgroundColor="var(--cxmpute-green)" />
          </Link>
        </div>
        <div className={styles.contentCard}>
          <h2>Generate Embeddings</h2>
          <p>Open-source embedding models for vector search & RAG.</p>
          <Link href="/models">
            <Button text="Explore" backgroundColor="var(--cxmpute-green)" />
          </Link>
        </div>
        <div className={styles.contentCard}>
          <h2>SOTA Text-to-Speech</h2>
          <p>High-fidelity TTS via Kokoro 82 M.</p>
          <Link href="/models/kokoro-82m">
            <Button text="Explore" backgroundColor="var(--cxmpute-green)" />
          </Link>
        </div>
        <div className={styles.contentCard}>
          <h2>Generate Images & Video</h2>
          <p>Text-to-image / video inference endpoints.</p>
          <Link href="/models">
            <Button text="Explore" backgroundColor="var(--cxmpute-green)" />
          </Link>
        </div>
        <div className={styles.contentCard}>
          <h2>Computer Vision APIs</h2>
          <p>OCR, caption, point & detect objects.</p>
          <Link href="/docs/computer-vision">
            <Button text="Explore" backgroundColor="var(--cxmpute-green)" />
          </Link>
        </div>
        <div className={styles.contentCard}>
          <h2>Web Scraping</h2>
          <p>Bypass rate-limits with our global node network.</p>
          <Link href="/docs/scraping">
            <Button text="Explore" backgroundColor="var(--cxmpute-green)" />
          </Link>
        </div>
      </div>

      {/* trivial modal confirm */}
      {confirm && (
        <div className={styles.backdrop}>
          <div className={styles.modal}>
            <p>{confirm.msg}</p>
            <div className={styles.modalBtns}>
              <button
                onClick={() => {
                  confirm.onYes();
                  setConfirm(null);
                }}
              >
                Yes
              </button>
              <button onClick={() => setConfirm(null)}>Cancel</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
### File: src/components/dashboard/dashboard.module.css
/* ───────── base card & container (unchanged) ───────── */
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  max-width: 650px;
}

.header {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  text-align: center;
}

.contentCard {
  padding: 20px;
  width: 100%;
  border: 2px solid black;
  border-radius: 7px;
  box-shadow: 5px 5px 0 black;
  background: #fff;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

/* ───────── grid (≤2 cols responsive) ───────── */
.grid {
  display: grid;
  gap: 20px;
  grid-template-columns: 1fr;
}

@media (min-width: 680px) {
  .grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* ───────── selector buttons ───────── */
.switchButtons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.switchBtn {
  border: 2px solid black;
  border-radius: 7px;
  padding: 4px 10px;
  background: var(--cxmpute-purple, #91a8eb);
  color: #fff;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 3px 3px 0 black;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.switchBtn:disabled {
  opacity: 0.55;
  cursor: default;
}

.switchBtn:not(:disabled):hover {
  transform: translate(2px, 2px);
  box-shadow: 0 0 0 black;
}

/* ───────── key block ───────── */
.keysBlock h3 {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
  font-size: 0.9rem;
}

.keyRow {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 0.8rem;
}

.masked {
  -webkit-text-security: disc;
  text-security: disc;
  filter: blur(4px);
  user-select: none;
}

/* copy / trash / refresh */
.iconBtn {
  border: none;
  background: transparent;
  cursor: pointer;
  display: flex;
  align-items: center;
}

/* ───────── provision rows ───────── */
.provisionRow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  font-size: 0.8rem;
  word-break: break-all;
}

/* ───────── create-key box ───────── */
.createBox {
  margin-top: 6px;
  cursor: pointer;
}

.createBox[open] summary {
  margin-bottom: 10px;
}

.createForm {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.createForm input,
.createForm select {
  border: 1px solid #bbb;
  border-radius: 4px;
  padding: 4px 6px;
  font-size: 0.85rem;
}

/* ───────── modal confirm ───────── */
.backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0 0 0 / 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.modal {
  background: #fff;
  padding: 20px 24px;
  border: 2px solid black;
  border-radius: 8px;
  box-shadow: 4px 4px 0 black;
  max-width: 320px;
}

.modalBtns {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 16px;
}

.modalBtns button {
  border: 2px solid black;
  border-radius: 6px;
  padding: 4px 12px;
  background: var(--cxmpute-green, #20a191);
  color: #fff;
  cursor: pointer;
  box-shadow: 3px 3px 0 black;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.modalBtns button:hover {
  transform: translate(2px, 2px);
  box-shadow: 0 0 0 black;
}

### File: src/components/map/map.tsx
import {mapstring} from "./mapstring.js";
import DottedMap from "dotted-map/without-countries";

const Map = () => {
    // It’s safe to re-create the map at each render, because of the
    // pre-computation it’s super fast ⚡️
    const map = new DottedMap({ map: JSON.parse(mapstring) });
  
    // map.addPin({
    //   lat: 40.73061,
    //   lng: -73.935242,
    //   svgOptions: { color: '#d6ff79', radius: 0.4 },
    // });
  
    const svgMap = map.getSVG({
      radius: 0.22,
      color: '#ff9f62',
      shape: 'circle',
      backgroundColor: '#f9f5f2',
    });
  
    return (
      <div>
        <img src={`data:image/svg+xml;utf8,${encodeURIComponent(svgMap)}`} />
      </div>
    );
  };
  
  export default Map;
  
### File: src/components/map/map.module.css

### File: src/components/button/button.module.css
.button {
    font-family: "Montserrat", sans-serif;
    font-size: 0.9rem;
    border: 2px solid black;
    border-radius: 7px;
    padding: 0.3rem 0.5rem;
    background-color: white; /* This will be overridden by the inline style prop if provided */
    box-shadow: 5px 5px 0px black;
    cursor: pointer;
    text-align: center;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    transition: all 0.3s ease;
  }
  
  .button:hover {
    box-shadow: 0 0 0 black;
    transform: translateY(3px) translateX(3px);
  }
  
  .icon {
    width: 24px;
    height: 24px;
    transition: all 0.3s ease-in-out;
  }
  
### File: src/components/button/button.tsx
import React from "react";
import styles from "./button.module.css";

type ButtonProps = {
  text: string;
  backgroundColor?: string;
  disabled?: boolean; // add this line
  onClick?: () => void;
};

const Button: React.FC<ButtonProps> = ({ text, backgroundColor = "white", disabled, onClick }) => {
  return (
    <button
      className={styles.button}
      style={{ backgroundColor }}
      disabled={disabled} // add this line
      onClick={onClick}
    >
      {text}
      <svg
        className={styles.icon}
        viewBox="0 0 24 24"
        fill="currentColor"
      >
        <path
          fillRule="evenodd"
          d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm4.28 10.28a.75.75 0 000-1.06l-3-3a.75.75 0 10-1.06 1.06l1.72 1.72H8.25a.75.75 0 000 1.5h5.69l-1.72 1.72a.75.75 0 101.06 1.06l3-3z"
          clipRule="evenodd"
        />
      </svg>
    </button>
  );
};

export default Button;

### File: src/components/faqCard/faqCard.tsx
"use client";
import { useState } from "react";
import styles from "./faqCard.module.css";

interface FAQCardProps {
  question: string;
  answer: string;
}

export default function FAQCard({ question, answer }: FAQCardProps) {
  const [isOpen, setIsOpen] = useState(false);

  const toggleAnswer = () => setIsOpen((prev) => !prev);

  return (
    <div className={styles.faqCard}>
      <div className={styles.faqCardHeader} onClick={toggleAnswer}>
        <h1>{question}</h1>
        <h1>{isOpen ? "-" : "+"}</h1>
      </div>
      {isOpen && (
        <div className={styles.faqCardText}>
          <p>{answer}</p>
        </div>
      )}
    </div>
  );
}

### File: src/components/faqCard/faqCard.module.css
.faqCardHeader{
    display: flex;
    justify-content: space-between;
    cursor: pointer;
}

.faqCard{
    margin-top: 32px;
    margin-bottom: 32px;
}

.faqCard h1{
    font-size: 20px;
    margin-bottom: 24px;
}
### File: src/lib/genSchemaCad.ts
import { z } from "zod";

export const GenResultCad = z.object({
  code: z.string(),
  commentary: z.string().optional(),
  finished: z.boolean().default(false),
});

export type GenResultCadType = z.infer<typeof GenResultCad>;

### File: src/lib/utils.ts
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/lib/utils.ts
import { DynamoDBClient, ConditionalCheckFailedException } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  QueryCommand,
  UpdateCommand,
  GetCommand,
  PutCommand,
  DeleteCommand,
} from "@aws-sdk/lib-dynamodb";
import { Resource } from "sst";
import { ApiKeyInfo, ProviderRecord } from "@/lib/interfaces";

/** 
 * Export a single docClient or separate clients if needed 
 */
const client = new DynamoDBClient({});
export const docClient = DynamoDBDocumentClient.from(client);

/** Helper: get today's date in YYYY-MM-DD */
export function getTodayDateString(): string {
  return new Date().toISOString().split("T")[0];
}

/**
 * Deducts credits from the user and the matched API key if they have enough.
 * Returns { valid: true, user } on success, or { valid: false, reason } if not.
 */
export async function validateApiKey(
  userId: string,
  apiKey: string,
  creditsNeeded: number
): Promise<{ valid: boolean; reason?: string; user?: any }> {
  try {
    // 1) Fetch user
    const userResult = await docClient.send(
      new GetCommand({
        TableName: Resource.UserTable.name,
        Key: { userId },
      })
    );

    if (!userResult.Item) {
      return { valid: false, reason: "User not found" };
    }

    const user = userResult.Item;
    if (!user.apiKeys || !Array.isArray(user.apiKeys)) {
      return { valid: false, reason: "User has no API keys array" };
    }

    // 2) Find the matching API key
    const akIndex = user.apiKeys.findIndex(
      (entry: ApiKeyInfo) => entry.key === apiKey
    );
    if (akIndex === -1) {
      return { valid: false, reason: "API key not found for user" };
    }
    const ak = user.apiKeys[akIndex] as ApiKeyInfo;

    // 3) Check credits
    const userCredits = typeof user.credits === "number" ? user.credits : 0;
    if (userCredits < creditsNeeded) {
      return { valid: false, reason: "User has insufficient total credits" };
    }
    if (ak.creditsLeft < creditsNeeded) {
      return { valid: false, reason: "API key has insufficient creditsLeft" };
    }

    // 4) Check if route is permitted
    const requiredRoute = "/chat/completions";
    if (!ak.permittedRoutes.includes(requiredRoute)) {
      return { valid: false, reason: "Route not permitted" };
    }

    // 5) Deduct credits
    const newUserCredits = userCredits - creditsNeeded;
    const newApiKeyCredits = ak.creditsLeft - creditsNeeded;
    user.credits = newUserCredits;
    user.apiKeys[akIndex] = {
      ...ak,
      creditsLeft: newApiKeyCredits,
    };

    // 6) Concurrency check & update
    try {
      await docClient.send(
        new PutCommand({
          TableName: Resource.UserTable.name,
          Item: user,
          ConditionExpression: `
            #credits = :oldCredits AND
            contains(JSON_STRING(user.apiKeys), :akSegment)
          `,
          ExpressionAttributeNames: {
            "#credits": "credits",
          },
          ExpressionAttributeValues: {
            ":oldCredits": userCredits,
            ":akSegment": `"key":"${apiKey}","creditsLeft":${ak.creditsLeft}`,
          },
        })
      );
    } catch (err) {
      if (err instanceof ConditionalCheckFailedException) {
        return {
          valid: false,
          reason: "User or API key changed concurrently; please retry",
        };
      }
      throw err;
    }

    // 7) Return success
    return { valid: true, user };
  } catch (error) {
    console.error("Error validating API key:", error);
    return { valid: false, reason: "Internal error" };
  }
}

/**
 * Picks a random provision for the given model, using "ByModelRandom" GSI
 */
export async function selectProvision(model: string) {
  const r = Math.random();
  const gsiName = "ByModelRandom";

  let response = await docClient.send(
    new QueryCommand({
      TableName: Resource.LLMProvisionPoolTable.name,
      IndexName: gsiName,
      KeyConditionExpression: "model = :m AND randomValue > :r",
      ExpressionAttributeValues: {
        ":m": model,
        ":r": r,
      },
      Limit: 1,
      ScanIndexForward: true,
    })
  );

  if (!response.Items || response.Items.length === 0) {
    response = await docClient.send(
      new QueryCommand({
        TableName: Resource.LLMProvisionPoolTable.name,
        IndexName: gsiName,
        KeyConditionExpression: "model = :m AND randomValue < :r",
        ExpressionAttributeValues: {
          ":m": model,
          ":r": r,
        },
        Limit: 1,
        ScanIndexForward: false,
      })
    );
  }

  if (!response.Items || response.Items.length === 0) {
    throw new Error(`No provisions available for model: ${model}`);
  }

  return response.Items[0];
}

/** Checks if a provision is healthy with a 10s timeout on /heartbeat */
export async function checkProvisionHealth(provisionEndpoint: string) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 seconds

  try {
    const response = await fetch(`${provisionEndpoint}/heartbeat`, {
      method: "GET",
      headers: { "Content-Type": "application/json" },
      signal: controller.signal,
    });
    return response.ok;
  } catch (error) {
    console.error("Heartbeat check failed:", error);
    return false;
  } finally {
    clearTimeout(timeoutId);
  }
}

/** Remove a provision from the LLM Provision pool table */
export async function removeProvision(provisionId: string) {
  try {
    await docClient.send(
      new DeleteCommand({
        TableName: Resource.LLMProvisionPoolTable.name,
        Key: {
          provisionId,
        },
      })
    );
  } catch (error) {
    console.error("Error removing provision:", error);
  }
}

/** Update daily metadata record for an endpoint */
export async function updateMetadata(
  endpoint: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  latency: number,
  tps: number
) {
  const dateStr = getTodayDateString();
  try {
    // 1) Fetch existing item
    const existing = await docClient.send(
      new GetCommand({
        TableName: Resource.MetadataTable.name,
        Key: {
          endpoint,
          dayTimestamp: dateStr,
        },
      })
    );

    if (existing.Item) {
      const current = existing.Item;
      const oldTotalRequests = current.totalNumRequests ?? 0;
      const oldAvgLatency = current.averageLatency ?? 0;
      const oldAvgTps = current.LLM?.averageTps ?? 0;

      const newAvgLatency =
        (oldAvgLatency * oldTotalRequests + latency) / (oldTotalRequests + 1);
      const newAvgTps =
        (oldAvgTps * oldTotalRequests + tps) / (oldTotalRequests + 1);

      await docClient.send(
        new UpdateCommand({
          TableName: Resource.MetadataTable.name,
          Key: {
            endpoint,
            dayTimestamp: dateStr,
          },
          UpdateExpression: `
            SET
              totalNumRequests = totalNumRequests + :one,
              averageLatency = :newAvgLatency,
              LLM.model = :model,
              LLM.tokensIn = LLM.tokensIn + :incIn,
              LLM.tokensOut = LLM.tokensOut + :incOut,
              LLM.averageTps = :newAvgTps
          `,
          ExpressionAttributeValues: {
            ":one": 1,
            ":newAvgLatency": newAvgLatency,
            ":model": model,
            ":incIn": inputTokens,
            ":incOut": outputTokens,
            ":newAvgTps": newAvgTps,
          },
        })
      );
    } else {
      // Insert a new record
      await docClient.send(
        new PutCommand({
          TableName: Resource.MetadataTable.name,
          Item: {
            endpoint,
            dayTimestamp: dateStr,
            totalNumRequests: 1,
            averageLatency: latency,
            LLM: {
              model,
              tokensIn: inputTokens,
              tokensOut: outputTokens,
              averageTps: tps,
            },
          },
        })
      );
    }
  } catch (error) {
    console.error("Error updating metadata:", error);
  }
}

// For daily usage: 7-day array, or indefinite. We'll keep it simple:
interface ServiceMetadataItem {
  serviceName: string;
  serviceUrl?: string;
  [key: string]: any;
}
interface EndpointUsage {
  totalNumRequests: number;
  requests: Array<{
    dayTimestamp: string;
    numRequests: number;
  }>;
}
interface ModelUsage {
  totalInputTokens: number;
  totalOutputTokens: number;
  totals: Array<{
    dayTimestamp: string;
    numInputTokens: number;
    numOutputTokens: number;
  }>;
}

/**
 * Upsert service metadata. For endpoint != '/chat/completions', we do endpoint usage.
 * For endpoint == '/chat/completions', we do model usage.
 */
export async function updateServiceMetadata(
  serviceName: string,
  serviceUrl: string | null,
  endpoint: string,
  model: string,
  inputTokens: number,
  outputTokens: number
) {
  const day = getTodayDateString();

  try {
    const existingResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Key: { serviceName },
      })
    );
    let item = existingResp.Item as ServiceMetadataItem | undefined;

    // If doesn't exist, create
    if (!item) {
      item = {
        serviceName,
        serviceUrl: serviceUrl ?? undefined,
      };
    }
    // Update serviceUrl if missing
    if (!item.serviceUrl && serviceUrl) {
      item.serviceUrl = serviceUrl;
    }

    if (endpoint !== "/chat/completions") {
      // Endpoint-based usage
      if (!item[endpoint]) {
        const endpointUsage: EndpointUsage = {
          totalNumRequests: 0,
          requests: [],
        };
        item[endpoint] = endpointUsage;
      }
      const epUsage = item[endpoint] as EndpointUsage;
      epUsage.totalNumRequests += 1;

      const existingDay = epUsage.requests.find((r) => r.dayTimestamp === day);
      if (existingDay) {
        existingDay.numRequests += 1;
      } else {
        epUsage.requests.push({ dayTimestamp: day, numRequests: 1 });
      }
    } else {
      // Model-based usage
      if (!item[model]) {
        const modelUsage: ModelUsage = {
          totalInputTokens: 0,
          totalOutputTokens: 0,
          totals: [],
        };
        item[model] = modelUsage;
      }
      const mUsage = item[model] as ModelUsage;
      mUsage.totalInputTokens += inputTokens;
      mUsage.totalOutputTokens += outputTokens;

      const existingDay = mUsage.totals.find((r) => r.dayTimestamp === day);
      if (existingDay) {
        existingDay.numInputTokens += inputTokens;
        existingDay.numOutputTokens += outputTokens;
      } else {
        mUsage.totals.push({
          dayTimestamp: day,
          numInputTokens: inputTokens,
          numOutputTokens: outputTokens,
        });
      }
    }

    // Write it back
    await docClient.send(
      new PutCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Item: item,
      })
    );
  } catch (err) {
    console.error("Error updating service metadata:", err);
  }
}

/** Check if day is within last 30 days */
function isWithinLast30Days(day: string): boolean {
  const dayDate = new Date(day + "T00:00:00Z");
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  return dayDate >= thirtyDaysAgo;
}

/**
 * Reward a provider. Merges reward for today's date if it exists,
 * slides out older-than-30-day entries, and recalculates totalRewards.
 */
export async function rewardProvider(providerId: string, reward: number) {
  try {
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ProviderTable.name,
        Key: { providerId },
      })
    );
    if (!getResp.Item) {
      console.warn("Provider not found for providerId:", providerId);
      return;
    }
    const provider = getResp.Item as ProviderRecord;
    const dateStr = getTodayDateString();

    const oldRewards = provider.rewards ?? [];
    const updatedRewards = oldRewards.filter((r) => isWithinLast30Days(r.day));

    const existingToday = updatedRewards.find((r) => r.day === dateStr);
    if (existingToday) {
      existingToday.amount += reward;
    } else {
      updatedRewards.push({ day: dateStr, amount: reward });
    }

    const newTotal = updatedRewards.reduce((sum, r) => sum + r.amount, 0);
    provider.rewards = updatedRewards;
    provider.totalRewards = newTotal;

    await docClient.send(
      new PutCommand({
        TableName: Resource.ProviderTable.name,
        Item: provider,
      })
    );
  } catch (error) {
    console.error("Error rewarding provider:", error);
  }
}

/* -------------------------------------------------------------------------- */
/*                         Embeddings Provision Logic                         */
/* -------------------------------------------------------------------------- */

/**
 * Picks a random embeddings node from `EmbeddingsProvisionPoolTable`
 * using the "ByModelRandom" GSI (model, randomValue).
 */
export async function selectEmbeddingsProvision(model: string) {
    const r = Math.random();
    const gsiName = "ByModelRandom"; // from your sst config
  
    // 1) Query for randomValue > r
    let response = await docClient.send(
      new QueryCommand({
        TableName: Resource.EmbeddingsProvisionPoolTable.name,
        IndexName: gsiName,
        KeyConditionExpression: "model = :m AND randomValue > :r",
        ExpressionAttributeValues: {
          ":m": model,
          ":r": r,
        },
        Limit: 1,
        ScanIndexForward: true,
      })
    );
  
    // 2) If none found, query randomValue < r
    if (!response.Items || response.Items.length === 0) {
      response = await docClient.send(
        new QueryCommand({
          TableName: Resource.EmbeddingsProvisionPoolTable.name,
          IndexName: gsiName,
          KeyConditionExpression: "model = :m AND randomValue < :r",
          ExpressionAttributeValues: {
            ":m": model,
            ":r": r,
          },
          Limit: 1,
          ScanIndexForward: false,
        })
      );
    }
  
    if (!response.Items || response.Items.length === 0) {
      throw new Error(`No embeddings provisions available for model: ${model}`);
    }
    return response.Items[0];
  }
  
  /**
   * Check if an embeddings node is healthy
   */
  export async function checkEmbeddingsHealth(endpoint: string): Promise<boolean> {
    try {
      const resp = await fetch(`${endpoint}/heartbeat`, { method: "GET" });
      return resp.ok;
    } catch (err) {
      console.error("Embeddings node heartbeat failed:", err);
      return false;
    }
  }
  
  /**
   * Remove an unhealthy embeddings node from the table
   */
  export async function removeEmbeddingsProvision(provisionId: string) {
    try {
      await docClient.send(
        new DeleteCommand({
          TableName: Resource.EmbeddingsProvisionPoolTable.name,
          Key: { provisionId },
        })
      );
    } catch (err) {
      console.error("Error removing embeddings provision:", err);
    }
  }
  
  /* -------------------------------------------------------------------------- */
  /*                          Metadata & Service Logging                        */
  /* -------------------------------------------------------------------------- */
  
  /**
   * Update daily metadata for /embeddings, similar to your chat approach.
   * We'll store it under endpoint="/embeddings".
   */
  export async function updateEmbeddingsMetadata(
    latency: number
  ) {
    const dateStr = getTodayDateString();
    // Freed to handle how you like, here's a short example:
    try {
      const getResp = await docClient.send(
        new GetCommand({
          TableName: Resource.MetadataTable.name,
          Key: {
            endpoint: "/embeddings",
            dayTimestamp: dateStr,
          },
        })
      );
  
      if (!getResp.Item) {
        // Insert
        await docClient.send(
          new PutCommand({
            TableName: Resource.MetadataTable.name,
            Item: {
              endpoint: "/embeddings",
              dayTimestamp: dateStr,
              totalNumRequests: 1,
              averageLatency: latency,
            },
          })
        );
      } else {
        // Update existing
        const oldItem = getResp.Item;
        const oldCount = oldItem.totalNumRequests ?? 0;
        const oldLat = oldItem.averageLatency ?? 0;
        const newAvgLat = (oldLat * oldCount + latency) / (oldCount + 1);

  
        await docClient.send(
          new PutCommand({
            TableName: Resource.MetadataTable.name,
            Item: {
              ...oldItem,
              totalNumRequests: oldCount + 1,
              averageLatency: newAvgLat
            },
          })
        );
      }
    } catch (err) {
      console.error("Error updating embeddings metadata:", err);
    }
  }
  
  /**
   * Update service metadata for /embeddings. 
   * We'll treat /embeddings like an endpoint, but you can also track the model if you prefer.
   */
  export async function updateEmbeddingsServiceMetadata(
    serviceName: string,
    serviceUrl: string | null,
  ) {
    const day = getTodayDateString();
    try {
      const getResp = await docClient.send(
        new GetCommand({
          TableName: Resource.ServiceMetadataTable.name,
          Key: { serviceName },
        })
      );
      const item = getResp.Item || { serviceName };
  
      // If the serviceUrl is new, store it
      if (!item.serviceUrl && serviceUrl) {
        item.serviceUrl = serviceUrl;
      }
  
      // We'll store usage at item["/embeddings"]
      const endpointKey = "/embeddings";
      if (!item[endpointKey]) {
        item[endpointKey] = {
          totalNumRequests: 0,
          requests: [],
        };
      }
      const epUsage = item[endpointKey];
      epUsage.totalNumRequests += 1;
  
      const existingDay = epUsage.requests.find((r: any) => r.dayTimestamp === day);
      if (existingDay) {
        existingDay.numRequests += 1;
      } else {
        epUsage.requests.push({
          dayTimestamp: day,
          numRequests: 1,
        });
      }
  
      // Optionally also track usage per model. This is up to you. 
      // For now, let's keep it simple.
  
      await docClient.send(
        new PutCommand({
          TableName: Resource.ServiceMetadataTable.name,
          Item: item,
        })
      );
    } catch (err) {
      console.error("Error updating embeddings service metadata:", err);
    }
  }

/* -------------------------------------------------------------------------- */
/*                      Image Provision / Media Table Logic                   */
/* -------------------------------------------------------------------------- */

/** 
 * Picks a random "image" node from the `MediaProvisionPoolTable`. 
 * We assume we store items with `type="image"` and `model=<some model>`. 
 * Possibly you want to allow `model` to be optional.  
 */
export async function selectImageProvision(model: string) {
  const r = Math.random();
  // We’ll assume you have a GSI "ByModelAndTypeRandom" or similar 
  // that has (model, randomValue) as key. Also ensure item.type="image".
  const gsiName = "ByModelAndTypeRandom"; // from your SST config if you set that up for model + randomValue

  // Query #1 => randomValue > r
  let response = await docClient.send(
    new QueryCommand({
      TableName: Resource.MediaProvisionPoolTable.name,
      IndexName: gsiName,
      // If you store "type" in your table, you might do a FilterExpression => "type = :image"
      // but more robust is a GSI that includes "type" in the key. For now, let's keep it simple:
      KeyConditionExpression: "model = :m AND randomValue > :r",
      ExpressionAttributeValues: {
        ":m": model,
        ":r": r,
      },
      Limit: 1,
      ScanIndexForward: true,
    })
  );

  if (!response.Items || response.Items.length === 0) {
    // Query #2 => randomValue < r
    response = await docClient.send(
      new QueryCommand({
        TableName: Resource.MediaProvisionPoolTable.name,
        IndexName: gsiName,
        KeyConditionExpression: "model = :m AND randomValue < :r",
        ExpressionAttributeValues: {
          ":m": model,
          ":r": r,
        },
        Limit: 1,
        ScanIndexForward: false,
      })
    );
  }

  if (!response.Items || response.Items.length === 0) {
    throw new Error(`No image provisions available for model: ${model}`);
  }

  return response.Items[0];
}

/** Checks if the image node’s /heartbeat is healthy */
export async function checkImageHealth(endpoint: string): Promise<boolean> {
  try {
    const resp = await fetch(`${endpoint}/heartbeat`, { method: "GET" });
    return resp.ok;
  } catch (err) {
    console.error("Image node heartbeat check failed:", err);
    return false;
  }
}

/** Removes the image node from the table if it’s unhealthy after 3 tries */
export async function removeImageProvision(provisionId: string) {
  try {
    await docClient.send(
      new DeleteCommand({
        TableName: Resource.MediaProvisionPoolTable.name,
        Key: { provisionId },
      })
    );
  } catch (error) {
    console.error("Error removing image provision:", error);
  }
}

/** 
 * We can store daily usage in the same "MetadataTable" under endpoint="/image" 
 * or "/image/<model>" – up to you. 
 */
export async function updateImageMetadata(
  latency: number
) {
  // For tokens, you might say inputTokens = promptLength, 
  // outputTokens = imageSize, or any logic you prefer.
  const endpoint = "/image";
  const dayStr = getTodayDateString();

  try {
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.MetadataTable.name,
        Key: { endpoint, dayTimestamp: dayStr },
      })
    );

    if (!getResp.Item) {
      // Insert new
      await docClient.send(
        new PutCommand({
          TableName: Resource.MetadataTable.name,
          Item: {
            endpoint,
            dayTimestamp: dayStr,
            totalNumRequests: 1,
            averageLatency: latency,
          },
        })
      );
    } else {
      // Update existing
      const oldItem = getResp.Item;
      const oldCount = oldItem.totalNumRequests ?? 0;
      const oldAvgLat = oldItem.averageLatency ?? 0;
      const newAvgLat = (oldAvgLat * oldCount + latency) / (oldCount + 1);

      await docClient.send(
        new PutCommand({
          TableName: Resource.MetadataTable.name,
          Item: {
            ...oldItem,
            totalNumRequests: oldCount + 1,
            averageLatency: newAvgLat,
          },
        })
      );
    }
  } catch (err) {
    console.error("Error updating image metadata:", err);
  }
}

/** 
 * Upsert service metadata for /image. If you want to handle model usage, you can. 
 */
export async function updateImageServiceMetadata(serviceName: string, serviceUrl: string | null) {
  const endpointKey = "/image";
  const dayStr = getTodayDateString();

  try {
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Key: { serviceName },
      })
    );

    const item = getResp.Item || { serviceName };
    // store serviceUrl if not present
    if (!item.serviceUrl && serviceUrl) {
      item.serviceUrl = serviceUrl;
    }

    if (!item[endpointKey]) {
      item[endpointKey] = {
        totalNumRequests: 0,
        requests: [],
      };
    }
    const epUsage = item[endpointKey];
    epUsage.totalNumRequests += 1;

    const existingDay = epUsage.requests.find((r: any) => r.dayTimestamp === dayStr);
    if (existingDay) {
      existingDay.numRequests += 1;
    } else {
      epUsage.requests.push({
        dayTimestamp: dayStr,
        numRequests: 1,
      });
    }

    await docClient.send(
      new PutCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Item: item,
      })
    );
  } catch (err) {
    console.error("Error updating image service metadata:", err);
  }
}

// Moon api
/**
 * 1) Select a random "moon" provision from the MoonProvisionPoolTable
 *    using the GSI "ByRandom" => randomValue in [0..1).
 */
export async function selectMoonProvision() {
    const r = Math.random();
    const gsiName = "ByRandom"; // from your sst config
  
    // Query #1 => randomValue > r
    let response = await docClient.send(
      new QueryCommand({
        TableName: Resource.MoonProvisionPoolTable.name,
        IndexName: gsiName,
        KeyConditionExpression: "randomValue > :r",
        ExpressionAttributeValues: {
          ":r": r,
        },
        Limit: 1,
        ScanIndexForward: true,
      })
    );
  
    if (!response.Items || response.Items.length === 0) {
      // Query #2 => randomValue < r
      response = await docClient.send(
        new QueryCommand({
          TableName: Resource.MoonProvisionPoolTable.name,
          IndexName: gsiName,
          KeyConditionExpression: "randomValue < :r",
          ExpressionAttributeValues: {
            ":r": r,
          },
          Limit: 1,
          ScanIndexForward: false,
        })
      );
    }
  
    if (!response.Items || response.Items.length === 0) {
      throw new Error("No moon provisions available");
    }
    return response.Items[0];
  }
  
  /** 2) Check the health of a moon node by calling `endpoint/heartbeat` */
  export async function checkMoonHealth(endpoint: string): Promise<boolean> {
    try {
      const resp = await fetch(`${endpoint}/heartbeat`, { method: "GET" });
      return resp.ok;
    } catch (err) {
      console.error("Moon node heartbeat failed:", err);
      return false;
    }
  }
  
  /** 3) Remove a dead moon node after 3 attempts */
  export async function removeMoonProvision(provisionId: string) {
    try {
      await docClient.send(
        new DeleteCommand({
          TableName: Resource.MoonProvisionPoolTable.name,
          Key: { provisionId },
        })
      );
    } catch (err) {
      console.error("Error removing moon provision:", err);
    }
  }
  
  /**
   * 4) Update daily metadata for /m/* endpoints
   *    We'll store `endpoint` = "/m/query" | "/m/caption" | ...
   *    Up to you how to measure tokens or inputSize or outputSize.
   */
  export async function updateMoonMetadata(
    endpoint: string,
    latency: number
  ) {
    const dayStr = getTodayDateString();
    try {
      // get existing item
      const getResp = await docClient.send(
        new GetCommand({
          TableName: Resource.MetadataTable.name,
          Key: { endpoint, dayTimestamp: dayStr },
        })
      );
      if (!getResp.Item) {
        // Insert
        await docClient.send(
          new PutCommand({
            TableName: Resource.MetadataTable.name,
            Item: {
              endpoint,
              dayTimestamp: dayStr,
              totalNumRequests: 1,
              averageLatency: latency,
            },
          })
        );
      } else {
        const oldItem = getResp.Item;
        const oldCount = oldItem.totalNumRequests ?? 0;
        const oldLat = oldItem.averageLatency ?? 0;
        const newAvgLat = (oldLat * oldCount + latency) / (oldCount + 1);
  
        await docClient.send(
          new PutCommand({
            TableName: Resource.MetadataTable.name,
            Item: {
              ...oldItem,
              totalNumRequests: oldCount + 1,
              averageLatency: newAvgLat,
            },
          })
        );
      }
    } catch (err) {
      console.error("Error updating moon metadata:", err);
    }
  }
  
  /**
   * 5) Update service metadata for /m/* endpoints
   *    We'll store usage at item["/m/query"], item["/m/caption"], etc.
   */
  export async function updateMoonServiceMetadata(
    serviceName: string,
    serviceUrl: string | null,
    endpoint: string
  ) {
    const dayStr = getTodayDateString();
    try {
      const getResp = await docClient.send(
        new GetCommand({
          TableName: Resource.ServiceMetadataTable.name,
          Key: { serviceName },
        })
      );
      const item = getResp.Item || { serviceName };
      if (!item.serviceUrl && serviceUrl) {
        item.serviceUrl = serviceUrl;
      }
  
      if (!item[endpoint]) {
        item[endpoint] = {
          totalNumRequests: 0,
          requests: [],
        };
      }
      item[endpoint].totalNumRequests += 1;
  
      const epUsage = item[endpoint];
      const existingDay = epUsage.requests.find((r: any) => r.dayTimestamp === dayStr);
      if (existingDay) {
        existingDay.numRequests += 1;
      } else {
        epUsage.requests.push({
          dayTimestamp: dayStr,
          numRequests: 1,
        });
      }
  
      await docClient.send(
        new PutCommand({
          TableName: Resource.ServiceMetadataTable.name,
          Item: item,
        })
      );
    } catch (err) {
      console.error("Error updating moon service metadata:", err);
    }
  }

/* -------------------------------------------------------------------------- */
/*                         Scraping Provision Logic                           */
/* -------------------------------------------------------------------------- */

/**
 * Picks a random scraping node from `ScrapingProvisionPoolTable` 
 * using the "ByRandom" index (randomValue in [0..1)).
 */
export async function selectScrapingProvision() {
  const r = Math.random();
  const gsiName = "ByRandom"; // from your sst config

  // 1) Query for randomValue > r
  let response = await docClient.send(
    new QueryCommand({
      TableName: Resource.ScrapingProvisionPoolTable.name,
      IndexName: gsiName,
      KeyConditionExpression: "randomValue > :r",
      ExpressionAttributeValues: {
        ":r": r,
      },
      Limit: 1,
      ScanIndexForward: true,
    })
  );

  // 2) If none found, query randomValue < r
  if (!response.Items || response.Items.length === 0) {
    response = await docClient.send(
      new QueryCommand({
        TableName: Resource.ScrapingProvisionPoolTable.name,
        IndexName: gsiName,
        KeyConditionExpression: "randomValue < :r",
        ExpressionAttributeValues: {
          ":r": r,
        },
        Limit: 1,
        ScanIndexForward: false,
      })
    );
  }

  if (!response.Items || response.Items.length === 0) {
    throw new Error("No scraping provisions available");
  }
  return response.Items[0];
}

/** Checks if a scraping node is healthy by calling /heartbeat */
export async function checkScrapingHealth(endpoint: string): Promise<boolean> {
  try {
    const resp = await fetch(`${endpoint}/heartbeat`, { method: "GET" });
    return resp.ok;
  } catch (err) {
    console.error("Scraping node heartbeat check failed:", err);
    return false;
  }
}

/** Removes a scraping node from the table if unhealthy after 3 tries */
export async function removeScrapingProvision(provisionId: string) {
  try {
    await docClient.send(
      new DeleteCommand({
        TableName: Resource.ScrapingProvisionPoolTable.name,
        Key: { provisionId },
      })
    );
  } catch (err) {
    console.error("Error removing scraping provision:", err);
  }
}

/**
 * Update daily metadata for /scrape. 
 * We store in the same "MetadataTable" with endpoint="/scrape".
 */
export async function updateScrapeMetadata(latency: number) {
  const endpoint = "/scrape";
  const dayStr = getTodayDateString();

  try {
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.MetadataTable.name,
        Key: { endpoint, dayTimestamp: dayStr },
      })
    );

    if (!getResp.Item) {
      // Insert
      await docClient.send(
        new PutCommand({
          TableName: Resource.MetadataTable.name,
          Item: {
            endpoint,
            dayTimestamp: dayStr,
            totalNumRequests: 1,
            averageLatency: latency,
          },
        })
      );
    } else {
      // Update existing
      const oldItem = getResp.Item;
      const oldCount = oldItem.totalNumRequests ?? 0;
      const oldLat = oldItem.averageLatency ?? 0;
      const newAvgLat = (oldLat * oldCount + latency) / (oldCount + 1);

      await docClient.send(
        new PutCommand({
          TableName: Resource.MetadataTable.name,
          Item: {
            ...oldItem,
            totalNumRequests: oldCount + 1,
            averageLatency: newAvgLat,
          },
        })
      );
    }
  } catch (err) {
    console.error("Error updating /scrape metadata:", err);
  }
}

/**
 * Update service metadata for /scrape. 
 * We'll treat "/scrape" as an endpoint in ServiceMetadataTable.
 */
export async function updateScrapeServiceMetadata(
  serviceName: string,
  serviceUrl: string | null
) {
  const endpointKey = "/scrape";
  const dayStr = getTodayDateString();

  try {
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Key: { serviceName },
      })
    );
    const item = getResp.Item || { serviceName };

    // If new serviceUrl, store it
    if (!item.serviceUrl && serviceUrl) {
      item.serviceUrl = serviceUrl;
    }

    // If we haven't used "/scrape" yet, create it
    if (!item[endpointKey]) {
      item[endpointKey] = {
        totalNumRequests: 0,
        requests: [],
      };
    }
    const epUsage = item[endpointKey];
    epUsage.totalNumRequests += 1;

    // Append or update today's usage
    const existingDay = epUsage.requests.find((r: any) => r.dayTimestamp === dayStr);
    if (existingDay) {
      existingDay.numRequests += 1;
    } else {
      epUsage.requests.push({
        dayTimestamp: dayStr,
        numRequests: 1,
      });
    }

    await docClient.send(
      new PutCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Item: item,
      })
    );
  } catch (err) {
    console.error("Error updating /scrape service metadata:", err);
  }
}

/* -------------------------------------------------------------------------- */
/*                            TTS Provision Logic                             */
/* -------------------------------------------------------------------------- */

/**
 * Picks a random TTS node from `TTSProvisionPoolTable` 
 * using the "ByModelRandom" GSI (model, randomValue).
 */
export async function selectTTSProvision(model: string) {
    const r = Math.random();
    const gsiName = "ByModelRandom"; // from your sst config
  
    // Query #1 => randomValue > r
    let response = await docClient.send(
      new QueryCommand({
        TableName: Resource.TTSProvisionPoolTable.name,
        IndexName: gsiName,
        KeyConditionExpression: "model = :m AND randomValue > :r",
        ExpressionAttributeValues: {
          ":m": model,
          ":r": r,
        },
        Limit: 1,
        ScanIndexForward: true,
      })
    );
  
    if (!response.Items || response.Items.length === 0) {
      // Query #2 => randomValue < r
      response = await docClient.send(
        new QueryCommand({
          TableName: Resource.TTSProvisionPoolTable.name,
          IndexName: gsiName,
          KeyConditionExpression: "model = :m AND randomValue < :r",
          ExpressionAttributeValues: {
            ":m": model,
            ":r": r,
          },
          Limit: 1,
          ScanIndexForward: false,
        })
      );
    }
  
    if (!response.Items || response.Items.length === 0) {
      throw new Error(`No TTS provisions available for model: ${model}`);
    }
    return response.Items[0];
  }
  
  /** Check if TTS node is healthy by calling /heartbeat */
  export async function checkTTSHealth(endpoint: string): Promise<boolean> {
    try {
      const resp = await fetch(`${endpoint}/heartbeat`, { method: "GET" });
      return resp.ok;
    } catch (err) {
      console.error("TTS node heartbeat failed:", err);
      return false;
    }
  }
  
  /** Remove TTS node from the table if it’s unhealthy after 3 tries */
  export async function removeTTSProvision(provisionId: string) {
    try {
      await docClient.send(
        new DeleteCommand({
          TableName: Resource.TTSProvisionPoolTable.name,
          Key: { provisionId },
        })
      );
    } catch (err) {
      console.error("Error removing TTS provision:", err);
    }
  }
  
  /**
   * Update daily metadata for /tts in the "MetadataTable".
   */
  export async function updateTTSMetadata(latency: number) {
    const endpoint = "/tts";
    const dayStr = getTodayDateString();
  
    try {
      const getResp = await docClient.send(
        new GetCommand({
          TableName: Resource.MetadataTable.name,
          Key: { endpoint, dayTimestamp: dayStr },
        })
      );
  
      if (!getResp.Item) {
        // Create
        await docClient.send(
          new PutCommand({
            TableName: Resource.MetadataTable.name,
            Item: {
              endpoint,
              dayTimestamp: dayStr,
              totalNumRequests: 1,
              averageLatency: latency,
            },
          })
        );
      } else {
        // Update
        const oldItem = getResp.Item;
        const oldCount = oldItem.totalNumRequests ?? 0;
        const oldLat = oldItem.averageLatency ?? 0;
        const newAvgLat = (oldLat * oldCount + latency) / (oldCount + 1);
  
        await docClient.send(
          new PutCommand({
            TableName: Resource.MetadataTable.name,
            Item: {
              ...oldItem,
              totalNumRequests: oldCount + 1,
              averageLatency: newAvgLat,
            },
          })
        );
      }
    } catch (err) {
      console.error("Error updating TTS metadata:", err);
    }
  }
  
  /**
   * Update service metadata for /tts in the "ServiceMetadataTable".
   */
  export async function updateTTSServiceMetadata(serviceName: string, serviceUrl: string | null) {
    const endpointKey = "/tts";
    const dayStr = getTodayDateString();
  
    try {
      const getResp = await docClient.send(
        new GetCommand({
          TableName: Resource.ServiceMetadataTable.name,
          Key: { serviceName },
        })
      );
      const item = getResp.Item || { serviceName };
  
      // If new serviceUrl, store it
      if (!item.serviceUrl && serviceUrl) {
        item.serviceUrl = serviceUrl;
      }
  
      if (!item[endpointKey]) {
        item[endpointKey] = {
          totalNumRequests: 0,
          requests: [],
        };
      }
      const epUsage = item[endpointKey];
      epUsage.totalNumRequests += 1;
  
      const existingDay = epUsage.requests.find((r: any) => r.dayTimestamp === dayStr);
      if (existingDay) {
        existingDay.numRequests += 1;
      } else {
        epUsage.requests.push({
          dayTimestamp: dayStr,
          numRequests: 1,
        });
      }
  
      await docClient.send(
        new PutCommand({
          TableName: Resource.ServiceMetadataTable.name,
          Item: item,
        })
      );
    } catch (err) {
      console.error("Error updating TTS service metadata:", err);
    }
  }
  

/* -------------------------------------------------------------------------- */
/*                           Video Provision Logic                            */
/* -------------------------------------------------------------------------- */

/**
 * Picks a random "video" node from the `MediaProvisionPoolTable`.
 * We assume items have `type="video"`, `model=<some model>`, and randomValue in [0..1).
 * We use the "ByModelAndTypeRandom" GSI. 
 */
export async function selectVideoProvision(model: string) {
  const r = Math.random();
  const gsiName = "ByModelAndTypeRandom"; // from your sst config (hashKey=model, rangeKey=randomValue)
  
  // Query #1 => randomValue > r
  let response = await docClient.send(
    new QueryCommand({
      TableName: Resource.MediaProvisionPoolTable.name,
      IndexName: gsiName,
      KeyConditionExpression: "model = :m AND randomValue > :r",
      ExpressionAttributeValues: {
        ":m": model,
        ":r": r,
      },
      Limit: 1,
      ScanIndexForward: true,
    })
  );

  // If no item found, query randomValue < r
  if (!response.Items || response.Items.length === 0) {
    response = await docClient.send(
      new QueryCommand({
        TableName: Resource.MediaProvisionPoolTable.name,
        IndexName: gsiName,
        KeyConditionExpression: "model = :m AND randomValue < :r",
        ExpressionAttributeValues: {
          ":m": model,
          ":r": r,
        },
        Limit: 1,
        ScanIndexForward: false,
      })
    );
  }

  if (!response.Items || response.Items.length === 0) {
    throw new Error(`No video provisions available for model: ${model}`);
  }
  // Return the single item
  return response.Items[0];
}

/** Check if a video node is healthy by calling `endpoint/heartbeat` */
export async function checkVideoHealth(endpoint: string): Promise<boolean> {
  try {
    const resp = await fetch(`${endpoint}/heartbeat`, { method: "GET" });
    return resp.ok;
  } catch (err) {
    console.error("Video node heartbeat failed:", err);
    return false;
  }
}

/** Remove a video provision from `MediaProvisionPoolTable` if unhealthy */
export async function removeVideoProvision(provisionId: string) {
  try {
    await docClient.send(
      new DeleteCommand({
        TableName: Resource.MediaProvisionPoolTable.name,
        Key: { provisionId },
      })
    );
  } catch (err) {
    console.error("Error removing video provision:", err);
  }
}

/**
 * Update daily metadata for /video in the "MetadataTable".
 * We'll store the record with endpoint="/video".
 */
export async function updateVideoMetadata(latency: number) {
  const endpoint = "/video";
  const dayStr = getTodayDateString();

  try {
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.MetadataTable.name,
        Key: { endpoint, dayTimestamp: dayStr },
      })
    );

    if (!getResp.Item) {
      // Insert
      await docClient.send(
        new PutCommand({
          TableName: Resource.MetadataTable.name,
          Item: {
            endpoint,
            dayTimestamp: dayStr,
            totalNumRequests: 1,
            averageLatency: latency,
          },
        })
      );
    } else {
      // Update
      const oldItem = getResp.Item;
      const oldCount = oldItem.totalNumRequests ?? 0;
      const oldLat = oldItem.averageLatency ?? 0;
      const newAvgLat = (oldLat * oldCount + latency) / (oldCount + 1);

      await docClient.send(
        new PutCommand({
          TableName: Resource.MetadataTable.name,
          Item: {
            ...oldItem,
            totalNumRequests: oldCount + 1,
            averageLatency: newAvgLat,
          },
        })
      );
    }
  } catch (err) {
    console.error("Error updating /video metadata:", err);
  }
}

/**
 * Update service metadata for /video in the "ServiceMetadataTable".
 */
export async function updateVideoServiceMetadata(serviceName: string, serviceUrl: string | null) {
  const endpointKey = "/video";
  const dayStr = getTodayDateString();

  try {
    const getResp = await docClient.send(
      new GetCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Key: { serviceName },
      })
    );
    const item = getResp.Item || { serviceName };

    // If new serviceUrl, store it
    if (!item.serviceUrl && serviceUrl) {
      item.serviceUrl = serviceUrl;
    }

    if (!item[endpointKey]) {
      item[endpointKey] = {
        totalNumRequests: 0,
        requests: [],
      };
    }
    const epUsage = item[endpointKey];
    epUsage.totalNumRequests += 1;

    const existingDay = epUsage.requests.find((r: any) => r.dayTimestamp === dayStr);
    if (existingDay) {
      existingDay.numRequests += 1;
    } else {
      epUsage.requests.push({ dayTimestamp: dayStr, numRequests: 1 });
    }

    await docClient.send(
      new PutCommand({
        TableName: Resource.ServiceMetadataTable.name,
        Item: item,
      })
    );
  } catch (err) {
    console.error("Error updating /video service metadata:", err);
  }
}

### File: src/lib/genSchema.ts
import { z } from "zod";

export const GenResult = z.object({
  code: z.string(),
  commentary: z.string().optional(),
  finished: z.boolean().default(false)
});

// Handy TypeScript alias
export type GenResultType = z.infer<typeof GenResult>;

### File: src/lib/references.ts
interface SystemMetadataRecord {
    endpoint: string;        // API endpoint
    model?: string;          // Optional model name
    vramRequired: number;    // in MB
    storageRequired: number; // in MB
    provisionTargetNumber: number;
  }
  
  export const SystemProvisionReference: SystemMetadataRecord[] = [
    // EMBEDDINGS
    {
      endpoint: "/embeddings",
      model: "nomic-embed-text",
      vramRequired: 274,
      storageRequired: 274,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "mxbai-embed-large",
      vramRequired: 670,
      storageRequired: 670,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "bge-m3",
      vramRequired: 1200,
      storageRequired: 1200,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "snowflake-arctic-embed:22m",
      vramRequired: 46,
      storageRequired: 46,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "snowflake-arctic-embed:33m",
      vramRequired: 67,
      storageRequired: 67,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "snowflake-arctic-embed:110m",
      vramRequired: 219,
      storageRequired: 219,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "snowflake-arctic-embed:137m",
      vramRequired: 274,
      storageRequired: 274,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "snowflake-arctic-embed:335m",
      vramRequired: 669,
      storageRequired: 669,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "all-minilm:33m",
      vramRequired: 67,
      storageRequired: 67,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "all-minilm:22m",
      vramRequired: 46,
      storageRequired: 46,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/embeddings",
      model: "snowflake-arctic-embed2",
      vramRequired: 1200,
      storageRequired: 1200,
      provisionTargetNumber: 10000,
    },
  
    // VISION (all share /chat/completions)
    {
      endpoint: "/chat/completions",
      model: "gemma3:1b",
      vramRequired: 815,
      storageRequired: 815,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "gemma3:4b",
      vramRequired: 3300,
      storageRequired: 3300,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "gemma3:12b",
      vramRequired: 8100,
      storageRequired: 8100,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "gemma3:24b",
      vramRequired: 17000,
      storageRequired: 17000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "llama3.2-vision:11b",
      vramRequired: 7900,
      storageRequired: 7900,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "minicpm-v",
      vramRequired: 5500,
      storageRequired: 5500,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "llava-llama3",
      vramRequired: 5500,
      storageRequired: 5500,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "moondream",
      vramRequired: 1700,
      storageRequired: 1700,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "granite3.2-vision",
      vramRequired: 2400,
      storageRequired: 2400,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "mistral-small3.1",
      vramRequired: 15000,
      storageRequired: 15000,
      provisionTargetNumber: 10000,
    },
  
    // TEXT (/chat/completions)
    {
      endpoint: "/chat/completions",
      model: "cogito:14b",
      vramRequired: 9000,
      storageRequired: 9000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "cogito:32b",
      vramRequired: 20000,
      storageRequired: 20000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "cogito:3b",
      vramRequired: 2200,
      storageRequired: 2200,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "cogito:70b",
      vramRequired: 43000,
      storageRequired: 43000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "cogito:8b",
      vramRequired: 4900,
      storageRequired: 4900,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-r1:1.5b",
      vramRequired: 1100,
      storageRequired: 1100,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-r1:14b",
      vramRequired: 9000,
      storageRequired: 9000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-r1:32b",
      vramRequired: 20000,
      storageRequired: 20000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-r1:70b",
      vramRequired: 43000,
      storageRequired: 43000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-r1:7b",
      vramRequired: 4700,
      storageRequired: 4700,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-r1:8b",
      vramRequired: 4900,
      storageRequired: 4900,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "llama3.1:8b",
      vramRequired: 4900,
      storageRequired: 4900,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "llama3.2:1b",
      vramRequired: 1300,
      storageRequired: 1300,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "llama3.2:3b",
      vramRequired: 2000,
      storageRequired: 2000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "llama3.3",
      vramRequired: 43000,
      storageRequired: 43000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "mistral",
      vramRequired: 4100,
      storageRequired: 4100,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "mistral-nemo",
      vramRequired: 7100,
      storageRequired: 7100,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "phi4",
      vramRequired: 9100,
      storageRequired: 9100,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "phi4-mini",
      vramRequired: 2600,
      storageRequired: 2600,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2.5:14b",
      vramRequired: 9000,
      storageRequired: 9000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2.5:32b",
      vramRequired: 20000,
      storageRequired: 20000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2.5:72b",
      vramRequired: 47000,
      storageRequired: 47000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2.5:7b",
      vramRequired: 4700,
      storageRequired: 4700,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwq",
      vramRequired: 20000,
      storageRequired: 20000,
      provisionTargetNumber: 10000,
    },
  
    // MATH (/chat/completions)
    {
      endpoint: "/chat/completions",
      model: "mathstral",
      vramRequired: 4100,
      storageRequired: 4100,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2-math:7b",
      vramRequired: 4400,
      storageRequired: 4400,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2-math:72b",
      vramRequired: 41000,
      storageRequired: 41000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepscaler",
      vramRequired: 3600,
      storageRequired: 3600,
      provisionTargetNumber: 10000,
    },
  
    // CODE (/chat/completions)
    {
      endpoint: "/chat/completions",
      model: "qwen2.5-coder:3b",
      vramRequired: 1900,
      storageRequired: 1900,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2.5-coder:7b",
      vramRequired: 4700,
      storageRequired: 4700,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2.5-coder:14b",
      vramRequired: 9000,
      storageRequired: 9000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "qwen2.5-coder:32b",
      vramRequired: 20000,
      storageRequired: 20000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepcoder:14b",
      vramRequired: 9000,
      storageRequired: 9000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "codegemma:2b",
      vramRequired: 1600,
      storageRequired: 1600,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "codegemma:7b",
      vramRequired: 5000,
      storageRequired: 5000,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-coder:1.3b",
      vramRequired: 776,
      storageRequired: 776,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-coder:6.7b",
      vramRequired: 3800,
      storageRequired: 3800,
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/chat/completions",
      model: "deepseek-coder-v2:16b",
      vramRequired: 8900,
      storageRequired: 8900,
      provisionTargetNumber: 10000,
    },
  
    // IMAGE
    {
      endpoint: "/image",
      model: "stable diffusion 2.1",
      vramRequired: 8192,    // 8 GB
      storageRequired: 2048, // 2 GB
      provisionTargetNumber: 10000,
    },
  
    // AUDIO
    {
      endpoint: "/tts",
      model: "kokoro-82m",
      vramRequired: 90,
      storageRequired: 90,
      provisionTargetNumber: 10000,
    },
  
    // VIDEO
    {
      endpoint: "/video",
      model: "Wan-AI/Wan2.1-T2V-1.3B",
      vramRequired: 8192,     // 8 GB
      storageRequired: 20000, // 20 GB
      provisionTargetNumber: 10000,
    },
    {
      endpoint: "/m",
      vramRequired: 2500,     // 2.5 GB
      storageRequired: 2500, // 20 GB
      provisionTargetNumber: 10000,
    }
  ];

// Helper function to parse modalities
const parseModalities = (modalitiesString: string): string[] => {
  if (!modalitiesString) {
    return [];
  }
  return modalitiesString.split(',').map(m => m.trim()).filter(m => m);
};

// Helper function to attempt parsing vector size from outputLength for embeddings
const parseVectorSize = (category: string, outputLengthStr: string | undefined): number | undefined => {
    if (category?.toLowerCase() !== 'embeddings' || !outputLengthStr) {
        return undefined;
    }
    // Try to find the first number, assuming it's the primary dimension
    const match = outputLengthStr.match(/\d+/);
    if (match) {
        const size = parseInt(match[0], 10);
        return isNaN(size) ? undefined : size;
    }
    return undefined;
};


// The data array conforming to the Models[] type
// Helper function to generate a URL-friendly slug from a name
const generateSlug = (name: string): string => {
  return name
      .toLowerCase() // Convert to lowercase
      .replace(/[:\/.]/g, '-') // Replace colons, slashes, periods with hyphens
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/[^\w-]+/g, '') // Remove all non-word chars except hyphens
      .replace(/--+/g, '-') // Replace multiple hyphens with a single hyphen
      .replace(/^-+/, '') // Trim hyphens from start of text
      .replace(/-+$/, ''); // Trim hyphens from end of text
};


// Define the updated interface
export interface Models {
  Name: string;
  InputModalities: string[];
  OutputModalities: string[];
  Category: string;
  description: string; // Markdown formatted description
  Creator: string;
  creatorUrl: string;
  blogUrl?: string; // Optional as some entries might not have it
  contextSize?: string; // Optional
  outputLength?: string; // Optional, used for token count or vector dimension string
  vectorSize?: number; // Optional, specifically for embedding vector dimensions
  slug: string; // Optional, slug for the model
  docs: string; // Markdown formatted documentation including explanation and sample request
}

// Generate docs for Embeddings models
const generateEmbeddingsDocs = (modelName: string): string => {
    const endpointRoute = "/api/v1/embeddings";
    // Extract relevant parts if needed, or just reference it.
    // For simplicity, we'll create a summary and provide a sample.
    return `
### Documentation for ${modelName}

Generates text embeddings using the \`${endpointRoute}\` endpoint. This model converts input text into numerical vectors suitable for tasks like semantic search, clustering, and classification.

Refer to the full documentation for the \`${endpointRoute}\` endpoint for details on headers, parameters (\`truncate\`, \`keep_alive\`, etc.), error handling, and response format.

#### Sample Request (cURL)

\`\`\`bash
# Replace <your-orchestrator-host> and <API_KEY> with your actual values
curl https://<your-orchestrator-host>/api/v1/embeddings \\
  -H "Authorization: Bearer <API_KEY>" \\
  -H "X-User-Id: your_user_id_123" \\
  -H "Content-Type: application/json" \\
  -d '{
        "model": "${modelName}",
        "input": ["Your text sentence here.", "Another sentence to embed."],
        "truncate": true,
        "keep_alive": "5m"
      }'
\`\`\`
`;
};

// Generate docs for Chat/Vision/Text/Math/Code models
const generateChatCompletionsDocs = (modelName: string, isVision: boolean = false): string => {
    const endpointRoute = "/api/v1/chat/completions";
    const visionNote = isVision ? "This model also supports image inputs alongside text." : "";
    return `
### Documentation for ${modelName}

Used for chat completions via the OpenAI-compatible \`${endpointRoute}\` endpoint. ${visionNote} It can be used for various tasks like text generation, question answering, summarization, coding, and mathematical reasoning, depending on the model's specialization.

This endpoint mirrors the OpenAI API structure, allowing you to use existing OpenAI SDKs by changing the \`baseURL\`. Refer to the full documentation for the \`${endpointRoute}\` endpoint for details on headers, parameters (\`stream\`, \`temperature\`, \`max_tokens\`, \`tools\`/\`functions\`, \`response_format\`, etc.), error handling, and response format (including streaming).

#### Sample Request (cURL - Non-streaming)

\`\`\`bash
# Replace <your-orchestrator-host> and <API_KEY> with your actual values
curl https://<your-orchestrator-host>/api/v1/chat/completions \\
  -H "Authorization: Bearer <API_KEY>" \\
  -H "X-User-Id: your_user_id_123" \\
  -H "Content-Type: application/json" \\
  -d '{
        "model": "${modelName}",
        "messages": [
          { "role": "system", "content": "You are a helpful assistant." },
          { "role": "user", "content": "Explain the concept of ${isVision ? 'multimodal AI' : 'transformer models'} in simple terms." }
        ],
        "temperature": 0.7,
        "max_tokens": 150
      }'
\`\`\`

#### Sample Request (Python SDK)

\`\`\`python
from openai import OpenAI

client = OpenAI(
    api_key="<API_KEY>", # Replace with your key
    base_url="https://<your-orchestrator-host>/api/v1", # Replace with your host
    default_headers={
        "X-User-Id": "your_user_id_123"
    }
)

try:
    response = client.chat.completions.create(
        model="${modelName}",
        messages=[
            {"role": "system", "content": "You are a helpful coding assistant."},
            {"role": "user", "content": "Write a python function to calculate factorial."}
            # For vision models, add image content if supported by your SDK/setup
            # {"role": "user", "content": [
            #     {"type": "text", "text": "Describe this image"},
            #     {"type": "image_url", "image_url": {"url": "data:image/jpeg;base64,..."}}
            # ]}
        ],
        temperature=0.5,
        stream=False # Set to True for streaming response
    )
    print(response.choices[0].message.content)
except Exception as e:
    print(f"An error occurred: {e}")

\`\`\`
`;
};

// Generate docs for Image models
const generateImageDocs = (modelName: string): string => {
    const endpointRoute = "/api/v1/image";
    // Note: The image endpoint docs don't show 'model' in the request body.
    // The selection might happen based on the endpoint/provisioning, not the request body.
    return `
### Documentation for ${modelName}

Generates images from text prompts using the \`${endpointRoute}\` endpoint. This specific model (${modelName}) is used internally by the service when this endpoint is called, based on system configuration.

The endpoint accepts a text prompt and various parameters to control the image generation process. Refer to the full documentation for the \`${endpointRoute}\` endpoint for details on headers, parameters (\`negativePrompt\`, \`numInferenceSteps\`, \`width\`, \`height\`, etc.), error handling, and the PNG image stream response format.

#### Sample Request (cURL)

\`\`\`bash
# Replace <your-orchestrator-host> and <API_KEY> with your actual values
# The specific model (${modelName}) is typically selected by the backend for this endpoint.
curl https://<your-orchestrator-host>/api/v1/image \\
  -H "Authorization: Bearer <API_KEY>" \\
  -H "X-User-Id: your_user_id_123" \\
  -H "Content-Type: application/json" \\
  --output generated_image.png \\
  -d '{
        "prompt": "A photo of an astronaut riding a horse on the moon",
        "negativePrompt": "cartoon, drawing, sketch, low quality, blurry",
        "numInferenceSteps": 30,
        "width": 768,
        "height": 768
      }'
\`\`\`
`;
};

// Generate docs for Audio (TTS) models
const generateTtsDocs = (modelName: string): string => {
    const endpointRoute = "/api/v1/tts";
    // Note: The TTS endpoint docs don't show 'model' in the request body.
    return `
### Documentation for ${modelName}

Performs Text-to-Speech (TTS) synthesis using the \`${endpointRoute}\` endpoint. This specific model (${modelName}) is used internally by the service when this endpoint is called, based on system configuration.

The endpoint accepts text and an optional voice ID to generate audio. Refer to the full documentation for the \`${endpointRoute}\` endpoint for details on headers, parameters (\`voice\`), error handling, and the WAV audio stream response format.

#### Sample Request (cURL)

\`\`\`bash
# Replace <your-orchestrator-host> and <API_KEY> with your actual values
# The specific model (${modelName}) is typically selected by the backend for this endpoint.
curl https://<your-orchestrator-host>/api/v1/tts \\
  -H "Authorization: Bearer <API_KEY>" \\
  -H "X-User-Id: your_user_id_123" \\
  -H "Content-Type: application/json" \\
  --output speech_output.wav \\
  -d '{
        "text": "Hello from the decentralized network! This audio was generated using Kokoro.",
        "voice": "af_nicole" # Optional: See endpoint docs for available voices
      }'
\`\`\`
`;
};

// Generate docs for Video models
const generateVideoDocs = (modelName: string): string => {
    const endpointRoute = "/api/v1/video";
     // Note: The video endpoint docs don't show 'model' in the request body.
    return `
### Documentation for ${modelName}

Generates video from text prompts using the \`${endpointRoute}\` endpoint. This specific model (${modelName}) is used internally by the service when this endpoint is called, based on system configuration.

The endpoint accepts a text prompt and parameters like resolution and generation settings. Refer to the full documentation for the \`${endpointRoute}\` endpoint for details on headers, parameters (\`size\`, \`sample_guide_scale\`, etc.), error handling, and the MP4 video stream response format.

#### Sample Request (cURL)

\`\`\`bash
# Replace <your-orchestrator-host> and <API_KEY> with your actual values
# The specific model (${modelName}) is typically selected by the backend for this endpoint.
curl https://<your-orchestrator-host>/api/v1/video \\
  -H "Authorization: Bearer <API_KEY>" \\
  -H "X-User-Id: your_user_id_123" \\
  -H "Content-Type: application/json" \\
  --output generated_video.mp4 \\
  -d '{
        "prompt": "A cinematic shot of a spaceship flying through a nebula",
        "size": "832*480",
        "sample_guide_scale": 7,
        "offload_model": true
      }'
\`\`\`
`;
};


// The data array conforming to the Models[] type with docs added
export const models: Models[] = [
{
  Name: "nomic-embed-text",
  Category: "embeddings",
  description: "`nomic-embed-text` is a large context length text encoder that surpasses OpenAI `text-embedding-ada-002` and `text-embedding-3-small` performance on short and long context tasks.",
  Creator: "Nomic AI",
  creatorUrl: "https://www.nomic.ai/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "8192",
  outputLength: "vector dimensions: 768, 512, 256, 128, 64",
  blogUrl: "https://www.nomic.ai/blog/posts/nomic-embed-text-v1",
  vectorSize: parseVectorSize("embeddings", "vector dimensions: 768, 512, 256, 128, 64"), // Parses 768
  slug: generateSlug("nomic-embed-text"), // "nomic-embed-text"
  docs: generateEmbeddingsDocs("nomic-embed-text")
},
{
  Name: "mxbai-embed-large",
  Category: "embeddings",
  description: "As of March 2024, this model archives SOTA performance for Bert-large sized models on the MTEB. It outperforms commercial models like OpenAIs `text-embedding-3-large` model and matches the performance of model 20x its size. `mxbai-embed-large` was trained with no overlap of the MTEB data, which indicates that the model generalizes well across several domains, tasks and text length.",
  Creator: "Mixedbread AI",
  creatorUrl: "https://www.mixedbread.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "512",
  outputLength: "up to 1024",
  blogUrl: "https://www.mixedbread.com/blog/mxbai-embed-large-v1",
  vectorSize: parseVectorSize("embeddings", "up to 1024"), // Parses 1024
  slug: generateSlug("mxbai-embed-large"), // "mxbai-embed-large"
  docs: generateEmbeddingsDocs("mxbai-embed-large")
},
{
  Name: "bge-m3",
  Category: "embeddings",
  description: `\`BGE-M3\` is based on the XLM-RoBERTa architecture and is distinguished for its versatility in Multi-Functionality, Multi-Linguality, and Multi-Granularity:

*   **Multi-Functionality**: It can simultaneously perform the three common retrieval functionalities of embedding model: dense retrieval, multi-vector retrieval, and sparse retrieval.
*   **Multi-Linguality**: It can support more than 100 working languages.
*   **Multi-Granularity**: It is able to process inputs of different granularities, spanning from short sentences to long documents of up to 8192 tokens.`,
  Creator: "BAAI",
  creatorUrl: "https://www.baai.ac.cn/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "8192",
  outputLength: "1024",
  blogUrl: "https://arxiv.org/pdf/2402.03216",
  vectorSize: parseVectorSize("embeddings", "1024"), // Parses 1024
  slug: generateSlug("bge-m3"), // "bge-m3"
  docs: generateEmbeddingsDocs("bge-m3")
},
{
  Name: "snowflake-arctic-embed:22m",
  Category: "embeddings",
  description: `\`snowflake-arctic-embed\` is a suite of text embedding models that focuses on creating high-quality retrieval models optimized for performance.

The models are trained by leveraging existing open-source text representation models, such as \`bert-base-uncased\`, and are trained in a multi-stage pipeline to optimize their retrieval performance.

This model is available in 5 parameter sizes:

*   \`snowflake-arctic-embed:335m\` (default)
*   \`snowflake-arctic-embed:137m\`
*   \`snowflake-arctic-embed:110m\`
*   \`snowflake-arctic-embed:33m\`
*   \`snowflake-arctic-embed:22m\``,
  Creator: "Snowflake",
  creatorUrl: "https://www.snowflake.com/en/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "512",
  outputLength: "384",
  blogUrl: "https://www.snowflake.com/en/blog/introducing-snowflake-arctic-embed-snowflakes-state-of-the-art-text-embedding-family-of-models/",
  vectorSize: parseVectorSize("embeddings", "384"), // Parses 384
  slug: generateSlug("snowflake-arctic-embed:22m"), // "snowflake-arctic-embed-22m"
  docs: generateEmbeddingsDocs("snowflake-arctic-embed:22m")
},
{
  Name: "snowflake-arctic-embed:33m",
  Category: "embeddings",
  description: `\`snowflake-arctic-embed\` is a suite of text embedding models that focuses on creating high-quality retrieval models optimized for performance.

The models are trained by leveraging existing open-source text representation models, such as \`bert-base-uncased\`, and are trained in a multi-stage pipeline to optimize their retrieval performance.

This model is available in 5 parameter sizes:

*   \`snowflake-arctic-embed:335m\` (default)
*   \`snowflake-arctic-embed:137m\`
*   \`snowflake-arctic-embed:110m\`
*   \`snowflake-arctic-embed:33m\`
*   \`snowflake-arctic-embed:22m\``,
  Creator: "Snowflake",
  creatorUrl: "https://www.snowflake.com/en/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "512",
  outputLength: "384",
  blogUrl: "https://www.snowflake.com/en/blog/introducing-snowflake-arctic-embed-snowflakes-state-of-the-art-text-embedding-family-of-models/",
  vectorSize: parseVectorSize("embeddings", "384"), // Parses 384
  slug: generateSlug("snowflake-arctic-embed:33m"), // "snowflake-arctic-embed-33m"
  docs: generateEmbeddingsDocs("snowflake-arctic-embed:33m")
},
{
  Name: "snowflake-arctic-embed:110m",
  Category: "embeddings",
  description: `\`snowflake-arctic-embed\` is a suite of text embedding models that focuses on creating high-quality retrieval models optimized for performance.

The models are trained by leveraging existing open-source text representation models, such as \`bert-base-uncased\`, and are trained in a multi-stage pipeline to optimize their retrieval performance.

This model is available in 5 parameter sizes:

*   \`snowflake-arctic-embed:335m\` (default)
*   \`snowflake-arctic-embed:137m\`
*   \`snowflake-arctic-embed:110m\`
*   \`snowflake-arctic-embed:33m\`
*   \`snowflake-arctic-embed:22m\``,
  Creator: "Snowflake",
  creatorUrl: "https://www.snowflake.com/en/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "512",
  outputLength: "768",
  blogUrl: "https://www.snowflake.com/en/blog/introducing-snowflake-arctic-embed-snowflakes-state-of-the-art-text-embedding-family-of-models/",
  vectorSize: parseVectorSize("embeddings", "768"), // Parses 768
  slug: generateSlug("snowflake-arctic-embed:110m"), // "snowflake-arctic-embed-110m"
  docs: generateEmbeddingsDocs("snowflake-arctic-embed:110m")
},
{
  Name: "snowflake-arctic-embed:137m",
  Category: "embeddings",
  description: `\`snowflake-arctic-embed\` is a suite of text embedding models that focuses on creating high-quality retrieval models optimized for performance.

The models are trained by leveraging existing open-source text representation models, such as \`bert-base-uncased\`, and are trained in a multi-stage pipeline to optimize their retrieval performance.

This model is available in 5 parameter sizes:

*   \`snowflake-arctic-embed:335m\` (default)
*   \`snowflake-arctic-embed:137m\`
*   \`snowflake-arctic-embed:110m\`
*   \`snowflake-arctic-embed:33m\`
*   \`snowflake-arctic-embed:22m\``,
  Creator: "Snowflake",
  creatorUrl: "https://www.snowflake.com/en/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "8192",
  outputLength: "768",
  blogUrl: "https://www.snowflake.com/en/blog/introducing-snowflake-arctic-embed-snowflakes-state-of-the-art-text-embedding-family-of-models/",
  vectorSize: parseVectorSize("embeddings", "768"), // Parses 768
  slug: generateSlug("snowflake-arctic-embed:137m"), // "snowflake-arctic-embed-137m"
  docs: generateEmbeddingsDocs("snowflake-arctic-embed:137m")
},
{
  Name: "snowflake-arctic-embed:335m",
  Category: "embeddings",
  description: `\`snowflake-arctic-embed\` is a suite of text embedding models that focuses on creating high-quality retrieval models optimized for performance.

The models are trained by leveraging existing open-source text representation models, such as \`bert-base-uncased\`, and are trained in a multi-stage pipeline to optimize their retrieval performance.

This model is available in 5 parameter sizes:

*   \`snowflake-arctic-embed:335m\` (default)
*   \`snowflake-arctic-embed:137m\`
*   \`snowflake-arctic-embed:110m\`
*   \`snowflake-arctic-embed:33m\`
*   \`snowflake-arctic-embed:22m\``,
  Creator: "Snowflake",
  creatorUrl: "https://www.snowflake.com/en/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "512",
  outputLength: "1024",
  blogUrl: "https://www.snowflake.com/en/blog/introducing-snowflake-arctic-embed-snowflakes-state-of-the-art-text-embedding-family-of-models/",
  vectorSize: parseVectorSize("embeddings", "1024"), // Parses 1024
  slug: generateSlug("snowflake-arctic-embed:335m"), // "snowflake-arctic-embed-335m"
  docs: generateEmbeddingsDocs("snowflake-arctic-embed:335m")
},
{
  Name: "all-minilm:33m",
  Category: "embeddings",
  description: "The model is intended to be used as a sentence and short paragraph encoder. Given an input text, it outputs a vector which captures the semantic information. The sentence vector may be used for information retrieval, clustering or sentence similarity tasks.",
  Creator: "Sentence Transformers",
  creatorUrl: "https://huggingface.co/sentence-transformers",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "256",
  outputLength: "384",
  blogUrl: undefined, // No blog post listed
  vectorSize: parseVectorSize("embeddings", "384"), // Parses 384
  slug: generateSlug("all-minilm:33m"), // "all-minilm-33m"
  docs: generateEmbeddingsDocs("all-minilm:33m")
},
{
  Name: "all-minilm:22m",
  Category: "embeddings",
  description: "The model is intended to be used as a sentence and short paragraph encoder. Given an input text, it outputs a vector which captures the semantic information. The sentence vector may be used for information retrieval, clustering or sentence similarity tasks.",
  Creator: "Sentence Transformers",
  creatorUrl: "https://huggingface.co/sentence-transformers",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "256",
  outputLength: "384",
  blogUrl: undefined, // No blog post listed
  vectorSize: parseVectorSize("embeddings", "384"), // Parses 384
  slug: generateSlug("all-minilm:22m"), // "all-minilm-22m"
  docs: generateEmbeddingsDocs("all-minilm:22m")
},
{
  Name: "snowflake-arctic-embed2",
  Category: "embeddings",
  description: "Snowflake's frontier embedding model. Arctic Embed 2.0 adds multilingual support without sacrificing English performance or scalability.",
  Creator: "Snowflake",
  creatorUrl: "https://www.snowflake.com/en/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("vector"),
  contextSize: "512",
  outputLength: "1024",
  blogUrl: "https://arxiv.org/pdf/2412.04506",
  vectorSize: parseVectorSize("embeddings", "1024"), // Parses 1024
  slug: generateSlug("snowflake-arctic-embed2"), // "snowflake-arctic-embed2"
  docs: generateEmbeddingsDocs("snowflake-arctic-embed2")
},
{
  Name: "gemma3:1b",
  Category: "vision",
  description: "Gemma is a lightweight, family of models from Google built on Gemini technology. The Gemma 3 models are multimodal—processing text and images—and feature a 128K context window with support for over 140 languages. Available in 1B, 4B, 12B, and 27B parameter sizes, they excel in tasks like question answering, summarization, and reasoning, while their compact design allows deployment on resource-limited devices.",
  Creator: "Google",
  creatorUrl: "https://huggingface.co/google",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "32k",
  outputLength: "8192",
  blogUrl: "https://blog.google/technology/developers/gemma-3/",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("gemma3:1b"), // "gemma3-1b"
  docs: generateChatCompletionsDocs("gemma3:1b", true)
},
{
  Name: "gemma3:4b",
  Category: "vision",
  description: "Gemma is a lightweight, family of models from Google built on Gemini technology. The Gemma 3 models are multimodal—processing text and images—and feature a 128K context window with support for over 140 languages. Available in 1B, 4B, 12B, and 27B parameter sizes, they excel in tasks like question answering, summarization, and reasoning, while their compact design allows deployment on resource-limited devices.",
  Creator: "Google",
  creatorUrl: "https://huggingface.co/google",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8192",
  blogUrl: "https://blog.google/technology/developers/gemma-3/",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("gemma3:4b"), // "gemma3-4b"
  docs: generateChatCompletionsDocs("gemma3:4b", true)
},
{
  Name: "gemma3:12b",
  Category: "vision",
  description: "Gemma is a lightweight, family of models from Google built on Gemini technology. The Gemma 3 models are multimodal—processing text and images—and feature a 128K context window with support for over 140 languages. Available in 1B, 4B, 12B, and 27B parameter sizes, they excel in tasks like question answering, summarization, and reasoning, while their compact design allows deployment on resource-limited devices.",
  Creator: "Google",
  creatorUrl: "https://huggingface.co/google",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8192",
  blogUrl: "https://blog.google/technology/developers/gemma-3/",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("gemma3:12b"), // "gemma3-12b"
  docs: generateChatCompletionsDocs("gemma3:12b", true)
},
{
  Name: "gemma3:24b",
  Category: "vision",
  description: "Gemma is a lightweight, family of models from Google built on Gemini technology. The Gemma 3 models are multimodal—processing text and images—and feature a 128K context window with support for over 140 languages. Available in 1B, 4B, 12B, and 27B parameter sizes, they excel in tasks like question answering, summarization, and reasoning, while their compact design allows deployment on resource-limited devices.",
  Creator: "Google",
  creatorUrl: "https://huggingface.co/google",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8192",
  blogUrl: "https://blog.google/technology/developers/gemma-3/",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("gemma3:24b"), // "gemma3-24b"
  docs: generateChatCompletionsDocs("gemma3:24b", true)
},
{
  Name: "llama3.2-vision:11b",
  Category: "vision",
  description: `The Llama 3.2-Vision collection of multimodal large language models (LLMs) is a collection of instruction-tuned image reasoning generative models in 11B and 90B sizes (text + images in / text out). The Llama 3.2-Vision instruction-tuned models are optimized for visual recognition, image reasoning, captioning, and answering general questions about an image. The models outperform many of the available open source and closed multimodal models on common industry benchmarks.

**Supported Languages**: For text only tasks, English, German, French, Italian, Portuguese, Hindi, Spanish, and Thai are officially supported. Llama 3.2 has been trained on a broader collection of languages than these 8 supported languages. Note for image+text applications, English is the only language supported.`,
  Creator: "Meta",
  creatorUrl: "https://huggingface.co/meta-llama",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "4096",
  blogUrl: "https://ai.meta.com/blog/llama-3-2-connect-2024-vision-edge-mobile-devices/",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("llama3.2-vision:11b"), // "llama3-2-vision-11b"
  docs: generateChatCompletionsDocs("llama3.2-vision:11b", true)
},
{
  Name: "minicpm-v",
  Category: "vision",
  description: `\`MiniCPM-V 2.6\` is the latest and most capable model in the MiniCPM-V series. The model is built on SigLip-400M and Qwen2-7B with a total of 8B parameters. It exhibits a significant performance improvement over MiniCPM-Llama3-V 2.5, and introduces new features for multi-image and video understanding. Notable features of MiniCPM-V 2.6 include:

*   **🔥 Leading Performance**: MiniCPM-V 2.6 achieves an average score of 65.2 on the latest version of OpenCompass, a comprehensive evaluation over 8 popular benchmarks. With only 8B parameters, it surpasses widely used proprietary models like GPT-4o mini, GPT-4V, Gemini 1.5 Pro, and Claude 3.5 Sonnet for single image understanding.
*   **🖼️ Multi Image Understanding and In-context Learning**: MiniCPM-V 2.6 can also perform conversation and reasoning over multiple images. It achieves state-of-the-art performance on popular multi-image benchmarks such as Mantis-Eval, BLINK, Mathverse mv and Sciverse mv, and also shows promising in-context learning capability.
*   **💪 Strong OCR Capability**: MiniCPM-V 2.6 can process images with any aspect ratio and up to 1.8 million pixels (e.g., 1344x1344). It achieves state-of-the-art performance on OCRBench, surpassing proprietary models such as GPT-4o, GPT-4V, and Gemini 1.5 Pro. Based on the the latest RLAIF-V and VisCPM techniques, it features trustworthy behaviors, with significantly lower hallucination rates than GPT-4o and GPT-4V on Object HalBench, and supports multilingual capabilities on English, Chinese, German, French, Italian, Korean, etc.
*   **🚀 Superior Efficiency**: In addition to its friendly size, MiniCPM-V 2.6 also shows state-of-the-art token density (i.e., number of pixels encoded into each visual token). It produces only 640 tokens when processing a 1.8M pixel image, which is 75% fewer than most models. This directly improves the inference speed, first-token latency, memory usage, and power consumption.`,
  Creator: "openBMB",
  creatorUrl: "https://huggingface.co/openbmb",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "8192",
  blogUrl: "https://github.com/OpenBMB/MiniCPM-o",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("minicpm-v"), // "minicpm-v"
  docs: generateChatCompletionsDocs("minicpm-v", true)
},
{
  Name: "llava-llama3",
  Category: "vision",
  description: "`llava-llama-3-8b-v1_1` is a LLaVA model fine-tuned from `meta-llama/Meta-Llama-3-8B-Instruct` and `CLIP-ViT-Large-patch14-336` with ShareGPT4V-PT and InternVL-SFT by XTuner.",
  Creator: "xtuner",
  creatorUrl: "https://huggingface.co/xtuner",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k", // Assuming this is the same as minicpm-v based on structure, might need clarification
  outputLength: "4096",
  blogUrl: undefined, // No specific blog post listed, only HF link
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("llava-llama3"), // "llava-llama3"
  docs: generateChatCompletionsDocs("llava-llama3", true)
},
{
  Name: "moondream",
  Category: "vision",
  description: `\`Moondream\` is an open-source visual language model that understands images using simple text prompts. It's fast, wildly capable — and just 1GB in size.

*   **Vision AI at Warp Speed**: Forget everything you thought you needed to know about computer vision. With Moondream, there's no training, no ground truth data, and no heavy infrastructure. Just a model, a prompt, and a whole world of visual understanding.
*   **Ridiculously lightweight**: Under 2B parameters. Quantized to 4-bit. Just 1GB. Moondream runs anywhere — from edge devices to your laptop.
*   **Actually affordable**: Run it locally for free. Or use our cloud API to process a high volume of images quickly and cheaply. Free tier included.
*   **Simple by design**: Choose a capability. Write a prompt. Get results. That's it. Moondream is designed for developers who don't want to babysit models.
*   **Versatile as hell**: Go beyond basic visual Q&A. Moondream can caption, detect objects, locate things, read documents, follow gaze, and more.
*   **Tried, tested, trusted**: 6M+ downloads. 8K+ GitHub stars. Used across industries — from healthcare to robotics to mobile apps.`,
  Creator: "moondream",
  creatorUrl: "https://moondream.ai/",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: undefined, // Not specified in data
  outputLength: undefined, // Not specified in data
  blogUrl: "https://moondream.ai/blog/introducing-a-new-moondream-1-9b-and-gpu-support",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("moondream"), // "moondream"
  docs: generateChatCompletionsDocs("moondream", true) // Also potentially uses /m endpoints, but chat is primary interface
},
{
  Name: "granite3.2-vision",
  Category: "vision",
  description: "Model Summary: `granite-vision-3.2-2b` is a compact and efficient vision-language model, specifically designed for visual document understanding, enabling automated content extraction from tables, charts, infographics, plots, diagrams, and more. The model was trained on a meticulously curated instruction-following dataset, comprising diverse public datasets and synthetic datasets tailored to support a wide range of document understanding and general image tasks. It was trained by fine-tuning a Granite large language model with both image and text modalities.",
  Creator: "IBM",
  creatorUrl: "https://huggingface.co/ibm-granite",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: undefined, // Not specified in data
  outputLength: undefined, // Not specified in data
  blogUrl: "https://arxiv.org/abs/2502.09927",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("granite3.2-vision"), // "granite3-2-vision"
  docs: generateChatCompletionsDocs("granite3.2-vision", true)
},
 {
  Name: "mistral-small3.1",
  Category: "vision",
  description: `Model Card for Mistral-Small-3.1-24B-Instruct-2503 Building upon Mistral Small 3 (2501), Mistral Small 3.1 (2503) adds state-of-the-art vision understanding and enhances long context capabilities up to 128k tokens without compromising text performance. With 24 billion parameters, this model achieves top-tier capabilities in both text and vision tasks. This model is an instruction-finetuned version of: \`Mistral-Small-3.1-24B-Base-2503\`.

Mistral Small 3.1 can be deployed locally and is exceptionally "knowledge-dense," fitting within a single RTX 4090 or a 32GB RAM MacBook once quantized.

It is ideal for:

*   Fast-response conversational agents.
*   Low-latency function calling.
*   Subject matter experts via fine-tuning.
*   Local inference for hobbyists and organizations handling sensitive data.
*   Programming and math reasoning.
*   Long document understanding.
*   Visual understanding.

For enterprises requiring specialized capabilities (increased context, specific modalities, domain-specific knowledge, etc.), we will release commercial models beyond what Mistral AI contributes to the community.

Learn more about Mistral Small 3.1 in our [blog post](https://mistral.ai/news/mistral-small-3-1).

**Key Features**
*   **Vision**: Vision capabilities enable the model to analyze images and provide insights based on visual content in addition to text.
*   **Multilingual**: Supports dozens of languages, including English, French, German, Greek, Hindi, Indonesian, Italian, Japanese, Korean, Malay, Nepali, Polish, Portuguese, Romanian, Russian, Serbian, Spanish, Swedish, Turkish, Ukrainian, Vietnamese, Arabic, Bengali, Chinese, Farsi.
*   **Agent-Centric**: Offers best-in-class agentic capabilities with native function calling and JSON outputting.
*   **Advanced Reasoning**: State-of-the-art conversational and reasoning capabilities.
*   **Apache 2.0 License**: Open license allowing usage and modification for both commercial and non-commercial purposes.
*   **Context Window**: A 128k context window.
*   **System Prompt**: Maintains strong adherence and support for system prompts.
*   **Tokenizer**: Utilizes a Tekken tokenizer with a 131k vocabulary size.`,
  Creator: "Mistral",
  creatorUrl: "https://mistral.ai/",
  InputModalities: parseModalities("text, image"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "128k",
  blogUrl: "https://mistral.ai/news/mistral-small-3-1",
  vectorSize: undefined, // Not an embedding model
  slug: generateSlug("mistral-small3.1"), // "mistral-small3-1"
  docs: generateChatCompletionsDocs("mistral-small3.1", true)
},
{
  Name: "cogito:14b",
  Category: "text",
  description: `The Cogito v1 Preview LLMs are instruction tuned generative models (text in/text out). All models are released under an open license for commercial use.

*   Cogito models are hybrid reasoning models. Each model can answer directly (standard LLM), or self-reflect before answering (like reasoning models).
*   The LLMs are trained using Iterated Distillation and Amplification (IDA) - an scalable and efficient alignment strategy for superintelligence using iterative self-improvement.
*   The models have been optimized for coding, STEM, instruction following and general helpfulness, and have significantly higher multilingual, coding and tool calling capabilities than size equivalent counterparts.
*   In both standard and reasoning modes, Cogito v1-preview models outperform their size equivalent counterparts on common industry benchmarks.
*   Each model is trained in over 30 languages and supports a context length of 128k.`,
  Creator: "Cogito",
  creatorUrl: "https://www.deepcogito.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "128k",
  blogUrl: "https://www.deepcogito.com/research/cogito-v1-preview",
  vectorSize: undefined,
  slug: generateSlug("cogito:14b"), // "cogito-14b"
  docs: generateChatCompletionsDocs("cogito:14b")
},
{
  Name: "cogito:32b",
  Category: "text",
  description: `The Cogito v1 Preview LLMs are instruction tuned generative models (text in/text out). All models are released under an open license for commercial use.

*   Cogito models are hybrid reasoning models. Each model can answer directly (standard LLM), or self-reflect before answering (like reasoning models).
*   The LLMs are trained using Iterated Distillation and Amplification (IDA) - an scalable and efficient alignment strategy for superintelligence using iterative self-improvement.
*   The models have been optimized for coding, STEM, instruction following and general helpfulness, and have significantly higher multilingual, coding and tool calling capabilities than size equivalent counterparts.
*   In both standard and reasoning modes, Cogito v1-preview models outperform their size equivalent counterparts on common industry benchmarks.
*   Each model is trained in over 30 languages and supports a context length of 128k.`,
  Creator: "Cogito",
  creatorUrl: "https://www.deepcogito.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "128k",
  blogUrl: "https://www.deepcogito.com/research/cogito-v1-preview",
  vectorSize: undefined,
  slug: generateSlug("cogito:32b"), // "cogito-32b"
  docs: generateChatCompletionsDocs("cogito:32b")
},
{
  Name: "cogito:3b",
  Category: "text",
  description: `The Cogito v1 Preview LLMs are instruction tuned generative models (text in/text out). All models are released under an open license for commercial use.

*   Cogito models are hybrid reasoning models. Each model can answer directly (standard LLM), or self-reflect before answering (like reasoning models).
*   The LLMs are trained using Iterated Distillation and Amplification (IDA) - an scalable and efficient alignment strategy for superintelligence using iterative self-improvement.
*   The models have been optimized for coding, STEM, instruction following and general helpfulness, and have significantly higher multilingual, coding and tool calling capabilities than size equivalent counterparts.
*   In both standard and reasoning modes, Cogito v1-preview models outperform their size equivalent counterparts on common industry benchmarks.
*   Each model is trained in over 30 languages and supports a context length of 128k.`,
  Creator: "Cogito",
  creatorUrl: "https://www.deepcogito.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "128k",
  blogUrl: "https://www.deepcogito.com/research/cogito-v1-preview",
  vectorSize: undefined,
  slug: generateSlug("cogito:3b"), // "cogito-3b"
  docs: generateChatCompletionsDocs("cogito:3b")
},
{
  Name: "cogito:70b",
  Category: "text",
  description: `The Cogito v1 Preview LLMs are instruction tuned generative models (text in/text out). All models are released under an open license for commercial use.

*   Cogito models are hybrid reasoning models. Each model can answer directly (standard LLM), or self-reflect before answering (like reasoning models).
*   The LLMs are trained using Iterated Distillation and Amplification (IDA) - an scalable and efficient alignment strategy for superintelligence using iterative self-improvement.
*   The models have been optimized for coding, STEM, instruction following and general helpfulness, and have significantly higher multilingual, coding and tool calling capabilities than size equivalent counterparts.
*   In both standard and reasoning modes, Cogito v1-preview models outperform their size equivalent counterparts on common industry benchmarks.
*   Each model is trained in over 30 languages and supports a context length of 128k.`,
  Creator: "Cogito",
  creatorUrl: "https://www.deepcogito.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "128k",
  blogUrl: "https://www.deepcogito.com/research/cogito-v1-preview",
  vectorSize: undefined,
  slug: generateSlug("cogito:70b"), // "cogito-70b"
  docs: generateChatCompletionsDocs("cogito:70b")
},
{
  Name: "cogito:8b",
  Category: "text",
  description: `The Cogito v1 Preview LLMs are instruction tuned generative models (text in/text out). All models are released under an open license for commercial use.

*   Cogito models are hybrid reasoning models. Each model can answer directly (standard LLM), or self-reflect before answering (like reasoning models).
*   The LLMs are trained using Iterated Distillation and Amplification (IDA) - an scalable and efficient alignment strategy for superintelligence using iterative self-improvement.
*   The models have been optimized for coding, STEM, instruction following and general helpfulness, and have significantly higher multilingual, coding and tool calling capabilities than size equivalent counterparts.
*   In both standard and reasoning modes, Cogito v1-preview models outperform their size equivalent counterparts on common industry benchmarks.
*   Each model is trained in over 30 languages and supports a context length of 128k.`,
  Creator: "Cogito",
  creatorUrl: "https://www.deepcogito.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "128k",
  blogUrl: "https://www.deepcogito.com/research/cogito-v1-preview",
  vectorSize: undefined,
  slug: generateSlug("cogito:8b"), // "cogito-8b"
  docs: generateChatCompletionsDocs("cogito:8b")
},
{
  Name: "deepseek-r1:1.5b",
  Category: "text",
  description: `\`DeepSeek R1 Distill Qwen 1.5B\` is a distilled large language model based on \`Qwen 2.5 Math 1.5B\`, using outputs from DeepSeek R1. It's a very small and efficient model which outperforms GPT 4o 0513 on Math Benchmarks.

Other benchmark results include:

*   AIME 2024 pass@1: 28.9
*   AIME 2024 cons@64: 52.7
*   MATH-500 pass@1: 83.9

The model leverages fine-tuning from DeepSeek R1's outputs, enabling competitive performance comparable to larger frontier models.`,
  Creator: "Deepseek",
  creatorUrl: "https://www.deepseek.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "33k",
  blogUrl: "https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf",
  vectorSize: undefined,
  slug: generateSlug("deepseek-r1:1.5b"), // "deepseek-r1-1-5b"
  docs: generateChatCompletionsDocs("deepseek-r1:1.5b")
},
{
  Name: "deepseek-r1:14b",
  Category: "text",
  description: `\`DeepSeek R1 Distill Qwen 14B\` is a distilled large language model based on Qwen 2.5 14B, using outputs from DeepSeek R1. It outperforms OpenAI's o1-mini across various benchmarks, achieving new state-of-the-art results for dense models.

Other benchmark results include:

*   AIME 2024 pass@1: 69.7
*   MATH-500 pass@1: 93.9
*   CodeForces Rating: 1481

The model leverages fine-tuning from DeepSeek R1's outputs, enabling competitive performance comparable to larger frontier models.`,
  Creator: "Deepseek",
  creatorUrl: "https://www.deepseek.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "33k",
  blogUrl: "https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf",
  vectorSize: undefined,
  slug: generateSlug("deepseek-r1:14b"), // "deepseek-r1-14b"
  docs: generateChatCompletionsDocs("deepseek-r1:14b")
},
{
  Name: "deepseek-r1:32b",
  Category: "text",
  description: `\`DeepSeek R1 Distill Qwen 32B\` is a distilled large language model based on Qwen 2.5 32B, using outputs from DeepSeek R1. It outperforms OpenAI's o1-mini across various benchmarks, achieving new state-of-the-art results for dense models.

Other benchmark results include:

*   AIME 2024 pass@1: 72.6
*   MATH-500 pass@1: 94.3
*   CodeForces Rating: 1691

The model leverages fine-tuning from DeepSeek R1's outputs, enabling competitive performance comparable to larger frontier models.`,
  Creator: "Deepseek",
  creatorUrl: "https://www.deepseek.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "64k",
  blogUrl: "https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf",
  vectorSize: undefined,
  slug: generateSlug("deepseek-r1:32b"), // "deepseek-r1-32b"
  docs: generateChatCompletionsDocs("deepseek-r1:32b")
},
{
  Name: "deepseek-r1:70b",
  Category: "text",
  description: `\`DeepSeek R1 Distill Llama 70B\` is a distilled large language model based on \`Llama-3.3-70B-Instruct\`, using outputs from DeepSeek R1. The model combines advanced distillation techniques to achieve high performance across multiple benchmarks, including:

*   AIME 2024 pass@1: 70.0
*   MATH-500 pass@1: 94.5
*   CodeForces Rating: 1633

The model leverages fine-tuning from DeepSeek R1's outputs, enabling competitive performance comparable to larger frontier models.`,
  Creator: "Deepseek",
  creatorUrl: "https://www.deepseek.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "64k",
  blogUrl: "https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf",
  vectorSize: undefined,
  slug: generateSlug("deepseek-r1:70b"), // "deepseek-r1-70b"
  docs: generateChatCompletionsDocs("deepseek-r1:70b")
},
{
  Name: "deepseek-r1:7b",
  Category: "text",
  description: "DeepSeek's first-generation of reasoning models with comparable performance to OpenAI-o1, including six dense models distilled from DeepSeek-R1 based on Llama and Qwen.", // Used short description as main one was empty
  Creator: "Deepseek",
  creatorUrl: "https://www.deepseek.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "33k",
  blogUrl: "https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf",
  vectorSize: undefined,
  slug: generateSlug("deepseek-r1:7b"), // "deepseek-r1-7b"
  docs: generateChatCompletionsDocs("deepseek-r1:7b")
},
{
  Name: "deepseek-r1:8b",
  Category: "text",
  description: `\`DeepSeek R1 Distill Llama 8B\` is a distilled large language model based on \`Llama-3.1-8B-Instruct\`, using outputs from DeepSeek R1. The model combines advanced distillation techniques to achieve high performance across multiple benchmarks, including:

*   AIME 2024 pass@1: 50.4
*   MATH-500 pass@1: 89.1
*   CodeForces Rating: 1205

The model leverages fine-tuning from DeepSeek R1's outputs, enabling competitive performance comparable to larger frontier models.`,
  Creator: "Deepseek",
  creatorUrl: "https://www.deepseek.com/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "33k",
  blogUrl: "https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf",
  vectorSize: undefined,
  slug: generateSlug("deepseek-r1:8b"), // "deepseek-r1-8b"
  docs: generateChatCompletionsDocs("deepseek-r1:8b")
},
 {
  Name: "llama3.1:8b",
  Category: "text",
  description: "The Meta Llama 3.1 collection of multilingual large language models (LLMs) is a collection of pretrained and instruction tuned generative models in 8B, 70B and 405B sizes (text in/text out). The Llama 3.1 instruction tuned text only models (8B, 70B, 405B) are optimized for multilingual dialogue use cases and outperform many of the available open source and closed chat models on common industry benchmarks.",
  Creator: "Meta",
  creatorUrl: "https://huggingface.co/meta-llama",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "16k",
  blogUrl: "https://ai.meta.com/blog/meta-llama-3-1/",
  vectorSize: undefined,
  slug: generateSlug("llama3.1:8b"), // "llama3-1-8b"
  docs: generateChatCompletionsDocs("llama3.1:8b")
},
{
  Name: "llama3.2:1b",
  Category: "text",
  description: "The Meta Llama 3.2 collection of multilingual large language models (LLMs) is a collection of pretrained and instruction-tuned generative models in 1B and 3B sizes (text in/text out). The Llama 3.2 instruction-tuned text only models are optimized for multilingual dialogue use cases, including agentic retrieval and summarization tasks. They outperform many of the available open source and closed chat models on common industry benchmarks.",
  Creator: "Meta",
  creatorUrl: "https://huggingface.co/meta-llama",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "8k",
  blogUrl: "https://ai.meta.com/blog/llama-3-2-connect-2024-vision-edge-mobile-devices/",
  vectorSize: undefined,
  slug: generateSlug("llama3.2:1b"), // "llama3-2-1b"
  docs: generateChatCompletionsDocs("llama3.2:1b")
},
{
  Name: "llama3.2:3b",
  Category: "text",
  description: "The Meta Llama 3.2 collection of multilingual large language models (LLMs) is a collection of pretrained and instruction-tuned generative models in 1B and 3B sizes (text in/text out). The Llama 3.2 instruction-tuned text only models are optimized for multilingual dialogue use cases, including agentic retrieval and summarization tasks. They outperform many of the available open source and closed chat models on common industry benchmarks.",
  Creator: "Meta",
  creatorUrl: "https://huggingface.co/meta-llama",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "8k",
  blogUrl: "https://ai.meta.com/blog/llama-3-2-connect-2024-vision-edge-mobile-devices/",
  vectorSize: undefined,
  slug: generateSlug("llama3.2:3b"), // "llama3-2-3b"
  docs: generateChatCompletionsDocs("llama3.2:3b")
},
{
  Name: "llama3.3",
  Category: "text",
  description: `The Meta Llama 3.3 multilingual large language model (LLM) is a pretrained and instruction tuned generative model in 70B (text in/text out). The Llama 3.3 instruction tuned text only model is optimized for multilingual dialogue use cases and outperforms many of the available open source and closed chat models on common industry benchmarks.

**Supported languages**: English, German, French, Italian, Portuguese, Hindi, Spanish, and Thai.`,
  Creator: "Meta",
  creatorUrl: "https://huggingface.co/meta-llama",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "16k",
  blogUrl: "https://ai.meta.com/blog/future-of-ai-built-with-llama/",
  vectorSize: undefined,
  slug: generateSlug("llama3.3"), // "llama3-3"
  docs: generateChatCompletionsDocs("llama3.3")
},
{
  Name: "mistral",
  Category: "text",
  description: `Mistral is a 7B parameter model, distributed with the Apache license. It is available in both instruct (instruction following) and text completion.

The Mistral AI team has noted that Mistral 7B:

*   Outperforms Llama 2 13B on all benchmarks
*   Outperforms Llama 1 34B on many benchmarks
*   Approaches CodeLlama 7B performance on code, while remaining good at English tasks`,
  Creator: "Mistral",
  creatorUrl: "https://huggingface.co/mistralai",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "33k", // Updated based on newer Mistral info, spreadsheet had 32k
  outputLength: "8k",
  blogUrl: "https://mistral.ai/news/announcing-mistral-7b",
  vectorSize: undefined,
  slug: generateSlug("mistral"), // "mistral"
  docs: generateChatCompletionsDocs("mistral")
},
{
  Name: "mistral-nemo",
  Category: "text",
  description: "Mistral NeMo is a 12B model built in collaboration with NVIDIA. Mistral NeMo offers a large context window of up to 128k tokens. Its reasoning, world knowledge, and coding accuracy are state-of-the-art in its size category. As it relies on standard architecture, Mistral NeMo is easy to use and a drop-in replacement in any system using Mistral 7B.",
  Creator: "Mistral",
  creatorUrl: "https://mistral.ai/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "16k",
  blogUrl: "https://mistral.ai/news/mistral-nemo",
  vectorSize: undefined,
  slug: generateSlug("mistral-nemo"), // "mistral-nemo"
  docs: generateChatCompletionsDocs("mistral-nemo")
},
{
  Name: "phi4",
  Category: "text",
  description: `\`phi-4\` is a state-of-the-art open model built upon a blend of synthetic datasets, data from filtered public domain websites, and acquired academic books and Q&A datasets. The goal of this approach was to ensure that small capable models were trained with data focused on high quality and advanced reasoning.

\`phi-4\` underwent a rigorous enhancement and alignment process, incorporating both supervised fine-tuning and direct preference optimization to ensure precise instruction adherence and robust safety measures.`,
  Creator: "Microsoft",
  creatorUrl: "https://huggingface.co/microsoft",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "16k", // Data seems inconsistent, using the lower value mentioned
  outputLength: "8k",
  blogUrl: "https://arxiv.org/pdf/2412.08905",
  vectorSize: undefined,
  slug: generateSlug("phi4"), // "phi4"
  docs: generateChatCompletionsDocs("phi4")
},
{
  Name: "phi4-mini",
  Category: "text",
  description: "`Phi-4-mini-instruct` is a lightweight open model built upon synthetic data and filtered publicly available websites - with a focus on high-quality, reasoning dense data. The model belongs to the Phi-4 model family and supports 128K token context length. The model underwent an enhancement process, incorporating both supervised fine-tuning and direct preference optimization to support precise instruction adherence and robust safety measures",
  Creator: "Microsoft",
  creatorUrl: "https://huggingface.co/microsoft",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "128k",
  blogUrl: "http://techcommunity.microsoft.com/blog/educatordeveloperblog/welcome-to-the-new-phi-4-models---microsoft-phi-4-mini--phi-4-multimodal/4386037",
  vectorSize: undefined,
  slug: generateSlug("phi4-mini"), // "phi4-mini"
  docs: generateChatCompletionsDocs("phi4-mini")
},
{
  Name: "qwen2.5:14b",
  Category: "text",
  description: `\`Qwen2.5\` is the latest series of Qwen large language models. For Qwen2.5, a range of base language models and instruction-tuned models are released, with sizes ranging from 0.5 to 72 billion parameters. Qwen2.5 introduces the following improvements over Qwen2:

*   It possesses significantly more knowledge and has greatly enhanced capabilities in coding and mathematics, due to specialized expert models in these domains.
*   It demonstrates significant advancements in instruction following, long-text generation (over 8K tokens), understanding structured data (e.g., tables), and generating structured outputs, especially in JSON format. It is also more resilient to diverse system prompts, improving role-play and condition-setting for chatbots.
*   It supports long contexts of up to 128K tokens and can generate up to 8K tokens.
*   It offers multilingual support for over 29 languages, including Chinese, English, French, Spanish, Portuguese, German, Italian, Russian, Japanese, Korean, Vietnamese, Thai, Arabic, and more.`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5:14b"), // "qwen2-5-14b"
  docs: generateChatCompletionsDocs("qwen2.5:14b")
},
{
  Name: "qwen2.5:32b",
  Category: "text",
  description: `\`Qwen2.5\` is the latest series of Qwen large language models. For Qwen2.5, a range of base language models and instruction-tuned models are released, with sizes ranging from 0.5 to 72 billion parameters. Qwen2.5 introduces the following improvements over Qwen2:

*   It possesses significantly more knowledge and has greatly enhanced capabilities in coding and mathematics, due to specialized expert models in these domains.
*   It demonstrates significant advancements in instruction following, long-text generation (over 8K tokens), understanding structured data (e.g., tables), and generating structured outputs, especially in JSON format. It is also more resilient to diverse system prompts, improving role-play and condition-setting for chatbots.
*   It supports long contexts of up to 128K tokens and can generate up to 8K tokens.
*   It offers multilingual support for over 29 languages, including Chinese, English, French, Spanish, Portuguese, German, Italian, Russian, Japanese, Korean, Vietnamese, Thai, Arabic, and more.`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5:32b"), // "qwen2-5-32b"
  docs: generateChatCompletionsDocs("qwen2.5:32b")
},
{
  Name: "qwen2.5:72b",
  Category: "text",
  description: `\`Qwen2.5\` is the latest series of Qwen large language models. For Qwen2.5, a range of base language models and instruction-tuned models are released, with sizes ranging from 0.5 to 72 billion parameters. Qwen2.5 introduces the following improvements over Qwen2:

*   It possesses significantly more knowledge and has greatly enhanced capabilities in coding and mathematics, due to specialized expert models in these domains.
*   It demonstrates significant advancements in instruction following, long-text generation (over 8K tokens), understanding structured data (e.g., tables), and generating structured outputs, especially in JSON format. It is also more resilient to diverse system prompts, improving role-play and condition-setting for chatbots.
*   It supports long contexts of up to 128K tokens and can generate up to 8K tokens.
*   It offers multilingual support for over 29 languages, including Chinese, English, French, Spanish, Portuguese, German, Italian, Russian, Japanese, Korean, Vietnamese, Thai, Arabic, and more.`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5:72b"), // "qwen2-5-72b"
  docs: generateChatCompletionsDocs("qwen2.5:72b")
},
{
  Name: "qwen2.5:7b",
  Category: "text",
  description: `\`Qwen2.5\` is the latest series of Qwen large language models. For Qwen2.5, a range of base language models and instruction-tuned models are released, with sizes ranging from 0.5 to 72 billion parameters. Qwen2.5 introduces the following improvements over Qwen2:

*   It possesses significantly more knowledge and has greatly enhanced capabilities in coding and mathematics, due to specialized expert models in these domains.
*   It demonstrates significant advancements in instruction following, long-text generation (over 8K tokens), understanding structured data (e.g., tables), and generating structured outputs, especially in JSON format. It is also more resilient to diverse system prompts, improving role-play and condition-setting for chatbots.
*   It supports long contexts of up to 128K tokens and can generate up to 8K tokens.
*   It offers multilingual support for over 29 languages, including Chinese, English, French, Spanish, Portuguese, German, Italian, Russian, Japanese, Korean, Vietnamese, Thai, Arabic, and more.`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5:7b"), // "qwen2-5-7b"
  docs: generateChatCompletionsDocs("qwen2.5:7b")
},
{
  Name: "qwq",
  Category: "text",
  description: "`QwQ` is the reasoning model of the Qwen series. Compared with conventional instruction-tuned models, QwQ, which is capable of thinking and reasoning, can achieve significantly enhanced performance in downstream tasks, especially hard problems. `QwQ-32B` is the medium-sized reasoning model, which is capable of achieving competitive performance against state-of-the-art reasoning models, e.g., DeepSeek-R1, o1-mini.",
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "131k",
  blogUrl: "https://qwenlm.github.io/blog/qwq-32b/",
  vectorSize: undefined,
  slug: generateSlug("qwq"), // "qwq"
  docs: generateChatCompletionsDocs("qwq")
},
{
  Name: "mathstral",
  Category: "math",
  description: `Mistral AI is contributing Mathstral to the science community to bolster efforts in advanced mathematical problems requiring complex, multi-step logical reasoning. The Mathstral release is part of their broader effort to support academic projects—it was produced in the context of Mistral AI’s collaboration with Project Numina.

Akin to Isaac Newton in his time, Mathstral stands on the shoulders of Mistral 7B and specializes in STEM subjects. It achieves state-of-the-art reasoning capacities in its size category across various industry-standard benchmarks.`,
  Creator: "Mistral",
  creatorUrl: "https://mistral.ai/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "32k",
  outputLength: undefined, // Not specified in data
  blogUrl: "https://mistral.ai/news/mathstral",
  vectorSize: undefined,
  slug: generateSlug("mathstral"), // "mathstral"
  docs: generateChatCompletionsDocs("mathstral")
},
{
  Name: "qwen2-math:7b",
  Category: "math",
  description: "Over the past year, we have dedicated significant effort to researching and enhancing the reasoning capabilities of large language models, with a particular focus on their ability to solve arithmetic and mathematical problems. Today, we are delighted to introduce a series of math-specific large language models of our Qwen2 series, `Qwen2-Math` and `Qwen2-Math-Instruct-1.5B/7B/72B`. Qwen2-Math is a series of specialized math language models built upon the Qwen2 LLMs, which significantly outperforms the mathematical capabilities of open-source models and even closed-source models (e.g., GPT-4o). We hope that Qwen2-Math can contribute to the community for solving complex mathematical problems.",
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "4k",
  outputLength: "2k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2-math/",
  vectorSize: undefined,
  slug: generateSlug("qwen2-math:7b"), // "qwen2-math-7b"
  docs: generateChatCompletionsDocs("qwen2-math:7b")
},
{
  Name: "qwen2-math:72b",
  Category: "math",
  description: "Over the past year, we have dedicated significant effort to researching and enhancing the reasoning capabilities of large language models, with a particular focus on their ability to solve arithmetic and mathematical problems. Today, we are delighted to introduce a series of math-specific large language models of our Qwen2 series, `Qwen2-Math` and `Qwen2-Math-Instruct-1.5B/7B/72B`. Qwen2-Math is a series of specialized math language models built upon the Qwen2 LLMs, which significantly outperforms the mathematical capabilities of open-source models and even closed-source models (e.g., GPT-4o). We hope that Qwen2-Math can contribute to the community for solving complex mathematical problems.",
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "4k",
  outputLength: "2k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2-math/",
  vectorSize: undefined,
  slug: generateSlug("qwen2-math:72b"), // "qwen2-math-72b"
  docs: generateChatCompletionsDocs("qwen2-math:72b")
},
{
  Name: "deepscaler",
  Category: "math",
  description: `🚀 Democratizing Reinforcement Learning for LLMs 🌟

\`DeepScaleR-1.5B-Preview\` is a language model fine-tuned from \`DeepSeek-R1-Distilled-Qwen-1.5B\` using distributed reinforcement learning (RL) to scale up to long context lengths. The model achieves 43.1% Pass@1 accuracy on AIME 2024, representing a 15% improvement over the base model (28.8%) and surpassing OpenAI’s O1-Preview performance with just 1.5B parameters.`,
  Creator: "Agentica",
  creatorUrl: "https://huggingface.co/agentica-org",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "32k",
  outputLength: "8k",
  blogUrl: "https://pretty-radio-b75.notion.site/DeepScaleR-Surpassing-O1-Preview-with-a-1-5B-Model-by-Scaling-RL-19681902c1468005bed8ca303013a4e2",
  vectorSize: undefined,
  slug: generateSlug("deepscaler"), // "deepscaler"
  docs: generateChatCompletionsDocs("deepscaler")
},
 {
  Name: "qwen2.5-coder:3b",
  Category: "code",
  description: `**Powerful**: \`Qwen2.5-Coder-32B-Instruct\` has become the current SOTA open-source code model, matching the coding capabilities of GPT-4o. While demonstrating strong and comprehensive coding abilities, it also possesses good general and mathematical skills;
**Diverse**: Building on the previously open-sourced two sizes of 1.5B / 7B, this release brings four model sizes, including 0.5B / 3B / 14B / 32B. As of now, Qwen2.5-Coder has covered six mainstream model sizes to meet the needs of different developers;
**Practical**: We explore the practicality of Qwen2.5-Coder in two scenarios, including code assistants and Artifacts, with some examples showcasing the potential applications of Qwen2.5-Coder in real-world scenarios`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "32k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5-coder-family/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5-coder:3b"), // "qwen2-5-coder-3b"
  docs: generateChatCompletionsDocs("qwen2.5-coder:3b")
},
{
  Name: "qwen2.5-coder:7b",
  Category: "code",
  description: `**Powerful**: \`Qwen2.5-Coder-32B-Instruct\` has become the current SOTA open-source code model, matching the coding capabilities of GPT-4o. While demonstrating strong and comprehensive coding abilities, it also possesses good general and mathematical skills;
**Diverse**: Building on the previously open-sourced two sizes of 1.5B / 7B, this release brings four model sizes, including 0.5B / 3B / 14B / 32B. As of now, Qwen2.5-Coder has covered six mainstream model sizes to meet the needs of different developers;
**Practical**: We explore the practicality of Qwen2.5-Coder in two scenarios, including code assistants and Artifacts, with some examples showcasing the potential applications of Qwen2.5-Coder in real-world scenarios`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "131k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5-coder-family/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5-coder:7b"), // "qwen2-5-coder-7b"
  docs: generateChatCompletionsDocs("qwen2.5-coder:7b")
},
{
  Name: "qwen2.5-coder:14b",
  Category: "code",
  description: `**Powerful**: \`Qwen2.5-Coder-32B-Instruct\` has become the current SOTA open-source code model, matching the coding capabilities of GPT-4o. While demonstrating strong and comprehensive coding abilities, it also possesses good general and mathematical skills;
**Diverse**: Building on the previously open-sourced two sizes of 1.5B / 7B, this release brings four model sizes, including 0.5B / 3B / 14B / 32B. As of now, Qwen2.5-Coder has covered six mainstream model sizes to meet the needs of different developers;
**Practical**: We explore the practicality of Qwen2.5-Coder in two scenarios, including code assistants and Artifacts, with some examples showcasing the potential applications of Qwen2.5-Coder in real-world scenarios`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5-coder-family/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5-coder:14b"), // "qwen2-5-coder-14b"
  docs: generateChatCompletionsDocs("qwen2.5-coder:14b")
},
{
  Name: "qwen2.5-coder:32b",
  Category: "code",
  description: `**Powerful**: \`Qwen2.5-Coder-32B-Instruct\` has become the current SOTA open-source code model, matching the coding capabilities of GPT-4o. While demonstrating strong and comprehensive coding abilities, it also possesses good general and mathematical skills;
**Diverse**: Building on the previously open-sourced two sizes of 1.5B / 7B, this release brings four model sizes, including 0.5B / 3B / 14B / 32B. As of now, Qwen2.5-Coder has covered six mainstream model sizes to meet the needs of different developers;
**Practical**: We explore the practicality of Qwen2.5-Coder in two scenarios, including code assistants and Artifacts, with some examples showcasing the potential applications of Qwen2.5-Coder in real-world scenarios`,
  Creator: "Qwen",
  creatorUrl: "https://qwenlm.github.io/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://qwenlm.github.io/blog/qwen2.5-coder-family/",
  vectorSize: undefined,
  slug: generateSlug("qwen2.5-coder:32b"), // "qwen2-5-coder-32b"
  docs: generateChatCompletionsDocs("qwen2.5-coder:32b")
},
{
  Name: "deepcoder:14b",
  Category: "code",
  description: "`DeepCoder-14B-Preview` is a code reasoning LLM fine-tuned from `DeepSeek-R1-Distilled-Qwen-14B` using distributed reinforcement learning (RL) to scale up to long context lengths. The model achieves 60.6% Pass@1 accuracy on LiveCodeBench v5 (8/1/24-2/1/25), representing a 8% improvement over the base model (53%) and achieving similar performance to OpenAI's o3-mini with just 14B parameters.",
  Creator: "Agentica",
  creatorUrl: "https://huggingface.co/agentica-org/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://pretty-radio-b75.notion.site/DeepCoder-A-Fully-Open-Source-14B-Coder-at-O3-mini-Level-1cf81902c14680b3bee5eb349a512a51",
  vectorSize: undefined,
  slug: generateSlug("deepcoder:14b"), // "deepcoder-14b"
  docs: generateChatCompletionsDocs("deepcoder:14b")
},
{
  Name: "codegemma:2b",
  Category: "code",
  description: "`CodeGemma` is a collection of powerful, lightweight models that can perform a variety of coding tasks like fill-in-the-middle code completion, code generation, natural language understanding, mathematical reasoning, and instruction following.",
  Creator: "Google",
  creatorUrl: "https://huggingface.co/google/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "8k",
  outputLength: "4k",
  blogUrl: "https://arxiv.org/abs/2406.11409",
  vectorSize: undefined,
  slug: generateSlug("codegemma:2b"), // "codegemma-2b"
  docs: generateChatCompletionsDocs("codegemma:2b")
},
{
  Name: "codegemma:7b",
  Category: "code",
  description: "`CodeGemma` is a collection of powerful, lightweight models that can perform a variety of coding tasks like fill-in-the-middle code completion, code generation, natural language understanding, mathematical reasoning, and instruction following.",
  Creator: "Google",
  creatorUrl: "https://huggingface.co/google/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "8k",
  outputLength: "4k",
  blogUrl: "https://arxiv.org/abs/2406.11410",
  vectorSize: undefined,
  slug: generateSlug("codegemma:7b"), // "codegemma-7b"
  docs: generateChatCompletionsDocs("codegemma:7b")
},
{
  Name: "deepseek-coder:1.3b",
  Category: "code",
  description: `\`Deepseek Coder\` is composed of a series of code language models, each trained from scratch on 2T tokens, with a composition of 87% code and 13% natural language in both English and Chinese. We provide various sizes of the code model, ranging from 1B to 33B versions. Each model is pre-trained on project-level code corpus by employing a window size of 16K and a extra fill-in-the-blank task, to support project-level code completion and infilling. For coding capabilities, Deepseek Coder achieves state-of-the-art performance among open-source code models on multiple programming languages and various benchmarks.

*   **Massive Training Data**: Trained from scratch on 2T tokens, including 87% code and 13% linguistic data in both English and Chinese languages.
*   **Highly Flexible & Scalable**: Offered in model sizes of 1.3B, 5.7B, 6.7B, and 33B, enabling users to choose the setup most suitable for their requirements.
*   **Superior Model Performance**: State-of-the-art performance among publicly available code models on HumanEval, MultiPL-E, MBPP, DS-1000, and APPS benchmarks.
*   **Advanced Code Completion Capabilities**: A window size of 16K and a fill-in-the-blank task, supporting project-level code completion and infilling tasks.`,
  Creator: "Deepseek",
  creatorUrl: "https://huggingface.co/deepseek-ai/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "16k",
  outputLength: undefined, // Not specified in data
  blogUrl: "https://deepseekcoder.github.io/",
  vectorSize: undefined,
  slug: generateSlug("deepseek-coder:1.3b"), // "deepseek-coder-1-3b"
  docs: generateChatCompletionsDocs("deepseek-coder:1.3b")
},
{
  Name: "deepseek-coder:6.7b",
  Category: "code",
  description: `\`Deepseek Coder\` is composed of a series of code language models, each trained from scratch on 2T tokens, with a composition of 87% code and 13% natural language in both English and Chinese. We provide various sizes of the code model, ranging from 1B to 33B versions. Each model is pre-trained on project-level code corpus by employing a window size of 16K and a extra fill-in-the-blank task, to support project-level code completion and infilling. For coding capabilities, Deepseek Coder achieves state-of-the-art performance among open-source code models on multiple programming languages and various benchmarks.

*   **Massive Training Data**: Trained from scratch on 2T tokens, including 87% code and 13% linguistic data in both English and Chinese languages.
*   **Highly Flexible & Scalable**: Offered in model sizes of 1.3B, 5.7B, 6.7B, and 33B, enabling users to choose the setup most suitable for their requirements.
*   **Superior Model Performance**: State-of-the-art performance among publicly available code models on HumanEval, MultiPL-E, MBPP, DS-1000, and APPS benchmarks.
*   **Advanced Code Completion Capabilities**: A window size of 16K and a fill-in-the-blank task, supporting project-level code completion and infilling tasks.`,
  Creator: "Deepseek",
  creatorUrl: "https://huggingface.co/deepseek-ai/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "16k",
  outputLength: undefined, // Not specified in data
  blogUrl: "https://deepseekcoder.github.io/",
  vectorSize: undefined,
  slug: generateSlug("deepseek-coder:6.7b"), // "deepseek-coder-6-7b"
  docs: generateChatCompletionsDocs("deepseek-coder:6.7b")
},
{
  Name: "deepseek-coder-v2:16b",
  Category: "code",
  description: "We present \`DeepSeek-Coder-V2\`, an open-source Mixture-of-Experts (MoE) code language model that achieves performance comparable to GPT4-Turbo in code-specific tasks. Specifically, DeepSeek-Coder-V2 is further pre-trained from an intermediate checkpoint of DeepSeek-V2 with additional 6 trillion tokens. Through this continued pre-training, DeepSeek-Coder-V2 substantially enhances the coding and mathematical reasoning capabilities of DeepSeek-V2, while maintaining comparable performance in general language tasks. Compared to DeepSeek-Coder-33B, DeepSeek-Coder-V2 demonstrates significant advancements in various aspects of code-related tasks, as well as reasoning and general capabilities. Additionally, DeepSeek-Coder-V2 expands its support for programming languages from 86 to 338, while extending the context length from 16K to 128K.",
  Creator: "Deepseek",
  creatorUrl: "https://huggingface.co/deepseek-ai/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: undefined, // Not specified in data
  blogUrl: "https://deepseekcoder.github.io/",
  vectorSize: undefined,
  slug: generateSlug("deepseek-coder-v2:16b"), // "deepseek-coder-v2-16b"
  docs: generateChatCompletionsDocs("deepseek-coder-v2:16b")
},
{
  Name: "stable diffusion 2.1",
  Category: "image",
  description: "A latent text-to-image diffusion model capable of generating photo-realistic images given any text input.",
  Creator: "Stable Diffusion",
  creatorUrl: "https://huggingface.co/stabilityai/stable-diffusion-2-1", // Using HF as creator URL
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("image"),
  contextSize: undefined, // N/A for image models
  outputLength: undefined, // N/A for image models
  blogUrl: undefined, // No blog post listed
  vectorSize: undefined,
  slug: generateSlug("stable diffusion 2.1"), // "stable-diffusion-2-1"
  docs: generateImageDocs("stable diffusion 2.1")
},
{
  Name: "kokoro-82m",
  Category: "audio",
  description: "`Kokoro` is an open-weight TTS model with 82 million parameters. Despite its lightweight architecture, it delivers comparable quality to larger models while being significantly faster and more cost-efficient. With Apache-licensed weights, Kokoro can be deployed anywhere from production environments to personal projects.",
  Creator: "Hexgrad",
  creatorUrl: "https://huggingface.co/hexgrad",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("voice"), // Changed to 'voice' to match description
  contextSize: undefined, // N/A for TTS
  outputLength: undefined, // N/A for TTS
  blogUrl: undefined, // No blog post listed, HF page linked in creatorUrl
  vectorSize: undefined,
  slug: generateSlug("kokoro-82m"), // "kokoro-82m"
  docs: generateTtsDocs("kokoro-82m")
},
{
  Name: "Wan-AI/Wan2.1-T2V-1.3B",
  Category: "video",
  description: `\`Wan2.1\`, a comprehensive and open suite of video foundation models that pushes the boundaries of video generation. Wan2.1 offers these key features:

*   👍 **SOTA Performance**: Wan2.1 consistently outperforms existing open-source models and state-of-the-art commercial solutions across multiple benchmarks.
*   👍 **Supports Consumer-grade GPUs**: The T2V-1.3B model requires only 8.19 GB VRAM, making it compatible with almost all consumer-grade GPUs. It can generate a 5-second 480P video on an RTX 4090 in about 4 minutes (without optimization techniques like quantization). Its performance is even comparable to some closed-source models.
*   👍 **Multiple Tasks**: Wan2.1 excels in Text-to-Video, Image-to-Video, Video Editing, Text-to-Image, and Video-to-Audio, advancing the field of video generation.
*   👍 **Visual Text Generation**: Wan2.1 is the first video model capable of generating both Chinese and English text, featuring robust text generation that enhances its practical applications.`,
  Creator: "Wan AI",
  creatorUrl: "https://huggingface.co/Wan-AI/Wan2.1-T2V-1.3B", // Using HF as creator URL
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("video"),
  contextSize: undefined, // N/A for video models
  outputLength: undefined, // N/A for video models
  blogUrl: undefined, // No blog post listed
  vectorSize: undefined,
  slug: generateSlug("Wan-AI/Wan2.1-T2V-1.3B"), // "wan-ai-wan2-1-t2v-1-3b"
  docs: generateVideoDocs("Wan-AI/Wan2.1-T2V-1.3B")
},
{
  Name: "granite3.3:8b",
  Category: "text",
  description: "The IBM Granite 3.3 8B model is an 8-billion-parameter instruction-tuned LLM with a 128K token context window, optimized for reasoning, instruction following, fill-in-the-middle code completion, and structured reasoning.",
  Creator: "IBM",
  creatorUrl: "https://www.ibm.com/granite/docs/models/granite/",
  InputModalities: parseModalities("text"),
  OutputModalities: parseModalities("text"),
  contextSize: "128k",
  outputLength: "8k",
  blogUrl: "https://www.ibm.com/granite/docs/models/granite/",
  slug: generateSlug("granite3.3:8b"),
  docs: generateChatCompletionsDocs("granite3.3:8b")
},
];

interface EndpointDoc{
  route: string;
  docs: string;
}

export const endpoints: EndpointDoc[] = [
  {
    route: "/api/v1/embeddings",
    docs: `
## Endpoint \`POST /api/v1/embeddings\`

Generate vector-embeddings through your decentralized compute network.
The central **Next .js App Router** accepts the request, selects a healthy Ollama provider node (running in a Tauri side-car), forwards the call, rewards the provider, and streams the response back.

---

### 1  URL

\`\`\`
POST https://<your-orchestrator-host>/api/v1/embeddings
\`\`\`

---

### 2  Pre-flight (CORS)

\`\`\`
OPTIONS /api/v1/embeddings
\`\`\`

| Header | Value |
|--------|-------|
| Access-Control-Allow-Origin | \`*\` |
| Access-Control-Allow-Headers | \`Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer\` |
| Access-Control-Allow-Methods | \`POST, OPTIONS\` |

---

### 3  Request Headers

| Header | Required | Description |
|--------|----------|-------------|
| **Authorization** | ✓ | \`Bearer <API_KEY>\` – your issued API key. |
| **X-User-Id** | ✓ | Internal user / customer identifier used for metering. |
| **X-Title** | — | Friendly service / product name (used for per-service analytics). |
| **HTTP-Referer** | — | Originating page URL (captured for analytics). |
| **Content-Type** | ✓ | \`application/json\` |

---

### 4  Request Body

\`\`\`jsonc
{
  "model":        "string",            // e.g. "nomic-embed-text"
  "input":        "string|string[]",   // plain text or array of texts
  "truncate":     true|false,          // optional – whether to truncate long inputs
  "keep_alive":   "2h" | 3600,         // optional – keep model weights hot
  // Any additional Ollama runtime options are also accepted:
  "temperature":  0.0,
  "repeat_penalty": 1.1
}
\`\`\`

| Field | Type | Required | Notes |
|-------|------|----------|-------|
| \`model\` | \`string\` | ✓ | Name of an embeddings-capable Ollama model available on the network. |
| \`input\` | \`string\` or \`string[]\` | ✓ | One or more texts to embed. |
| \`truncate\` | \`boolean\` | — | If \`true\`, long inputs are truncated instead of erroring. |
| \`keep_alive\` | \`string\` \\| \`number\` | — | Duration to keep the model loaded (\`"30m"\`, \`"2h"\`, or seconds). |
| _…any other key_ | \`any\` | — | Passed straight through to Ollama; use to tune runtime (e.g. \`temperature\`). |

---

### 5  Successful Response \`200 OK\`

\`\`\`jsonc
{
  "model": "nomic-embed-text",
  "embeddings": [[0.019, -0.023, … ], …],
  "total_duration": 842,      // ms – wall-clock
  "load_duration": 337,       // ms – model load if cold
  "prompt_eval_count": 1
}
\`\`\`

| Field | Type | Description |
|-------|------|-------------|
| \`model\` | \`string\` | Echo of the model used. |
| \`embeddings\` | \`number[][]\` | Array of embedding vectors (one per input). |
| \`total_duration\` | \`number\` | End-to-end time on the provider in ms. |
| \`load_duration\` | \`number\` | Time spent loading the model (0 if already resident). |
| \`prompt_eval_count\` | \`number\` | Tokens processed internally by Ollama. |

The response is returned with \`Content-Type: application/json\` and \`Access-Control-Allow-Origin: *\`.

---

### 6  Error Responses

| HTTP status | JSON shape | When it happens |
|-------------|------------|-----------------|
| **400** | \`{ "error": "Missing required parameter: model, input" }\` | \`model\` or \`input\` missing. |
| **401** | \`{ "error": "Invalid API key" }\` | Bad or absent \`Authorization\` header. |
| **503** | \`{ "error": "No healthy embeddings provision found" }\` | All provider nodes failed health-checks. |
| **500** | \`{ "error": "Internal server error" }\` | Unhandled exception in router. |
| **> =502** (proxy) | \`{ "error": "Node error: …" }\` | Provider node replied non-200; message forwarded. |

---

### 7  End-to-End Flow (internals)

1. **Validate key** – credits check via \`validateApiKey\`.
2. **Choose provider** – \`selectEmbeddingsProvision(model)\` → returns \`{ provisionEndpoint, providerId, provisionId }\`. Health-checked up to 3 times; dead nodes are deregistered.
3. **Forward request** – JSON envelope is POSTed to \`http://<node>/embeddings\`.
4. **Measure latency** – total router → node → router time (plus node’s \`load_duration\`).
5. **Record metrics** – \`updateEmbeddingsMetadata\`, \`updateEmbeddingsServiceMetadata\`.
6. **Reward provider** – micro-payment \`rewardProvider(providerId, 0.01)\`.
7. **Return response** – passthrough of Ollama JSON plus CORS headers.

*These internals are purely informational; client code only sees the public contract.*

---

### 8  Example cURL

\`\`\`bash
curl https://api.my-net.io/api/v1/embeddings \\
  -H "Authorization: Bearer sk-live-abc123" \\
  -H "X-User-Id: user_42" \\
  -H "Content-Type: application/json" \\
  -d '{
        "model":"nomic-embed-text",
        "input":["Hello, world!", "Second sentence."],
        "truncate":false,
        "keep_alive":"30m"
      }'
\`\`\`

---

### 9  OpenAPI (YAML snippet)

\`\`\`yaml
paths:
  /api/v1/embeddings:
    post:
      summary: Generate text embeddings
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/EmbeddingsRequest'
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EmbeddingsResponse'
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '503': { $ref: '#/components/responses/ServiceUnavailable' }
        '500': { $ref: '#/components/responses/InternalError' }

components:
  schemas:
    EmbeddingsRequest:
      type: object
      required: [model, input]
      properties:
        model: { type: string }
        input: { oneOf: [{ type: string }, { type: array, items: { type: string } }] }
        truncate: { type: boolean }
        keep_alive: { oneOf: [{ type: string }, { type: number }] }
        # Additional properties allowed
      additionalProperties: true
    EmbeddingsResponse:
      type: object
      properties:
        model: { type: string }
        embeddings:
          type: array
          items:
            type: array
            items: { type: number }
        total_duration: { type: number }
        load_duration: { type: number }
        prompt_eval_count: { type: number }
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
\`\`\`

---

### 10  Provider-Node Endpoint (for reference only)

\`\`\`
POST http://<node-host>:<port>/embeddings
\`\`\`

Body and response signatures are identical to the public endpoint; authentication is not required because all calls originate from the orchestrator.

---

### 11  Changelog

| Date (UTC) | Change |
|------------|--------|
| 2025-04-26 | Initial specification drafted. |

---

> **Next step:** Let me know which endpoint you’d like to document next (e.g., \`/api/v1/completions\`, health probes, credits, etc.), or if you prefer the docs exported in another format (HTML, PDF, full OpenAPI file, etc.).
`
  },
  {
    route: "/api/v1/video",
    docs: `
## Endpoint \`POST /api/v1/video\`

Turn a text prompt into an **MP4 video** via your decentralized media-model network.
The Next .js router validates the request, selects a healthy “Wan T2V” provider node, streams the MP4 back, and rewards the node.

---

### 1  URL

\`\`\`
POST https://<orchestrator-host>/api/v1/video
\`\`\`

---

### 2  Pre-flight (CORS)

\`\`\`
OPTIONS /api/v1/video
\`\`\`

| Header | Value |
|--------|-------|
| Access-Control-Allow-Origin | \`*\` |
| Access-Control-Allow-Headers | \`Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer\` |
| Access-Control-Allow-Methods | \`POST, OPTIONS\` |

---

### 3  Request Headers

| Header | Required | Description |
|--------|----------|-------------|
| **Authorization** | ✓ | \`Bearer <API_KEY>\` |
| **X-User-Id** | ✓ | Internal user identifier for metering / quotas. |
| **X-Title** | — | Service name for per-service analytics. |
| **HTTP-Referer** | — | Originating page URL. |
| **Content-Type** | ✓ | \`application/json\` |

---

### 4  Request Body

\`\`\`jsonc
{
  "prompt":              "Two cats boxing on a stage",   // required
  "size":                "832*480",                      // required (width*height)
  "ckpt_dir":            "./Wan2.1-T2V-1.3B",            // optional – overrides default model dir
  "sample_shift":        8,                              // optional int
  "sample_guide_scale":  6,                              // optional float
  "offload_model":       true,                           // optional – CPU/GPU memory trade-off
  "t5_cpu":              true,                           // optional – run text encoder on CPU
  // …any other CLI flags your generate.py supports
}
\`\`\`

| Field | Type | Required | Notes |
|-------|------|----------|-------|
| \`prompt\` | \`string\` | ✓ | Text description of the desired clip. |
| \`size\` | \`string\` | ✓ | Resolution in \`<width>*<height>\` format (e.g. \`832*480\`). |
| \`ckpt_dir\` | \`string\` | — | Absolute/relative path to a Wan T2V checkpoint; defaults to the node’s configured model. |
| \`sample_shift\` | \`integer\` | — | Temporal sampling offset. |
| \`sample_guide_scale\` | \`number\` | — | Classifier-free guidance strength. |
| \`offload_model\` | \`boolean\` | — | Off-loads non-active layers to RAM or disk. |
| \`t5_cpu\` | \`boolean\` | — | Runs the T5 text encoder on CPU to free GPU VRAM. |
| _…any other key_ | \`any\` | — | Passed straight through to the provider’s \`generate.py\`. |

---

### 5  Successful Response \`200 OK\`

*Binary stream* – an MP4 file.

| Header | Value |
|--------|-------|
| \`Content-Type\` | \`video/mp4\` |
| \`Access-Control-Allow-Origin\` | \`*\` |

> The body is a **streaming MP4**; consume it as a file/pipe, not JSON.

---

### 6  Error Responses

| HTTP status | JSON body | Cause |
|-------------|-----------|-------|
| **400** | \`{ "error": "Missing required fields \\"prompt\\" and \\"size\\"." }\` | \`prompt\` or \`size\` not supplied. |
| **401** | \`{ "error": "Invalid API key" }\` | Bad or absent \`Authorization\`. |
| **503** | \`{ "error": "No healthy video provision found" }\` | All provider nodes failed health-checks. |
| **500** | \`{ "error": "Internal server error" }\` | Unhandled exception in router. |
| **502-504** | \`{ "error": "Node error: …" }\` | Provider returned non-200; message forwarded verbatim. |

---

### 7  Example cURL

\`\`\`bash
curl https://api.my-net.io/api/v1/video \\
  -H "Authorization: Bearer sk-live-abc123" \\
  -H "X-User-Id: user_42" \\
  -H "Content-Type: application/json" \\
  --output boxing_cats.mp4 \\
  -d '{
        "prompt":"Two cats boxing on a stage",
        "size":"832*480",
        "sample_guide_scale":6,
        "offload_model":true
      }'
\`\`\`

---

### 8  OpenAPI Snippet

\`\`\`yaml
paths:
  /api/v1/video:
    post:
      summary: Generate an MP4 video from a text prompt
      operationId: createVideo
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/VideoRequest'
      responses:
        '200':
          description: MP4 stream
          content:
            video/mp4: {}
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '503': { $ref: '#/components/responses/ServiceUnavailable' }
        '500': { $ref: '#/components/responses/InternalError' }

components:
  schemas:
    VideoRequest:
      type: object
      required: [prompt, size]
      properties:
        prompt: { type: string }
        size:   { type: string, pattern: '^[0-9]+\\\\*[0-9]+$' } # Escaped backslash for pattern
        ckpt_dir: { type: string }
        sample_shift: { type: integer }
        sample_guide_scale: { type: number }
        offload_model: { type: boolean }
        t5_cpu: { type: boolean }
      additionalProperties: true
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
\`\`\`

---

### 9  Internal Flow (router → node)

1. **Key validation** \`validateApiKey\`.
2. **Node selection** \`selectVideoProvision("wan2.1")\` + health probe (max 3 attempts).
3. **Forward** to \`http://<node>/video\` with the same JSON body.
4. **Provider** runs \`python generate.py …\` and writes an MP4 to disk.
5. **Stream** MP4 back through the router (\`Response(nodeResp.body, { "Content-Type": "video/mp4" })\`).
6. **Metrics** \`updateVideoMetadata(latency)\` and (optionally) \`updateVideoServiceMetadata\`.
7. **Reward** node owner \`rewardProvider(providerId, 0.01)\`.

Clients never see these internals—only the MP4 stream.

---

### 10  Provider-Node Endpoint (reference)

\`\`\`
POST http://<node-host>:<port>/video
\`\`\`

Same JSON as the public endpoint; returns an MP4 stream. No auth needed because only the orchestrator calls it.

---

### 11  Changelog

| Date (UTC) | Change |
|------------|--------|
| 2025-04-26 | Initial specification written. |

---

**Next:** tell me which route you’d like documented next (images, completions, health, billing, …); or ask for a full compiled OpenAPI/Swagger file, markdown site, or PDF.
`,
  },
  {
    route: "/api/v1/image",
    docs: `
## Endpoint \`POST /api/v1/image\`

Create a **PNG image** from a text prompt via the decentralized diffusion-model network.
The Next .js router selects a healthy Stable Diffusion node, forwards the request, rewards the node, and streams the PNG back.

---

### 1 URL
\`\`\`
POST https://<orchestrator-host>/api/v1/image
\`\`\`

---

### 2 Pre-flight (CORS)
\`\`\`
OPTIONS /api/v1/image
\`\`\`

| Header | Value |
|--------|-------|
| Access-Control-Allow-Origin | \`*\` |
| Access-Control-Allow-Headers | \`Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer\` |
| Access-Control-Allow-Methods | \`POST, OPTIONS\` |

---

### 3 Request Headers

| Header | Required | Description |
|--------|----------|-------------|
| **Authorization** | ✓ | \`Bearer <API_KEY>\` |
| **X-User-Id** | ✓ | Internal user/customer id for metering. |
| **X-Title** | — | Friendly service / product name (per-service analytics). |
| **HTTP-Referer** | — | Originating page URL (analytics). |
| **Content-Type** | ✓ | \`application/json\` |

---

### 4 Request Body

\`\`\`jsonc
{
  "prompt":             "an astronaut riding a horse",   // required
  "negativePrompt":     "low-res, blurry",               // optional
  "numInferenceSteps":  30,                              // optional (default 30)
  "width":              512,                             // optional (default 512)
  "height":             512,                             // optional (default 512)

  // …any diffusers / Stable Diffusion runtime options
}
\`\`\`

| Field | Type | Required | Notes |
|-------|------|----------|-------|
| \`prompt\` | \`string\` | ✓ | The positive text-to-image prompt. |
| \`negativePrompt\` | \`string\` | — | Content to steer *away* from. |
| \`numInferenceSteps\` | \`integer\` | — | Diffusion steps (quality vs. speed). |
| \`width\`,\`height\` | \`integer\` | — | Output resolution in pixels (powers of 8). |
| _…any other key_ | \`any\` | — | Passed straight to Diffusers pipeline. |

---

### 5 Successful Response \`200 OK\`

*Binary stream* – a PNG file.

| Header | Value |
|--------|-------|
| \`Content-Type\` | \`image/png\` |
| \`Access-Control-Allow-Origin\` | \`*\` |

> The body is a **streaming PNG**; save it as a file or pipe it onward.

---

### 6 Error Responses

| HTTP status | JSON body | Cause |
|-------------|-----------|-------|
| **400** | \`{ "error": "Missing \\'prompt\\' field." }\` | \`prompt\` absent. |
| **401** | \`{ "error": "Invalid API key" }\` | Bad/absent \`Authorization\`. |
| **503** | \`{ "error": "No healthy image provision found" }\` | All image nodes failed health-check. |
| **500** | \`{ "error": "Internal server error" }\` | Unhandled exception in router. |
| **502-504** | \`{ "error": "Node error: …" }\` | Provider returned non-200; message forwarded. |

---

### 7 Example cURL

\`\`\`bash
curl https://api.my-net.io/api/v1/image \\
  -H "Authorization: Bearer sk-live-abc123" \\
  -H "X-User-Id: user_42" \\
  -H "Content-Type: application/json" \\
  --output astronaut_horse.png \\
  -d '{
        "prompt": "an astronaut riding a horse",
        "negativePrompt": "low-res, blurry",
        "numInferenceSteps": 40,
        "width": 640,
        "height": 640
      }'
\`\`\`

---

### 8 OpenAPI Snippet

\`\`\`yaml
paths:
  /api/v1/image:
    post:
      summary: Generate a PNG image from a text prompt
      operationId: createImage
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ImageRequest'
      responses:
        '200':
          description: PNG stream
          content:
            image/png: {}
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '503': { $ref: '#/components/responses/ServiceUnavailable' }
        '500': { $ref: '#/components/responses/InternalError' }

components:
  schemas:
    ImageRequest:
      type: object
      required: [prompt]
      properties:
        prompt: { type: string }
        negativePrompt: { type: string }
        numInferenceSteps: { type: integer, minimum: 1 }
        width:  { type: integer, minimum: 64 }
        height: { type: integer, minimum: 64 }
      additionalProperties: true
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
\`\`\`

---

### 9 Internal Flow (router → node)

1. **API-key check** \`validateApiKey\`.
2. **Node selection** \`selectImageProvision("stable-diffusion-2-1-base")\` + three health probes.
3. **Forward** JSON to \`http://<node>/image\`.
4. **Provider** runs Diffusers-JS Stable Diffusion pipeline → PNG.
5. **Stream** PNG back through the router with CORS headers.
6. **Metrics** \`updateImageMetadata(latency)\` and, if \`X-Title\` present, \`updateImageServiceMetadata\`.
7. **Reward** node owner \`rewardProvider(providerId, 0.01)\`.

Clients are unaware of these internals.

---

### 10 Provider-Node Endpoint (reference)

\`\`\`
POST http://<node-host>:<port>/image
\`\`\`
JSON body identical to public endpoint; returns a PNG stream. No auth—calls originate only from the orchestrator.

---

### 11 Changelog

| Date (UTC) | Change |
|------------|--------|
| 2025-04-26 | Initial specification drafted. |

---

**Next:** tell me which route to document next (e.g. \`/api/v1/audio\`, \`/credits/charge\`, health probes) or if you need a consolidated OpenAPI file / HTML docs.
`,
  },
  {
    route: "/api/v1/m/caption",
    docs: ``,
  },
  {
    route: "/api/v1/m/detect",
    docs: ``,
  },
  {
    route: "/api/v1/m/point",
    docs: ``,
  },
  {
    route: "/api/v1/m/query",
    docs: ``,
  },
  {
    route: "/api/v1/tts",
    docs: `
## Vision-Language (“Moon”) API group

These endpoints let you run image-understanding tasks—captioning, object detection, object centroids, and visual Q & A—through your decentralized **Moon** nodes.

All four routes share the same transport, auth, and CORS behaviour; the only differences are the request body and the JSON they return.

---

### 0 Common contract

| Item | Value |
|------|-------|
| **Base URL** | \`https://<orchestrator-host>/api/v1/m\` |
| **Auth header** | \`Authorization: Bearer <API_KEY>\` |
| **Mandatory header** | \`X-User-Id\` – internal customer id |
| **Optional headers** | \`X-Title\`, \`HTTP-Referer\` |
| **Content-Type** | \`application/json\` |
| **Pre-flight** | \`OPTIONS /api/v1/m/*\` returns:<br>\`Access-Control-Allow-Origin: *\`<br>\`Access-Control-Allow-Methods: POST, OPTIONS\` |

Error codes are consistent with earlier routes (\`400\`, \`401\`, \`503\`, \`500\`, plus propagated node errors).

---

## 1 \`POST /api/v1/m/caption\`

### Purpose
Generate a **natural-language caption** for an input image.

### Request body
\`\`\`jsonc
{
  // Image (choose one)
  "imageUrl":     "https://example.com/pic.jpg"  // remote or data URI
  "imageBase64":  "<base64-string>",
  "imageUint8":   [255, 216, 255, 224, …],

  // Options
  "length": "short" | "normal" | "long"   // default: "normal"
}
\`\`\`

### Success \`200 OK\`
\`\`\`json
{ "caption": "A golden retriever catching a frisbee in mid-air." }
\`\`\`

---

## 2 \`POST /api/v1/m/detect\`

### Purpose
Detect **all bounding boxes** of a given object class.

### Request body
\`\`\`jsonc
{
  // Image  (one of …)
  "imageUrl": "...",
  "imageBase64": "...",
  "imageUint8": [...],

  // Required
  "target": "car"            // object label
}
\`\`\`

### Success \`200 OK\`
\`\`\`json
{
  "objects": [
    { "label": "car",
      "box":   [x1, y1, x2, y2],   // pixel coords
      "confidence": 0.92 }
  ]
}
\`\`\`

---

## 3 \`POST /api/v1/m/point\`

### Purpose
Return **centroid point(s)** for all instances of a target object.

### Request body
\`\`\`jsonc
{
  "imageUrl": "...",
  "imageBase64": "...",
  "imageUint8": [...],
  "target": "person"
}
\`\`\`

### Success \`200 OK\`
\`\`\`json
{
  "points": [
    { "x": 312, "y": 154 },
    { "x": 488, "y": 160 }
  ]
}
\`\`\`

---

## 4 \`POST /api/v1/m/query\`

### Purpose
Ask a **free-form question** about an image (visual question answering).

### Request body
\`\`\`jsonc
{
  "imageUrl": "...",
  "imageBase64": "...",
  "imageUint8": [...],
  "question": "How many bicycles are there?"
}
\`\`\`

### Success \`200 OK\`
\`\`\`json
{ "answer": "There are three bicycles." }
\`\`\`

---

### Example cURL (caption)

\`\`\`bash
curl https://api.my-net.io/api/v1/m/caption \\
  -H "Authorization: Bearer sk-live-abc123" \\
  -H "X-User-Id: user_42" \\
  -H "Content-Type: application/json" \\
  -d '{
        "imageUrl":"https://images.example.com/dog.jpg",
        "length":"short"
      }'
\`\`\`

---

### OpenAPI snippet (shared components abbreviated)

\`\`\`yaml
components:
  schemas:
    ImageInput:
      oneOf:
        - type: object
          required: [imageUrl]
          properties: { imageUrl: { type: string, format: uri } }
        - type: object
          required: [imageBase64]
          properties: { imageBase64: { type: string } }
        - type: object
          required: [imageUint8]
          properties:
            imageUint8:
              type: array
              items: { type: integer, minimum: 0, maximum: 255 }
    CaptionRequest:
      allOf:
        - $ref: '#/components/schemas/ImageInput'
        - type: object
          properties:
            length: { type: string, enum: [short, normal, long] }
    CaptionResponse:
      type: object
      properties: { caption: { type: string } }
    DetectRequest:
      allOf:
        - $ref: '#/components/schemas/ImageInput'
        - type: object
          required: [target]
          properties: { target: { type: string } }
    DetectResponse:
      type: object
      properties:
        objects:
          type: array
          items:
            type: object
            properties:
              label: { type: string }
              box:   { type: array, items: { type: number }, minItems: 4, maxItems: 4 }
              confidence: { type: number }
    PointRequest:  { allOf: [ { $ref: '#/components/schemas/DetectRequest' } ] }
    PointResponse:
      type: object
      properties:
        points:
          type: array
          items: { type: object, properties: { x: {type:number}, y:{type:number} } }
    QueryRequest:
      allOf:
        - $ref: '#/components/schemas/ImageInput'
        - type: object
          required: [question]
          properties: { question: { type: string } }
    QueryResponse:
      type: object
      properties: { answer: { type: string } }
\`\`\`

*(Add four \`paths:\` entries referencing these schemas.)*

---

### Internal flow (all four routes)

1. **Key check** \`validateApiKey\`.
2. **Node selection** \`selectMoonProvision()\` → health-probe (3 tries; bad nodes removed).
3. **Forward** request to \`http://<node>/m/{caption\\|detect\\|point\\|query}\`.
4. **Measure** latency; \`updateMoonMetadata(<endpoint>, latency)\`.
5. **Per-service metrics** if \`X-Title\` present.
6. **Reward** node owner \`rewardProvider(providerId, 0.01)\`.
7. **Return** JSON with CORS headers.

---

### Changelog

| Date (UTC) | Change |
|------------|--------|
| 2025-04-26 | Initial specification for caption, detect, point, query. |

---

**Next:** let me know if you want documentation for any remaining endpoints, a merged OpenAPI file, or HTML/PDF output.
`,
  },
  {
    route: "/api/v1/scrape",
    docs: `
## Endpoint \`POST /api/v1/tts\`

Generate **spoken audio (WAV)** from text using the Kokoro TTS model.
This endpoint is typically handled directly by the orchestrator or a dedicated TTS service, unlike the decentralized model endpoints.

---

### 1  URL

\`\`\`
POST https://<your-orchestrator-host>/api/v1/tts
\`\`\`

---

### 2  Pre-flight (CORS)

\`\`\`
OPTIONS /api/v1/tts
\`\`\`

| Header | Value |
|--------|-------|
| Access-Control-Allow-Origin | \`*\` |
| Access-Control-Allow-Headers | \`Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer\` |
| Access-Control-Allow-Methods | \`POST, OPTIONS\` |

*(Assumes standard CORS setup consistent with other endpoints)*

---

### 3  Request Headers

| Header | Required | Description |
|--------|----------|-------------|
| **Authorization** | ✓ | \`Bearer <API_KEY>\` (Assumed standard auth) |
| **X-User-Id** | ✓ | Internal user/customer id for metering (Assumed standard header) |
| **X-Title** | — | Friendly service / product name (Assumed standard header) |
| **HTTP-Referer** | — | Originating page URL (Assumed standard header) |
| **Content-Type** | ✓ | \`application/json\` |

---

### 4  Request Body

\`\`\`jsonc
{
  "text":   "string",    // required – Text to synthesize
  "voice":  "string"     // optional – Voice ID (e.g., "af_bella", "bm_george")
}
\`\`\`

| Field | Type | Required | Notes |
|-------|------|----------|-------|
| \`text\` | \`string\` | ✓ | The text content to be converted into speech. |
| \`voice\` | \`string\` | — | Optional voice identifier. Defaults to \`"af_bella"\`. Available voices include: \`af\`, \`af_bella\`, \`af_nicole\`, \`af_sarah\`, \`af_sky\`, \`am_adam\`, \`am_michael\`, \`bf_emma\`, \`bf_isabella\`, \`bm_george\`, \`bm_lewis\`, etc. (Refer to Kokoro documentation for full list). |

---

### 5  Successful Response \`200 OK\`

*Binary stream* – a WAV audio file.

| Header | Value |
|--------|-------|
| \`Content-Type\` | \`audio/wav\` |
| \`Access-Control-Allow-Origin\` | \`*\` |

> The body is **streaming WAV audio data**. Consume it directly as an audio file.

---

### 6  Error Responses

| HTTP status | JSON body | Cause |
|-------------|-----------|-------|
| **400** | \`{ "error": "Text is required for TTS." }\` | \`text\` field missing in request body. |
| **401** | \`{ "error": "Invalid API key" }\` | Bad/absent \`Authorization\` (Assumed standard error). |
| **500** | \`{ "error": "<error message from TTS engine>" }\` | Internal server error during TTS processing (e.g., model not loaded, synthesis failed). |
| **503** | \`{ "error": "TTS service unavailable" }\` | Service potentially not ready or overloaded (if applicable). |

---

### 7  Example cURL

\`\`\`bash
curl https://api.my-net.io/api/v1/tts \\
  -H "Authorization: Bearer sk-live-abc123" \\
  -H "X-User-Id: user_42" \\
  -H "Content-Type: application/json" \\
  --output hello_world.wav \\
  -d '{
        "text": "Hello world, this is a test.",
        "voice": "bm_lewis"
      }'
\`\`\`

---

### 8  OpenAPI Snippet

\`\`\`yaml
paths:
  /api/v1/tts:
    post:
      summary: Generate speech (WAV) from text
      operationId: createTts
      security:
        - bearerAuth: [] # Assumed standard security
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/TtsRequest'
      responses:
        '200':
          description: WAV audio stream
          content:
            audio/wav:
              schema:
                type: string
                format: binary
        '400':
           description: Bad Request (e.g., missing text)
           content:
             application/json:
               schema:
                 type: object
                 properties:
                   error: { type: string }
        '401': { $ref: '#/components/responses/Unauthorized' } # Assumed standard
        '500': { $ref: '#/components/responses/InternalError' } # Assumed standard
        '503': { $ref: '#/components/responses/ServiceUnavailable' } # Assumed standard

components:
  schemas:
    TtsRequest:
      type: object
      required: [text]
      properties:
        text:
          type: string
          description: The text to synthesize into speech.
        voice:
          type: string
          description: Optional voice ID. Defaults to 'af_bella'.
          default: 'af_bella'
          example: 'bm_george'
  # Assumed standard responses/securitySchemes defined elsewhere
  responses:
    Unauthorized:
      description: Authentication information is missing or invalid.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/ErrorResponse' }
    InternalError:
      description: Unexpected server error.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/ErrorResponse' }
    ServiceUnavailable:
      description: Service is temporarily unavailable.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/ErrorResponse' }
    ErrorResponse:
      type: object
      properties:
        error: { type: string }
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
\`\`\`

---

### 9  Internal Flow (Orchestrator/Service)

1. **Load Model:** (Done once at startup) The Kokoro TTS model (\`onnx-community/Kokoro-82M-ONNX\`) is loaded into memory using \`KokoroTTS.from_pretrained()\`.
2. **Receive Request:** The Express router receives the POST request.
3. **Validate Input:** Checks for the presence of the required \`text\` field.
4. **Synthesize Audio:** Calls \`tts.generate(text, { voice })\` using the pre-loaded model instance.
5. **Format Output:** The returned \`Audio\` object is converted to WAV format using \`.toWav()\`.
6. **Stream Response:** The WAV audio data (as a Buffer) is sent back to the client with the \`Content-Type: audio/wav\` header.
7. **Error Handling:** Catches errors during synthesis or request processing and returns appropriate JSON error responses.

*(Note: This flow differs from the decentralized endpoints as it likely runs within the main orchestrator or a dedicated service, without node selection or reward mechanisms.)*

---

### 10 Changelog

| Date (UTC) | Change |
|------------|--------|
| 2025-04-27 | Initial specification based on Express router code. |

---
`
  },
  {
    route: "/api/v1/chat/completions",
    docs: `
## Endpoint \`POST /api/v1/chat/completions\`
(OpenAI-compatible chat completions)

The route mirrors the OpenAI \`/v1/chat/completions\` contract so you can point an *unchanged* OpenAI SDK or cURL script at **\`https://<orchestrator-host>/api/v1\`**.
Internally the request is forwarded to an Ollama-compatible node, parameters are translated, usage is metered, and a micro-payment is sent to the provider.

---

### 1 URL and CORS

\`\`\`
POST https://<orchestrator-host>/api/v1/chat/completions
\`\`\`

\`OPTIONS /api/v1/chat/completions\` responds with

\`\`\`
Access-Control-Allow-Origin: *
Access-Control-Allow-Headers: Content-Type, Authorization, X-User-Id, X-Title, HTTP-Referer
Access-Control-Allow-Methods: POST, OPTIONS
\`\`\`

---

### 2 Request Headers

| Header \\| Required \\| Notes |
|--------\\|----------\\|-------|
| **Authorization** \\| ✓ \\| \`Bearer <API_KEY>\` issued by your network |
| **X-User-Id** \\| ✓ \\| Internal customer / tenant id |
| **X-Title** \\| — \\| Friendly service name for per-service stats |
| **HTTP-Referer** \\| — \\| Calling-site URL (analytics) |
| **Content-Type** \\| ✓ \\| \`application/json\` |

---

### 3 Request Body (high-level)

All standard OpenAI fields are accepted (\`model\`, \`messages\`, \`functions\` → translated to Ollama \`tools\`, \`response_format\`, \`stream\`, **plus any** generative parameters such as \`temperature\`, \`top_p\`, \`max_tokens\`, etc.).

\`\`\`jsonc
{
  "model":    "gpt-4o",             // required – any model id present in the network
  "messages": [
    { "role": "system", "content": "You are a helpful assistant." },
    { "role": "user",   "content": "Hello!" }
  ],

  // Optional OpenAI parameters ----------------------------
  "stream": true,
  "temperature": 0.7,
  "functions": [
    {
      "name": "get_weather",
      "description": "Get the weather for a city",
      "parameters": {
        "type": "object",
        "properties": { "city": { "type": "string" } },
        "required": ["city"]
      }
    }
  ],
  "response_format": { "type": "json_object" }
}
\`\`\`

---

### 4 Successful Response

*Non-streaming* — identical to OpenAI’s **chat completion object**:

\`\`\`json
{
  "id": "chatcmpl-qY…",
  "object": "chat.completion",
  "created": 1714143432,
  "model": "gpt-4o",
  "choices": [
    {
      "index": 0,
      "message": { "role": "assistant", "content": "Hello! How can I help you today?" },
      "finish_reason": "stop"
    }
  ],
  "usage": { "prompt_tokens": 14, "completion_tokens": 9, "total_tokens": 23 }
}
\`\`\`

*Streaming* — Server-Sent Events exactly like OpenAI (\`data: { "id": … }\` chunks ending with \`data: [DONE]\`).

---

### 5 Error Codes

| Code \\| Meaning |
|------\\|---------|
| **400** \\| Missing \`model\` or \`messages\` |
| **401** \\| Invalid / missing API key |
| **503** \\| No healthy provision for requested model |
| **500** \\| Internal error (or propagated provider error with status > 500) |

---

### 6 cURL Examples

**Basic (non-streaming)**

\`\`\`bash
curl https://api.my-net.io/api/v1/chat/completions \\
  -H "Content-Type: application/json" \\
  -H "Authorization: Bearer sk-live-abc123" \\
  -H "X-User-Id: user_42" \\
  -d '{
        "model": "gpt-4o",
        "messages": [
          { "role": "system", "content": "You are a helpful assistant." },
          { "role": "user",   "content": "Hello!" }
        ],
        "temperature": 0.7
      }'
\`\`\`

**Streaming**

\`\`\`bash
curl -N https://api.my-net.io/api/v1/chat/completions \\
  -H "Content-Type: application/json" \\
  -H "Authorization: Bearer sk-live-abc123" \\
  -H "X-User-Id: user_42" \\
  -d '{
        "model":"gpt-4o",
        "stream":true,
        "messages":[
          { "role":"system","content":"You are a helpful assistant." },
          { "role":"user","content":"Tell me a joke." }
        ]
      }'
\`\`\`

---

### 7 OpenAI SDK Examples (fully compatible)

> **Tip :** OpenAI’s SDKs require a key even if your backend doesn’t check it; pass any non-empty string.

#### Node ( \`openai\` ≥ 4 )

\`\`\`ts
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: "sk-live-abc123",
  baseURL: "https://api.my-net.io/api/v1",
  defaultHeaders: {           // optional analytics
    "X-User-Id": "user_42",
    "X-Title":  "my-awesome-app"
  },
});

const chat = await openai.chat.completions.create({
  model: "gpt-4o",
  messages: [
    { role: "system", content: "You are a helpful assistant." },
    { role: "user",   content: "How do I center a div in CSS?" }
  ],
  temperature: 0.5,
});

console.log(chat.choices[0].message.content);
\`\`\`

#### Python ( \`openai\` ≥ 1.12 )

\`\`\`py
from openai import OpenAI

client = OpenAI(
    api_key="sk-live-abc123",
    base_url="https://api.my-net.io/api/v1",
    default_headers={
        "X-User-Id": "user_42",
        "X-Title": "my-awesome-app"
    }
)

response = client.chat.completions.create(
    model="gpt-4o",
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user",   "content": "Explain quantum entanglement in 2 sentences."}
    ],
    stream=False          # or True for SSE streaming
)

print(response.choices[0].message.content)
\`\`\`

Both snippets:

* use **valid OpenAI roles** (\`system\`, \`user\`, \`assistant\`, \`tool\`);
* reference a **current model id** (\`gpt-4o\`);
  replace with any model name registered in your network;
* set \`baseURL\`/\`base_url\` so the SDK talks to **your** router, not api.openai.com.

---

### 8 Internal Flow (summary)

1. **Auth + quota** → \`validateApiKey\`.
2. **Provision selection** → \`selectProvision(model)\` → health probes (3 tries).
3. **Request transform**:
   * \`response_format\` → \`format\` (Ollama)
   * \`functions\` → \`tools\`.
4. **Forward** to \`http://<node>/chat/completions\` (stream or JSON).
5. **Metrics & rewards** → \`updateMetadata\`, \`updateServiceMetadata\`, \`rewardProvider\`.
6. **Return** SSE stream or JSON, unmodified from provider (OpenAI shape).

---

### 9 Changelog

| Date (UTC) \\| Change |
|------------\\|--------|
| 2025-04-26 \\| Initial OpenAI-compatible specification added |

---

Need a consolidated OpenAPI file or more examples (function calling, tool choice, Vision messages)? Just let me know!
`,
  },
];

### File: src/lib/privateutils.ts
interface SystemMetadataRecord {
  endpoint: string;        // API endpoint
  model?: string;          // Optional model name
  vramRequired: number;    // in MB
  storageRequired: number; // in MB
  provisionTargetNumber: number;
}

export const ADMIN_EMAILS =[
  'josibobo2014@gmail.com',
  'joshuaokolo@college.harvard.edu',
  'joshua@cxmpute.cloud',
  'admin@cxmpute.cloud'
]

export const SystemProvisionReference: SystemMetadataRecord[] = [
  // EMBEDDINGS
  {
    endpoint: "/embeddings",
    model: "nomic-embed-text",
    vramRequired: 274,
    storageRequired: 274,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "mxbai-embed-large",
    vramRequired: 670,
    storageRequired: 670,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "bge-m3",
    vramRequired: 1200,
    storageRequired: 1200,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "snowflake-arctic-embed:22m",
    vramRequired: 46,
    storageRequired: 46,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "snowflake-arctic-embed:33m",
    vramRequired: 67,
    storageRequired: 67,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "snowflake-arctic-embed:110m",
    vramRequired: 219,
    storageRequired: 219,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "snowflake-arctic-embed:137m",
    vramRequired: 274,
    storageRequired: 274,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "snowflake-arctic-embed:335m",
    vramRequired: 669,
    storageRequired: 669,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "all-minilm:33m",
    vramRequired: 67,
    storageRequired: 67,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "all-minilm:22m",
    vramRequired: 46,
    storageRequired: 46,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/embeddings",
    model: "snowflake-arctic-embed2",
    vramRequired: 1200,
    storageRequired: 1200,
    provisionTargetNumber: 10000,
  },

  // VISION (all share /chat/completions)
  {
    endpoint: "/chat/completions",
    model: "gemma3:1b",
    vramRequired: 815,
    storageRequired: 815,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "gemma3:4b",
    vramRequired: 3300,
    storageRequired: 3300,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "gemma3:12b",
    vramRequired: 8100,
    storageRequired: 8100,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "gemma3:24b",
    vramRequired: 17000,
    storageRequired: 17000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "llama3.2-vision:11b",
    vramRequired: 7900,
    storageRequired: 7900,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "minicpm-v",
    vramRequired: 5500,
    storageRequired: 5500,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "llava-llama3",
    vramRequired: 5500,
    storageRequired: 5500,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "moondream",
    vramRequired: 1700,
    storageRequired: 1700,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "granite3.2-vision",
    vramRequired: 2400,
    storageRequired: 2400,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "mistral-small3.1",
    vramRequired: 15000,
    storageRequired: 15000,
    provisionTargetNumber: 10000,
  },

  // TEXT (/chat/completions)
  {
    endpoint: "/chat/completions",
    model: "cogito:14b",
    vramRequired: 9000,
    storageRequired: 9000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "cogito:32b",
    vramRequired: 20000,
    storageRequired: 20000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "cogito:3b",
    vramRequired: 2200,
    storageRequired: 2200,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "cogito:70b",
    vramRequired: 43000,
    storageRequired: 43000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "cogito:8b",
    vramRequired: 4900,
    storageRequired: 4900,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-r1:1.5b",
    vramRequired: 1100,
    storageRequired: 1100,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-r1:14b",
    vramRequired: 9000,
    storageRequired: 9000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-r1:32b",
    vramRequired: 20000,
    storageRequired: 20000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-r1:70b",
    vramRequired: 43000,
    storageRequired: 43000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-r1:7b",
    vramRequired: 4700,
    storageRequired: 4700,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-r1:8b",
    vramRequired: 4900,
    storageRequired: 4900,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "llama3.1:8b",
    vramRequired: 4900,
    storageRequired: 4900,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "llama3.2:1b",
    vramRequired: 1300,
    storageRequired: 1300,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "llama3.2:3b",
    vramRequired: 2000,
    storageRequired: 2000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "llama3.3",
    vramRequired: 43000,
    storageRequired: 43000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "mistral",
    vramRequired: 4100,
    storageRequired: 4100,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "mistral-nemo",
    vramRequired: 7100,
    storageRequired: 7100,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "phi4",
    vramRequired: 9100,
    storageRequired: 9100,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "phi4-mini",
    vramRequired: 2600,
    storageRequired: 2600,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2.5:14b",
    vramRequired: 9000,
    storageRequired: 9000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2.5:32b",
    vramRequired: 20000,
    storageRequired: 20000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2.5:72b",
    vramRequired: 47000,
    storageRequired: 47000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2.5:7b",
    vramRequired: 4700,
    storageRequired: 4700,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwq",
    vramRequired: 20000,
    storageRequired: 20000,
    provisionTargetNumber: 10000,
  },

  // MATH (/chat/completions)
  {
    endpoint: "/chat/completions",
    model: "mathstral",
    vramRequired: 4100,
    storageRequired: 4100,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2-math:7b",
    vramRequired: 4400,
    storageRequired: 4400,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2-math:72b",
    vramRequired: 41000,
    storageRequired: 41000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepscaler",
    vramRequired: 3600,
    storageRequired: 3600,
    provisionTargetNumber: 10000,
  },

  // CODE (/chat/completions)
  {
    endpoint: "/chat/completions",
    model: "qwen2.5-coder:3b",
    vramRequired: 1900,
    storageRequired: 1900,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2.5-coder:7b",
    vramRequired: 4700,
    storageRequired: 4700,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2.5-coder:14b",
    vramRequired: 9000,
    storageRequired: 9000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "qwen2.5-coder:32b",
    vramRequired: 20000,
    storageRequired: 20000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepcoder:14b",
    vramRequired: 9000,
    storageRequired: 9000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "codegemma:2b",
    vramRequired: 1600,
    storageRequired: 1600,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "codegemma:7b",
    vramRequired: 5000,
    storageRequired: 5000,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-coder:1.3b",
    vramRequired: 776,
    storageRequired: 776,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-coder:6.7b",
    vramRequired: 3800,
    storageRequired: 3800,
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/chat/completions",
    model: "deepseek-coder-v2:16b",
    vramRequired: 8900,
    storageRequired: 8900,
    provisionTargetNumber: 10000,
  },

  // IMAGE
  {
    endpoint: "/image",
    // model: "stable diffusion 2.1",
    model: 'image',
    vramRequired: 8192,    // 8 GB
    storageRequired: 2048, // 2 GB
    provisionTargetNumber: 10000,
  },

  // AUDIO
  {
    endpoint: "/tts",
    // model: "kokoro-82m",
    model: "tts",
    vramRequired: 90,
    storageRequired: 90,
    provisionTargetNumber: 10000,
  },

  // VIDEO
  {
    endpoint: "/video",
    model: "video",
    vramRequired: 8192,     // 8 GB
    storageRequired: 0, // 20 GB
    provisionTargetNumber: 10000,
  },
  {
    endpoint: "/m",
    model: "moon",  
    vramRequired: 2500,     // 2.5 GB
    storageRequired: 0, // 20 GB
    provisionTargetNumber: 10000,
  }
];


export const embeddingModels: string[] = [
  "nomic-embed-text",
  "mxbai-embed-large",
  "bge-m3",
  "snowflake-arctic-embed:22m",
  "snowflake-arctic-embed:33m",
  "snowflake-arctic-embed:110m",
  "snowflake-arctic-embed:137m",
  "snowflake-arctic-embed:335m",
  "all-minilm:33m",
  "all-minilm:22m",
  "snowflake-arctic-embed2",
];

export const chatCompletionModels: string[] = [
  // Vision
  "gemma3:1b",
  "gemma3:4b",
  "gemma3:12b",
  "gemma3:24b",
  "llama3.2-vision:11b",
  "minicpm-v",
  "llava-llama3",
  "moondream",
  "granite3.2-vision",
  "mistral-small3.1",

  // Text
  "cogito:14b",
  "cogito:32b",
  "cogito:3b",
  "cogito:70b",
  "cogito:8b",
  "deepseek-r1:1.5b",
  "deepseek-r1:14b",
  "deepseek-r1:32b",
  "deepseek-r1:70b",
  "deepseek-r1:7b",
  "deepseek-r1:8b",
  "llama3.1:8b",
  "llama3.2:1b",
  "llama3.2:3b",
  "llama3.3",
  "mistral",
  "mistral-nemo",
  "phi4",
  "phi4-mini",
  "qwen2.5:14b",
  "qwen2.5:32b",
  "qwen2.5:72b",
  "qwen2.5:7b",
  "qwq",

  // Math
  "mathstral",
  "qwen2-math:7b",
  "qwen2-math:72b",
  "deepscaler",

  // Code
  "qwen2.5-coder:3b",
  "qwen2.5-coder:7b",
  "qwen2.5-coder:14b",
  "qwen2.5-coder:32b",
  "deepcoder:14b",
  "codegemma:2b",
  "codegemma:7b",
  "deepseek-coder:1.3b",
  "deepseek-coder:6.7b",
  "deepseek-coder-v2:16b",
];

### File: src/lib/auth.ts
// src/lib/auth.ts
import { NextResponse } from "next/server";
import { auth as getAuthenticatedSubject } from "@/app/actions"; // Assuming your actions.ts is in app/

/**
 * Type definition for the user subject returned by your auth() function.
 * Ensure this matches the structure defined in your auth/subjects.ts
 * and returned by the success callback in auth/index.ts.
 */
export interface AuthenticatedUserSubject {
  type: "user"; // Or whatever your subject type is
  properties: {
    id: string;
    providerId: string;
    providerAk: string;
    userAks: string[];
    userAk: string;
    admin: boolean;
    // Add email if it's part of the subject properties and you need it directly
    email: string; // Or get it via another way if not directly in subject
  };
}


/**
 * Middleware-like function to ensure the current user is an admin.
 * It calls the existing `getAuthenticatedSubject` function from `app/actions.ts`.
 * If the user is not authenticated or not an admin, it throws a NextResponse
 * which will halt the execution of the API route and return an error.
 *
 * @param req - The NextRequest object, passed through from the API route.
 * @returns The authenticated user's subject if they are an admin.
 * @throws NextResponse with 401 or 403 status if not authenticated or not an admin.
 */
export async function requireAdmin(): Promise<AuthenticatedUserSubject> {
  const subject = await getAuthenticatedSubject();

  if (!subject || subject.type !== "user") {
    console.warn("requireAdmin: No authenticated user subject found or not of type 'user'.");
    // It's important that this NextResponse is thrown, not just returned,
    // so the calling API route stops execution.
    throw NextResponse.json({ error: "Unauthorized: Authentication required." }, { status: 401 });
  }

  // The `admin` boolean is directly available on subject.properties
  if (!subject.properties.admin) {
    console.warn(`requireAdmin: User ${subject.properties.id} is not an admin.`);
    throw NextResponse.json({ error: "Forbidden: Admin access required." }, { status: 403 });
  }

  // If you needed to check against ADMIN_EMAILS directly using an email from the subject:
  // (This assumes 'email' is part of subject.properties - adjust if it's not)
  // const userEmail = subject.properties.email;
  // if (!userEmail || !ADMIN_EMAILS.includes(userEmail)) {
  //   console.warn(`requireAdmin: User ${subject.properties.id} (Email: ${userEmail}) is not in ADMIN_EMAILS list.`);
  //   throw NextResponse.json({ error: "Forbidden: Admin access denied." }, { status: 403 });
  // }


  // console.log(`requireAdmin: Admin access granted for user ${subject.properties.id}`);
  return subject as AuthenticatedUserSubject; // Cast to specific type for stricter usage
}

// You might also want to have a simple requireAuth if some routes need just authentication
export async function requireAuth(): Promise<AuthenticatedUserSubject> {
    const subject = await getAuthenticatedSubject();
    if (!subject || subject.type !== "user") {
        console.warn("requireAuth: No authenticated user subject found or not of type 'user'.");
        throw NextResponse.json({ error: "Unauthorized: Authentication required." }, { status: 401 });
    }
    return subject as AuthenticatedUserSubject;
}
### File: src/lib/interfaces.ts
// interfaces.ts

//
// COMMON SHARED TYPES
//

/** A day-based reward entry */
export interface RewardEntry {
    day: string;     // e.g., "2025-04-13"
    amount: number;
  }
  
  /** Diagnostics for a device's compute */
  export interface DiagnosticsType {
    osType: "macOS" | "Windows" | "Linux";
    gpu?: {
      name: string;
      memory: number; // MB
      type: "integrated" | "dedicated";
      supportsCUDA: boolean;
    };
    cpu?: {
      name: string;
      cores: number;
      threads: number;
      architecture: string;
    };
    memory?: {
      total: number;
      used: number;
      free: number;
    };
    storage?: {
      total: number;
      used: number;
      free: number;
    };
    os?: {
      name: string;
      version: string;
      architecture: string;
    };
  }
  
  /** A device's diagnostic data plus GPU vs. no-GPU type */
  export interface DeviceDiagnostics {
    compute: DiagnosticsType;
    type: "nogpu" | "gpu";
  }
  
  /** A simple location object */
  export interface Location {
    country: string;
    state: string;
    city: string;
  }
  
  /** A user’s API key info (stored in user.apiKeys[]) */
  export interface ApiKeyInfo {
    key: string;
    creditLimit: number;
    creditsLeft: number;
    permittedRoutes: string[]; // ex: ["/chat/completions", "/embeddings"]
  }
  
  //
  // PROVIDER TABLE
  //
  export interface ProviderRecord {
    providerId: string;
    providerEmail?: string;
    apiKey?: string;                // Additional or transitional if needed
    providerWalletAddress?: string; // Optional if you store wallet
    rewards?: RewardEntry[];        // Past 30 days
    totalRewards?: number;          // Accumulated
  }
  
  //
  // PROVISIONS TABLE
  //
  export interface ProvisionRecord {
    provisionId: string;
    providerId?: string;
    deviceDiagnostics?: DeviceDiagnostics;
    location?: Location;
    // ... any other fields you store
  }
  
  //
  // LLM PROVISION POOL TABLE
  //
  export interface LLMProvisionRecord {
    provisionId: string;
    model: string;
    randomValue: number;           // For random selection
    provisionEndpoint?: string;    // e.g. "https://node-cxmpute.cloud"
    location?: Location;           // optional
  }
  
  //
  // EMBEDDINGS PROVISION POOL TABLE
  //
  export interface EmbeddingsProvisionRecord {
    provisionId: string;
    model: string;
    randomValue: number;
    provisionEndpoint?: string;
    location?: Location;
  }
  
  //
  // SCRAPING PROVISION POOL TABLE
  //
  export interface ScrapingProvisionRecord {
    provisionId: string;
    randomValue: number;
    provisionEndpoint?: string;
    location?: Location;
  }
  
  //
  // MOON PROVISION POOL TABLE
  //
  export interface MoonProvisionRecord {
    provisionId: string;
    randomValue: number;
    provisionEndpoint?: string;
    location?: Location;
  }
  
  //
  // VIDEO & IMAGE PROVISION POOL TABLE (MEDIA)
  //
  export interface MediaProvisionRecord {
    provisionId: string;
    model?: string;
    type?: "image" | "video";
    randomValue: number;
    provisionEndpoint?: string;
    location?: Location;
  }
  
  //
  // TTS PROVISION POOL TABLE
  //
  export interface TTSProvisionRecord {
    provisionId: string;
    model?: string;
    randomValue: number;
    provisionEndpoint?: string;
    location?: Location;
  }
  
  //
  // USER TABLE
  //
  /**
   * A user's record in the system, storing their wallet,
   * ads array, credits, and any relevant data.
   */
  export interface UserRecord {
    userId: string;
    userAk: string;
    userWalletAddress?: string;
    // If you store multiple API keys in an array:
    apiKeys?: ApiKeyInfo[];
    // or if you store user ads or credit usage in an array:
    userAds?: Array<{
      permittedCreditLimit: number;
      permittedRoutes: string[];
      creditsLeft: number;
    }>;
    credits?: number;
    rewards?: RewardEntry[];
    totalRewards?: number;
  }
  
  //
  // METADATA TABLE
  //
  /** Optional LLM info for an endpoint entry. */
  export interface LLMMetadata {
    model: string;
    tokensIn: number;
    tokensOut: number;
    averageTps?: number;
    uptime?: number;
  }
  
  /**
   * A single day's metadata record for an endpoint or model.
   * For example: endpoint='/chat/completions' & dayTimestamp='2025-04-13'.
   */
  export interface MetadataRecord {
    endpoint: string;       // e.g., "/chat/completions"
    dayTimestamp: string;   // e.g., "2025-04-13"
    totalNumRequests?: number;
    averageLatency?: number;
    LLM?: LLMMetadata;
  }
  
  //
  // SERVICE METADATA TABLE
  //
  /**
   * For each endpoint, we might track totalNumRequests + array of daily usage.
   */
  export interface ServiceEndpointUsage {
    totalNumRequests: number;
    requests: Array<{
      dayTimestamp: string;
      numRequests: number;
    }>;
  }
  
  /**
   * For each model (used by /chat/completions), we might track total tokens + daily usage.
   */
  export interface ServiceModelUsage {
    totalInputTokens: number;
    totalOutputTokens: number;
    totals: Array<{
      dayTimestamp: string;
      numInputTokens: number;
      numOutputTokens: number;
    }>;
  }
  
  /**
   * A single service's record in the table, which might hold:
   * - endpoints: item["/embeddings"], item["/m/query"], etc.
   * - models: item["gpt-4"], item["llama2"], etc.
   */
  export interface ServiceMetadataRecord {
    serviceName: string;
    serviceUrl?: string;
    // Possibly:
    [endpointOrModel: string]:
    //   | any
      | ServiceEndpointUsage
      | ServiceModelUsage
      | string
      | undefined;
  }
  
  //
  // NETWORK STATS TABLE
  //
  export interface NetworkStatsRecord {
    dateTimestamp: string;     // e.g., "2025-04-13"
    endpointOrModel: string;   // e.g., "/chat/completions" or "gpt-4"
    currentNumProvisions?: number;
    provisionTier?: number;
  }
  
  //
  // ADVERTISEMENT TABLE
  //
  export interface AdvertisementRecord {
    timeSlotTimestamp: string; // e.g. the start time for a 15-min block
    location: string;          // some location identifier
    content?: string;          // e.g., S3 url
  }
  
/* UUID without hyphens */
export type UUID = string;

/* ── Orders ──────────────────────────────────────────────────────────── */
export type OrderSide = "BUY" | "SELL";
export type OrderStatus = "OPEN" | "PARTIAL" | "FILLED" | "CANCELLED" | "EXPIRED";

interface BaseOrder {
  orderId: UUID;
  traderId: UUID;
  market: string;          // eg. BTC-PERP
  side: OrderSide;
  qty: number;
  filledQty: number;
  createdAt: number;       // ms epoch
  status: OrderStatus;
  feeBps: 100;              // flat 0.5 %
  sk: string;              // Dynamo sort‑key "TS#<epoch>"
  price?: number;          // optional → undefined for pure MARKET orders
}

/* Discriminated union */
export interface MarketOrder extends BaseOrder {
  orderType: "MARKET";
}

export interface LimitOrder extends BaseOrder {
  orderType: "LIMIT";
  price: number;
}

export interface PerpOrder extends BaseOrder {
  orderType: "PERP";
  price: number;
}

export interface FutureOrder extends BaseOrder {
  orderType: "FUTURE";
  price: number;
  expiryTs: number;
}

export interface OptionOrder extends BaseOrder {
  orderType: "OPTION";
  price: number;           // premium
  strike: number;
  expiryTs: number;
  optionType: "CALL" | "PUT";
}

export type Order =
  | MarketOrder
  | LimitOrder
  | PerpOrder
  | FutureOrder
  | OptionOrder;

/* ── Trades ──────────────────────────────────────────────────────────── */
export interface Trade {
  tradeId: UUID;
  takerOrderId: UUID;
  makerOrderId: UUID;
  market: string;
  price: number;
  qty: number;
  timestamp: number;
  side: OrderSide;         // from taker perspective
  takerFee: number;
  makerFee: number;
}

/* ── Positions ───────────────────────────────────────────────────────── */
export interface Position {
  traderId: UUID;
  market: string;
  size: number;            // signed qty
  avgEntryPrice: number;
  realizedPnl: number;
  unrealizedPnl: number;
  updatedAt: number;
}

/* ── Markets metadata ───────────────────────────────────────────────── */
export interface MarketMeta {
  symbol: string;           // BTC‑PERP
  type:   "SPOT" | "PERP" | "FUTURE" | "OPTION";
  status: "ACTIVE" | "PAUSED" | "DELISTED";
  tickSize: number;
  lotSize:  number;
  fundingIntervalSec?: number;
  expiryTs?: number;
  synth: string;            // **NEW** – ERC‑20 address for this market
  createdAt: number;
}

/* ── Oracle price snapshots ─────────────────────────────────────────── */
export interface PriceSnapshot {
  asset: string;            // BTC
  timestamp: number;
  price: number;
}

/* ── Metrics rows ───────────────────────────────────────────────────── */
export interface StatsIntradayRow {
  market: string;
  bucketTs: number;         // minute ISO ts
  volume: number;
  openInterest: number;
  fees: number;
  depth1bp: number;
  depth5bp: number;
  fundingRate?: number;
  impliedVol?: number;
  trades?: number;
}

export interface StatsDailyRow extends Omit<StatsIntradayRow, "bucketTs"> {
  day: string;              // YYYY‑MM‑DD
}

export interface StatsLifetimeRow {
  key: "GLOBAL";
  volume: number;
  fees: number;
  traders: number;
  markets: number;
}

/* ── WebSocket connection registry ─────────────────────────────────── */
export interface WSConnection {
  connectionId: string;
  traderId?: UUID;
  market?: string;
  expiresAt: number;
}

/* ── Queue payloads ──────────────────────────────────────────────── */
export interface OrderQueueMessage {
  /** UUID of the order being processed */
  orderId: UUID;
  /** Market symbol, eg. "BTC-PERP" */
  market: string;
  /** Discriminated order payload (copied from Orders table item) */
  order: Order & { pk: string; sk: string }; // Include pk/sk as they are needed by matcher sometimes
  /** NEW: Trading mode for this order */
  mode: TradingMode;
}

export type MatcherBatch = OrderQueueMessage[];

export type TradingMode = "REAL" | "PAPER";

// Define Balance type if needed
export interface Balance {
    pk: string; // TRADER#<id>#<mode>
    sk: string; // ASSET#<asset>
    balance: number;
    pending: number;
}

// --- NEW Interfaces for TraderRecord and PaperPoints ---

/** Structure for storing paper trading points */
export interface PaperPoints {
  totalPoints: number; // Current accumulated points for the epoch
  epoch: number;       // Current reward epoch (e.g., increments monthly)
}

/** Represents a record in the Traders DynamoDB table */
export interface TraderRecord {
  /** Primary Key: Composite key including trader ID and mode. Example: TRADER#uuid123abc#PAPER */
  pk: string;
  /** Sort Key: Often a static value for metadata. Example: META */
  sk: string;
  /** The unique identifier for the trader */
  traderId: UUID;
  /** The trading mode (REAL or PAPER) associated with this specific record/PK */
  mode: TradingMode;
  /** Optional: Trader's email address */
  email?: string;
  /** Optional: Trader's wallet address */
  walletAddress?: string;
  /** Optional: Paper trading points, only present for PAPER mode traders */
  paperPoints?: PaperPoints;
  /** Optional: API Keys associated with the trader */
  apiKeys?: ApiKeyInfo[];
  /** Optional: Credits balance */
  credits?: number;
   /** Optional: Historical rewards entries */
  rewards?: RewardEntry[];
  /** Optional: Total accumulated rewards */
  totalRewards?: number;
  /** Optional: User Access Key */
  userAk?: string;
   /** Optional: Status like ACTIVE/SUSPENDED if stored here */
  status?: "ACTIVE" | "SUSPENDED";
  // Add any other relevant trader attributes here (e.g., createdAt, lastLoginAt)
  createdAt?: number;
}

