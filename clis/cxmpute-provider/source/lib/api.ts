// source/lib/api.ts
import type { DeviceDiagnostics, DashboardStats } from './interfaces.js';

// Ensure your .env file has this or define it directly
const CXMPUTE_API_BASE_URL = process.env['CXMPUTE_API_URL'] || 'https://cxmpute.cloud/api';
console.log("CXMPUTE_API_BASE_URL", CXMPUTE_API_BASE_URL);

interface RegisterDevicePayload {
    deviceDiagnostics: DeviceDiagnostics;
    providerId: string;
    // provisionId is generated by App.tsx or backend
    providerAk: string;
    location: {
        country: string;
        state: string;
        city: string;
    };
    username: string; // Added username
    deviceName: string; // Added deviceName
    // installedSoftware: { ollama: boolean }; // Example if needed
}

interface RegisterDeviceResponse {
    success: boolean;
    message?: string;
    deviceId?: string; // Expect the backend to return the generated deviceId
    // any other relevant fields from the backend
}

// Orchestrator API interfaces (from your Tauri app's App.tsx)
interface RerunDiagnosticsPayload {
    deviceDiagnostics: DeviceDiagnostics;
    // location if it can be updated
}
interface OrchestratorStartPayload {
    provisionId: string; // This is our deviceId
    providerAk: string;
    availableResources: DeviceDiagnostics;
    // llmModels?: string[]; // These were part of Tauri, might not be needed from CLI if orchestrator decides
    // embeddingsModels?: string[];
}
interface OrchestratorStartResponse {
    services: string[]; // Services to run on the sidecar/server
    // Potentially other parameters the orchestrator wants to send
}
interface OrchestratorCallbackPayload {
    provisionId: string;
    providerAk: string;
    startedServices: string[];
    providedUrl: string;
    llmModels?: string[]; // Models actually pulled/running
    embeddingsModels?: string[];
}
interface OrchestratorEndPayload {
    provisionId: string;
    providerAk: string;
}


export async function registerDevice(payload: RegisterDevicePayload): Promise<RegisterDeviceResponse> {
    console.log("API Payload - registerDevice:", payload);
    try {
        const response = await fetch(`${CXMPUTE_API_BASE_URL}/v1/providers/new`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        });
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: response.statusText }));
            throw new Error(errorData.message || `Registration failed with status: ${response.status}`);
        }
        console.log("API Response - registerDevice:", await response.json());
        return await response.json() as RegisterDeviceResponse;
    } catch (error: any) {
        console.error("API Error - registerDevice:", error);
        return { success: false, message: error.message || "Network error during registration." };
    }
}

export async function fetchEarnings(providerId: string): Promise<DashboardStats> {
    try {
        const response = await fetch(`${CXMPUTE_API_BASE_URL}/providers/${providerId}/earnings`, {
            method: 'GET', // Assuming GET, adjust if POST with AK in body/header
            headers: {
                'Content-Type': 'application/json',
                // 'Authorization': `Bearer ${providerAk}` // If API key is passed as a bearer token
                // Or if it's a custom header:
                // 'X-Provider-AK': providerAk
            },
        });
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: response.statusText }));
            throw new Error(errorData.message || `Failed to fetch earnings: ${response.status}`);
        }
        const data = await response.json() as { total: number; earnings: { day: string; amount: number }[] };

        // Transform to DashboardStats
        const today = new Date().toISOString().split('T')[0];
        const todaysEarningEntry = data.earnings.find(e => e.day === today);

        return {
            earningsTotal: data.total,
            earningsToday: todaysEarningEntry ? todaysEarningEntry.amount : 0,
            referralsCount: 0, // Placeholder, API should provide this if needed
        };
    } catch (error: any) {
        console.error("API Error - fetchEarnings:", error);
        // Return a default or error-indicating structure
        return { earningsToday: 0, earningsTotal: 0, referralsCount: 0 };
    }
}

// --- Orchestrator API Calls ---

export async function notifyOrchestratorRerun(providerId: string, deviceId: string, payload: RerunDiagnosticsPayload): Promise<void> {
    // This API endpoint might not exist or might be different.
    // This is based on the `/api/providers/${providerID}/${deviceID}/rerun` from Tauri.
    // Adjust URL and method as per your actual orchestrator API.
    // For now, this is a placeholder.
    console.log("API: notifyOrchestratorRerun (placeholder)", providerId, deviceId, payload);
    await new Promise(resolve => setTimeout(resolve, 300)); // Simulate call
    // const response = await fetch(`${CXMPUTE_API_BASE_URL}/providers/${providerId}/${deviceId}/rerun`, {
    //     method: 'POST',
    //     headers: { 'Content-Type': 'application/json' },
    //     body: JSON.stringify(payload),
    // });
    // if (!response.ok) throw new Error("Failed to notify orchestrator of rerun");
}


export async function requestServicesFromOrchestrator(payload: OrchestratorStartPayload): Promise<OrchestratorStartResponse> {
    console.log("API: requestServicesFromOrchestrator", payload);
    const response = await fetch(`${CXMPUTE_API_BASE_URL}/v1/providers/start`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
    });
    if (!response.ok) {
        const errText = await response.text();
        throw new Error(`Orchestrator start request failed: ${errText || response.statusText}`);
    }

    const res = await response.json();

    console.log("API: requestServicesFromOrchestrator", res);
    
    return res as OrchestratorStartResponse;
}

export async function sendStartCallbackToOrchestrator(payload: OrchestratorCallbackPayload): Promise<void> {
    console.log("API: sendStartCallbackToOrchestrator", payload);
    const response = await fetch(`${CXMPUTE_API_BASE_URL}/v1/providers/start/callback`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
    });
    if (!response.ok) {
        const errText = await response.text();
        throw new Error(`Orchestrator callback failed: ${errText || response.statusText}`);
    }

    console.log("API: sendStartCallbackToOrchestrator", await response.json());
}

export async function notifyOrchestratorEnd(payload: OrchestratorEndPayload): Promise<void> {
    console.log("API: notifyOrchestratorEnd", payload);
    const response = await fetch(`${CXMPUTE_API_BASE_URL}/v1/providers/end`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
    });
    if (!response.ok) {
        const errText = await response.text();
        throw new Error(`Orchestrator end notification failed: ${errText || response.statusText}`);
    }
    console.log("API: notifyOrchestratorEnd", await response.json());
}