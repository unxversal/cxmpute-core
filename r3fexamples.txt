
// https://twitter.com/lusionltd/status/1701534187545636964
// https://lusion.co

import * as THREE from 'three'
import { useRef, useReducer, useMemo } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { useGLTF, MeshTransmissionMaterial, Environment, Lightformer } from '@react-three/drei'
import { CuboidCollider, BallCollider, Physics, RigidBody } from '@react-three/rapier'
import { EffectComposer, N8AO } from '@react-three/postprocessing'
import { easing } from 'maath'

const accents = ['#4060ff', '#20ffa0', '#ff4060', '#ffcc00']
const shuffle = (accent = 0) => [
  { color: '#444', roughness: 0.1 },
  { color: '#444', roughness: 0.75 },
  { color: '#444', roughness: 0.75 },
  { color: 'white', roughness: 0.1 },
  { color: 'white', roughness: 0.75 },
  { color: 'white', roughness: 0.1 },
  { color: accents[accent], roughness: 0.1, accent: true },
  { color: accents[accent], roughness: 0.75, accent: true },
  { color: accents[accent], roughness: 0.1, accent: true }
]

export const App = () => (
  <div className="container">
    <div className="nav">
      <h1 className="label" />
      <div />
      <span className="caption" />
      <div />
      <a href="https://lusion.co/">
        <div className="button">VISIT LUSION</div>
      </a>
      <div className="button gray">///</div>
    </div>
    <Scene style={{ borderRadius: 20 }} />
  </div>
)

function Scene(props) {
  const [accent, click] = useReducer((state) => ++state % accents.length, 0)
  const connectors = useMemo(() => shuffle(accent), [accent])
  return (
    <Canvas onClick={click} shadows dpr={[1, 1.5]} gl={{ antialias: false }} camera={{ position: [0, 0, 15], fov: 17.5, near: 1, far: 20 }} {...props}>
      <color attach="background" args={['#141622']} />
      <ambientLight intensity={0.4} />
      <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} intensity={1} castShadow />
      <Physics /*debug*/ gravity={[0, 0, 0]}>
        <Pointer />
        {connectors.map((props, i) => <Connector key={i} {...props} />) /* prettier-ignore */}
        <Connector position={[10, 10, 5]}>
          <Model>
            <MeshTransmissionMaterial clearcoat={1} thickness={0.1} anisotropicBlur={0.1} chromaticAberration={0.1} samples={8} resolution={512} />
          </Model>
        </Connector>
      </Physics>
      <EffectComposer disableNormalPass multisampling={8}>
        <N8AO distanceFalloff={1} aoRadius={1} intensity={4} />
      </EffectComposer>
      <Environment resolution={256}>
        <group rotation={[-Math.PI / 3, 0, 1]}>
          <Lightformer form="circle" intensity={4} rotation-x={Math.PI / 2} position={[0, 5, -9]} scale={2} />
          <Lightformer form="circle" intensity={2} rotation-y={Math.PI / 2} position={[-5, 1, -1]} scale={2} />
          <Lightformer form="circle" intensity={2} rotation-y={Math.PI / 2} position={[-5, -1, -1]} scale={2} />
          <Lightformer form="circle" intensity={2} rotation-y={-Math.PI / 2} position={[10, 1, 0]} scale={8} />
        </group>
      </Environment>
    </Canvas>
  )
}

function Connector({ position, children, vec = new THREE.Vector3(), scale, r = THREE.MathUtils.randFloatSpread, accent, ...props }) {
  const api = useRef()
  const pos = useMemo(() => position || [r(10), r(10), r(10)], [])
  useFrame((state, delta) => {
    delta = Math.min(0.1, delta)
    api.current?.applyImpulse(vec.copy(api.current.translation()).negate().multiplyScalar(0.2))
  })
  return (
    <RigidBody linearDamping={4} angularDamping={1} friction={0.1} position={pos} ref={api} colliders={false}>
      <CuboidCollider args={[0.38, 1.27, 0.38]} />
      <CuboidCollider args={[1.27, 0.38, 0.38]} />
      <CuboidCollider args={[0.38, 0.38, 1.27]} />
      {children ? children : <Model {...props} />}
      {accent && <pointLight intensity={4} distance={2.5} color={props.color} />}
    </RigidBody>
  )
}

function Pointer({ vec = new THREE.Vector3() }) {
  const ref = useRef()
  useFrame(({ mouse, viewport }) => {
    ref.current?.setNextKinematicTranslation(vec.set((mouse.x * viewport.width) / 2, (mouse.y * viewport.height) / 2, 0))
  })
  return (
    <RigidBody position={[0, 0, 0]} type="kinematicPosition" colliders={false} ref={ref}>
      <BallCollider args={[1]} />
    </RigidBody>
  )
}

function Model({ children, color = 'white', roughness = 0, ...props }) {
  const ref = useRef()
  const { nodes, materials } = useGLTF('/c-transformed.glb')
  useFrame((state, delta) => {
    easing.dampC(ref.current.material.color, color, 0.2, delta)
  })
  return (
    <mesh ref={ref} castShadow receiveShadow scale={10} geometry={nodes.connector.geometry}>
      <meshStandardMaterial metalness={0.2} roughness={roughness} map={materials.base.map} />
      {children}
    </mesh>
  )
}


@import url('https://rsms.me/inter/inter.css');

html {
  font-family: 'Inter', sans-serif;
}

* {
  box-sizing: border-box;
}

html,
body,
#root {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  background: #f0f0f0;
}

a {
  all: unset;
  cursor: pointer;
}

.container {
  display: grid;
  padding: 3em 5em 3em 5em;
  grid-template-rows: auto 1fr;
  gap: 3em;
  position: absolute;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.nav {
  display: grid;
  grid-template-columns: auto 0.25fr 1fr 0.25fr auto auto;
  gap: 1em;
}

.label {
  margin: 0;
  font-size: 2.5em;
  font-weight: 400;
  letter-spacing: 0;
}

.label::after {
  content: 'POIMANDRES';
}

.caption {
  font-size: 2.5em;
  display: inline-block;
  max-width: 500px;
}

.caption::after {
  content: 'Open source developer collective for the creative space';
}

.button {
  display: flex;
  align-items: center;
  justify-content: center;
  background: #141622;
  color: white;
  height: 52px;
  border-radius: 30px;
  padding: 0em 2em;
  white-space: pre;
}

.button.gray {
  background: #ccc;
  color: #141622;
}

@media (max-width: 1200px) {
  .container {
    padding: 2em 4em 2em 4em;
    gap: 2em;
  }
  .button {
    height: 48px;
    border-radius: 30px;
    padding: 0em 2em;
  }
  .label {
    font-size: 2em;
  }
  .caption {
    font-size: 1.5em;
  }
}

@media (max-width: 800px) {
  .caption::after {
    content: 'OSS dev collective  for the creative space';
  }
  .label::after {
    content: 'PMNDRS';
  }
  .container {
    padding: 2em 3em 2em 3em;
    gap: 2em;
  }
  .button {
    height: 36px;
    border-radius: 30px;
    padding: 0em 1.25em;
    font-size: 0.7em;
  }
  .label {
    font-size: 1em;
  }
  .caption {
    font-size: 1em;
  }
}

@media (max-width: 600px) {
  .nav {
    gap: 0.5em;
  }
  .caption::after {
    content: 'OSS dev collective';
  }
  .container {
    padding: 2em 2em 2em 2em;
    gap: 2em;
  }
}




import * as THREE from 'three'
import { useRef, useReducer, useMemo } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { Environment, Lightformer } from '@react-three/drei'
import { BallCollider, Physics, RigidBody } from '@react-three/rapier'
import { easing } from 'maath'
import { Effects } from './Effects'

const accents = ['#ff4060', '#ffcc00', '#20ffa0', '#4060ff']
const shuffle = (accent = 0) => [
  { color: '#444', roughness: 0.1, metalness: 0.5 },
  { color: '#444', roughness: 0.1, metalness: 0.5 },
  { color: '#444', roughness: 0.1, metalness: 0.5 },
  { color: 'white', roughness: 0.1, metalness: 0.1 },
  { color: 'white', roughness: 0.1, metalness: 0.1 },
  { color: 'white', roughness: 0.1, metalness: 0.1 },
  { color: accents[accent], roughness: 0.1, accent: true },
  { color: accents[accent], roughness: 0.1, accent: true },
  { color: accents[accent], roughness: 0.1, accent: true },
  { color: '#444', roughness: 0.1 },
  { color: '#444', roughness: 0.3 },
  { color: '#444', roughness: 0.3 },
  { color: 'white', roughness: 0.1 },
  { color: 'white', roughness: 0.2 },
  { color: 'white', roughness: 0.1 },
  { color: accents[accent], roughness: 0.1, accent: true, transparent: true, opacity: 0.5 },
  { color: accents[accent], roughness: 0.3, accent: true },
  { color: accents[accent], roughness: 0.1, accent: true }
]

export default function App(props) {
  const [accent, click] = useReducer((state) => ++state % accents.length, 0)
  const connectors = useMemo(() => shuffle(accent), [accent])
  return (
    <Canvas flat shadows onClick={click} dpr={[1, 1.5]} gl={{ antialias: false }} camera={{ position: [0, 0, 30], fov: 17.5, near: 10, far: 40 }} {...props}>
      <color attach="background" args={['#141622']} />
      <Physics /*debug*/ timeStep="vary" gravity={[0, 0, 0]}>
        <Pointer />
        {connectors.map((props, i) => (
          <Sphere key={i} {...props} />
        ))}
      </Physics>
      <Environment resolution={256}>
        <group rotation={[-Math.PI / 3, 0, 1]}>
          <Lightformer form="circle" intensity={100} rotation-x={Math.PI / 2} position={[0, 5, -9]} scale={2} />
          <Lightformer form="circle" intensity={2} rotation-y={Math.PI / 2} position={[-5, 1, -1]} scale={2} />
          <Lightformer form="circle" intensity={2} rotation-y={Math.PI / 2} position={[-5, -1, -1]} scale={2} />
          <Lightformer form="circle" intensity={2} rotation-y={-Math.PI / 2} position={[10, 1, 0]} scale={8} />
          <Lightformer form="ring" color="#4060ff" intensity={80} onUpdate={(self) => self.lookAt(0, 0, 0)} position={[10, 10, 0]} scale={10} />
        </group>
      </Environment>
      <Effects />
    </Canvas>
  )
}

function Sphere({ position, children, vec = new THREE.Vector3(), scale, r = THREE.MathUtils.randFloatSpread, accent, color = 'white', ...props }) {
  const api = useRef()
  const ref = useRef()
  const pos = useMemo(() => position || [r(10), r(10), r(10)], [])
  useFrame((state, delta) => {
    delta = Math.min(0.1, delta)
    api.current?.applyImpulse(vec.copy(api.current.translation()).negate().multiplyScalar(0.2))
    easing.dampC(ref.current.material.color, color, 0.2, delta)
  })
  return (
    <RigidBody linearDamping={4} angularDamping={1} friction={0.1} position={pos} ref={api} colliders={false}>
      <BallCollider args={[1]} />
      <mesh ref={ref} castShadow receiveShadow>
        <sphereGeometry args={[1, 64, 64]} />
        <meshStandardMaterial {...props} />
        {children}
      </mesh>
    </RigidBody>
  )
}

function Pointer({ vec = new THREE.Vector3() }) {
  const ref = useRef()
  useFrame(({ mouse, viewport }) => ref.current?.setNextKinematicTranslation(vec.set((mouse.x * viewport.width) / 2, (mouse.y * viewport.height) / 2, 0)))
  return (
    <RigidBody position={[0, 0, 0]} type="kinematicPosition" colliders={false} ref={ref}>
      <BallCollider args={[1]} />
    </RigidBody>
  )
}

import { useThree, useFrame } from '@react-three/fiber'
import { EffectComposer, RenderPass, EffectPass, BloomEffect, ToneMappingEffect, FXAAEffect } from 'postprocessing'
import { useEffect, useState } from 'react'
import { SSGIEffect, VelocityDepthNormalPass } from './realism-effects/v2'

export function Effects() {
  const gl = useThree((state) => state.gl)
  const scene = useThree((state) => state.scene)
  const camera = useThree((state) => state.camera)
  const size = useThree((state) => state.size)
  const [composer] = useState(() => new EffectComposer(gl, { multisampling: 0 }))

  useEffect(() => composer.setSize(size.width, size.height), [composer, size])
  useEffect(() => {
    const config = {
      importanceSampling: true,
      steps: 20,
      refineSteps: 4,
      spp: 1,
      resolutionScale: 1,
      missedRays: false,
      distance: 5.980000000000011,
      thickness: 2.829999999999997,
      denoiseIterations: 1,
      denoiseKernel: 3,
      denoiseDiffuse: 25,
      denoiseSpecular: 25.54,
      radius: 11,
      phi: 0.5760000000000001,
      lumaPhi: 20.651999999999997,
      depthPhi: 23.37,
      normalPhi: 26.087,
      roughnessPhi: 18.477999999999998,
      specularPhi: 7.099999999999999,
      envBlur: 0.8
    }

    const renderPass = new RenderPass(scene, camera)
    const velocityDepthNormalPass = new VelocityDepthNormalPass(scene, camera)
    composer.addPass(renderPass)
    composer.addPass(velocityDepthNormalPass)
    composer.addPass(new EffectPass(camera, new SSGIEffect(composer, scene, camera, { ...config, velocityDepthNormalPass })))
    composer.addPass(new EffectPass(camera, new BloomEffect({ mipmapBlur: true, luminanceThreshold: 0.1, intensity: 0.9, levels: 7 })))
    composer.addPass(new EffectPass(camera, new FXAAEffect(), new ToneMappingEffect()))

    return () => {
      composer.removeAllPasses()
    }
  }, [composer, camera, scene])

  useFrame((state, delta) => {
    gl.autoClear = true // ?
    composer.render(delta)
  }, 1)
}


import { Pass, Effect, RenderPass, Selection, NormalPass } from 'postprocessing';
import { ShaderChunk, ShaderLib, UniformsUtils, ShaderMaterial, Uniform, Vector2, Matrix4, Vector3, NoBlending, GLSL3, Clock, Quaternion, WebGLMultipleRenderTargets, NearestFilter, FramebufferTexture, LinearFilter, WebGLRenderTarget, FloatType, DataTexture, RGBAFormat, ClampToEdgeWrapping, LinearMipMapLinearFilter, EquirectangularReflectionMapping, TextureLoader, RepeatWrapping, NoColorSpace, MeshPhysicalMaterial, Color, DepthTexture, RedFormat, Matrix3, HalfFloatType, SRGBColorSpace } from 'three';

// from: https://news.ycombinator.com/item?id=17876741

const g = 1.32471795724474602596090885447809; // Plastic number

const a1 = 1.0 / g;
const a2 = 1.0 / (g * g);
const base = 1.1127756842787055; // harmoniousNumber(7), yields better coverage compared to using 0.5

const generateR2 = count => {
  const points = [];

  for (let n = 0; n < count; n++) {
    points.push([(base + a1 * n) % 1, (base + a2 * n) % 1]);
  }

  return points;
};

const r2Sequence = generateR2(256).map(([a, b]) => [a - 0.5, b - 0.5]);
function jitter(width, height, camera, frame, jitterScale = 1) {
  const [x, y] = r2Sequence[frame % r2Sequence.length];

  if (camera.setViewOffset) {
    camera.setViewOffset(width, height, x * jitterScale, y * jitterScale, width, height);
  }
}

var vertexShader = "#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"; // eslint-disable-line

var fragmentShader$7 = "#define GLSLIFY 1\nvarying vec2 vUv;uniform highp sampler2D inputTexture;uniform highp sampler2D velocityTexture;uniform highp sampler2D depthTexture;uniform highp sampler2D lastVelocityTexture;uniform float maxBlend;uniform float neighborhoodClampIntensity;uniform bool fullAccumulate;uniform vec2 invTexSize;uniform float cameraNear;uniform float cameraFar;uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;uniform vec3 cameraPos;uniform vec3 prevCameraPos;uniform mat4 prevViewMatrix;uniform mat4 prevCameraMatrixWorld;uniform mat4 prevProjectionMatrix;uniform mat4 prevProjectionMatrixInverse;uniform float keepData;\n#define EPSILON 0.00001\n#define DIFFUSE_SPECULAR 0\n#define DIFFUSE 1\n#define SPECULAR 2\n#include <gbuffer_packing>\n#include <packing>\n#include <reproject>\nvec3 reprojectedUvDiffuse=vec3(-1.0),reprojectedUvSpecular=vec3(-1.0);void accumulate(inout vec4 outputColor,inout vec4 inp,inout vec4 acc,inout float roughness,inout float moveFactor,bool doReprojectSpecular){vec3 reprojectedUvConfidence=doReprojectSpecular ? reprojectedUvSpecular : reprojectedUvDiffuse;vec2 reprojectedUv=reprojectedUvConfidence.xy;float confidence=reprojectedUvConfidence.z;confidence=pow(confidence,confidencePower);float accumBlend=1.-1./(acc.a+1.0);accumBlend=mix(0.,accumBlend,confidence);float maxValue=(fullAccumulate ? 1. : maxBlend)*keepData;\n#if inputType != DIFFUSE\nconst float roughnessMaximum=0.1;if(doReprojectSpecular&&roughness>=0.0&&roughness<roughnessMaximum){float maxRoughnessValue=mix(0.,maxValue,roughness/roughnessMaximum);maxValue=mix(maxValue,maxRoughnessValue,min(100.*moveFactor,1.));}\n#endif\nfloat temporalReprojectMix=min(accumBlend,maxValue);acc.a=1./(1.-temporalReprojectMix)-1.;acc.a=min(65536.,acc.a);outputColor.rgb=mix(inp.rgb,acc.rgb,temporalReprojectMix);outputColor.a=acc.a;undoColorTransform(outputColor.rgb);}void reproject(inout vec4 inp,inout vec4 acc,sampler2D accumulatedTexture,inout bool wasSampled,bool doNeighborhoodClamp,bool doReprojectSpecular){vec3 uvc=doReprojectSpecular ? reprojectedUvSpecular : reprojectedUvDiffuse;vec2 uv=uvc.xy;acc=sampleReprojectedTexture(accumulatedTexture,uv);transformColor(acc.rgb);if(!wasSampled){inp.rgb=acc.rgb;return;}acc.a++;vec3 clampedColor=acc.rgb;int clampRadius=doReprojectSpecular&&roughness<0.25 ? 1 : 2;clampNeighborhood(inputTexture,clampedColor,inp.rgb,clampRadius,doReprojectSpecular);float r=doReprojectSpecular ? roughness : 1.0;float clampAggressiveness=min(1.,uvc.z*r);float clampIntensity=mix(0.,min(1.,moveFactor*50.+neighborhoodClampIntensity),clampAggressiveness);vec3 newColor=mix(acc.rgb,clampedColor,clampIntensity);float colorDiff=min(length(newColor-acc.rgb),1.);acc.a*=1.-colorDiff;acc.rgb=newColor;}void preprocessInput(inout highp vec4 texel,inout bool sampledThisFrame){sampledThisFrame=texel.r>=0.;texel.rgb=max(texel.rgb,vec3(0.));transformColor(texel.rgb);}void getTexels(inout highp vec4 inputTexel[textureCount],inout bool sampledThisFrame[textureCount]){\n#if inputType == DIFFUSE_SPECULAR\nhighp vec4 tex=textureLod(inputTexture,vUv,0.);unpackTwoVec4(tex,inputTexel[0],inputTexel[1]);preprocessInput(inputTexel[0],sampledThisFrame[0]);preprocessInput(inputTexel[1],sampledThisFrame[1]);\n#else\ninputTexel[0]=textureLod(inputTexture,vUv,0.0);preprocessInput(inputTexel[0],sampledThisFrame[0]);\n#endif\n}void computeGVariables(vec2 dilatedUv,float depth){worldPos=screenSpaceToWorldSpace(dilatedUv,depth,cameraMatrixWorld,projectionMatrixInverse);vec3 viewPos=(viewMatrix*vec4(worldPos,1.0)).xyz;viewDir=normalize(viewPos);vec3 viewNormal=(vec4(worldNormal,0.0)*viewMatrix).xyz;viewAngle=dot(-viewDir,viewNormal);}void computeReprojectedUv(float depth,vec3 worldPos,vec3 worldNormal){reprojectedUvDiffuse=getReprojectedUV(false,depth,worldPos,worldNormal);\n#if inputType == DIFFUSE_SPECULAR || inputType == SPECULAR\nreprojectedUvSpecular=getReprojectedUV(true,depth,worldPos,worldNormal);if(reprojectedUvSpecular.x==-1.0){reprojectedUvSpecular=reprojectedUvDiffuse;}\n#endif\n}void getRoughnessRayLength(inout highp vec4 inputTexel[textureCount]){\n#if inputType == DIFFUSE_SPECULAR\nrayLength=inputTexel[1].a;roughness=clamp(inputTexel[0].a,0.,1.);\n#elif inputType == SPECULAR\nvec2 data=unpackHalf2x16(floatBitsToUint(inputTexel[0].a));rayLength=data.r;roughness=clamp(data.g,0.,1.);\n#endif\n}void main(){vec2 dilatedUv=vUv;getVelocityNormalDepth(dilatedUv,velocity,worldNormal,depth);highp vec4 inputTexel[textureCount],accumulatedTexel[textureCount];bool textureSampledThisFrame[textureCount];getTexels(inputTexel,textureSampledThisFrame);\n#if inputType != DIFFUSE\nif(depth==1.0&&fwidth(depth)==0.0){discard;return;}\n#endif\ncurvature=getCurvature(worldNormal);computeGVariables(dilatedUv,depth);getRoughnessRayLength(inputTexel);computeReprojectedUv(depth,worldPos,worldNormal);moveFactor=min(dot(velocity,velocity)*10000.,1.);\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){reproject(inputTexel[i],accumulatedTexel[i],accumulatedTexture[i],textureSampledThisFrame[i],neighborhoodClamp[i],reprojectSpecular[i]);accumulate(gOutput[i],inputTexel[i],accumulatedTexel[i],roughness,moveFactor,reprojectSpecular[i]);}\n#pragma unroll_loop_end\n}"; // eslint-disable-line

var reproject = "#define GLSLIFY 1\nvec2 dilatedUv,velocity;vec3 worldNormal,worldPos,viewDir;float depth,curvature,viewAngle,rayLength,angleMix;float roughness=1.;float moveFactor=0.;\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nfloat getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth,mat4 curMatrixWorld,const mat4 projMatrixInverse){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=projMatrixInverse*ndc;vec4 view=curMatrixWorld*(clip/clip.w);return view.xyz;}vec2 viewSpaceToScreenSpace(const vec3 position,const mat4 projMatrix){vec4 projectedCoord=projMatrix*vec4(position,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;return projectedCoord.xy;}\n#ifdef logTransform\nvoid transformColor(inout vec3 color){color=log(color+1.);}void undoColorTransform(inout vec3 color){color=exp(color)-1.;}\n#else\n#define transformColor\n#define undoColorTransform\n#endif\nvoid getNeighborhoodAABB(const sampler2D tex,const int clampRadius,inout vec3 minNeighborColor,inout vec3 maxNeighborColor,const bool isSpecular){for(int x=-clampRadius;x<=clampRadius;x++){for(int y=-clampRadius;y<=clampRadius;y++){vec2 offset=vec2(x,y)*invTexSize;vec2 neighborUv=vUv+offset;\n#if inputType == DIFFUSE_SPECULAR\nvec4 t1,t2;vec4 packedNeighborTexel=textureLod(inputTexture,neighborUv,0.0);unpackTwoVec4(packedNeighborTexel,t1,t2);vec4 neighborTexel=isSpecular ? t2 : t1;\n#else\nvec4 neighborTexel=textureLod(inputTexture,neighborUv,0.0);\n#endif\nif(neighborTexel.r>=0.){minNeighborColor=min(neighborTexel.rgb,minNeighborColor);maxNeighborColor=max(neighborTexel.rgb,maxNeighborColor);}}}}void clampNeighborhood(const sampler2D tex,inout vec3 color,vec3 inputColor,const int clampRadius,const bool isSpecular){undoColorTransform(inputColor);vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;getNeighborhoodAABB(tex,clampRadius,minNeighborColor,maxNeighborColor,isSpecular);transformColor(minNeighborColor);transformColor(maxNeighborColor);color=clamp(color,minNeighborColor,maxNeighborColor);}void getVelocityNormalDepth(inout vec2 dilatedUv,out vec2 vel,out vec3 normal,out float depth){vec2 centerUv=dilatedUv;vec4 velocityTexel=textureLod(velocityTexture,centerUv,0.0);vel=velocityTexel.rg;normal=unpackNormal(velocityTexel.b);depth=velocityTexel.a;}\n#define PLANE_DISTANCE 20.\n#define WORLD_DISTANCE 20.\n#define NORMAL_DISTANCE 15.\nfloat planeDistanceDisocclusionCheck(const vec3 worldPos,const vec3 lastWorldPos,const vec3 worldNormal,const float distFactor){vec3 toCurrent=worldPos-lastWorldPos;float distToPlane=abs(dot(toCurrent,worldNormal));return distToPlane/PLANE_DISTANCE*distFactor;}float worldDistanceDisocclusionCheck(const vec3 worldPos,const vec3 lastWorldPos,const float distFactor){return length(worldPos-lastWorldPos)/WORLD_DISTANCE*distFactor;}float normalDisocclusionCheck(const vec3 worldNormal,const vec3 lastWorldNormal,const float distFactor){return min(1.-dot(worldNormal,lastWorldNormal),1.)/NORMAL_DISTANCE*distFactor;}float validateReprojectedUV(const vec2 reprojectedUv,const vec3 worldPos,const vec3 worldNormal,const bool isHitPoint){if(reprojectedUv.x>1.0||reprojectedUv.x<0.0||reprojectedUv.y>1.0||reprojectedUv.y<0.0)return 0.;vec2 dilatedReprojectedUv=reprojectedUv;vec2 lastVelocity=vec2(0.0);vec3 lastWorldNormal=vec3(0.0);float lastDepth=0.0;getVelocityNormalDepth(dilatedReprojectedUv,lastVelocity,lastWorldNormal,lastDepth);vec3 lastWorldPos=screenSpaceToWorldSpace(dilatedReprojectedUv,lastDepth,prevCameraMatrixWorld,prevProjectionMatrixInverse);vec3 lastViewPos=(prevViewMatrix*vec4(lastWorldPos,1.0)).xyz;vec3 lastViewDir=normalize(lastViewPos);vec3 lastViewNormal=(vec4(lastWorldNormal,0.0)*prevViewMatrix).xyz;float lastViewAngle=dot(-lastViewDir,lastViewNormal);angleMix=abs(lastViewAngle-viewAngle);float viewZ=abs(getViewZ(depth));float distFactor=1.+1./(viewZ+1.0);float disoccl=0.;disoccl+=worldDistanceDisocclusionCheck(worldPos,lastWorldPos,distFactor);disoccl+=planeDistanceDisocclusionCheck(worldPos,lastWorldPos,worldNormal,distFactor);float confidence=1.-min(disoccl,1.);confidence=max(confidence,0.);confidence=pow(confidence,confidencePower);return confidence;}vec2 reprojectHitPoint(const vec3 rayOrig,const float rayLength){if(curvature>0.05||rayLength<0.01){return vec2(-1.);}vec3 cameraRay=normalize(rayOrig-cameraPos);vec3 parallaxHitPoint=cameraPos+cameraRay*rayLength;vec4 reprojectedHitPoint=prevProjectionMatrix*prevViewMatrix*vec4(parallaxHitPoint,1.0);reprojectedHitPoint.xyz/=reprojectedHitPoint.w;reprojectedHitPoint.xy=reprojectedHitPoint.xy*0.5+0.5;vec2 diffuseUv=vUv-velocity.xy;float m=min(max(0.,roughness-0.25)/0.25,1.);return reprojectedHitPoint.xy;}vec3 getReprojectedUV(const bool doReprojectSpecular,const float depth,const vec3 worldPos,const vec3 worldNormal){if(doReprojectSpecular){vec2 reprojectedUv=reprojectHitPoint(worldPos,rayLength);float confidence=validateReprojectedUV(reprojectedUv,worldPos,worldNormal,true);return vec3(reprojectedUv,confidence);}else{vec2 reprojectedUv=vUv-velocity;float confidence=validateReprojectedUV(reprojectedUv,worldPos,worldNormal,false);return vec3(reprojectedUv,confidence);}}vec4 BiCubicCatmullRom5Tap(sampler2D tex,vec2 P){vec2 Weight[3];vec2 Sample[3];vec2 UV=P/invTexSize;vec2 tc=floor(UV-0.5)+0.5;vec2 f=UV-tc;vec2 f2=f*f;vec2 f3=f2*f;vec2 w0=f2-0.5*(f3+f);vec2 w1=1.5*f3-2.5*f2+vec2(1.);vec2 w3=0.5*(f3-f2);vec2 w2=vec2(1.)-w0-w1-w3;Weight[0]=w0;Weight[1]=w1+w2;Weight[2]=w3;Sample[0]=tc-vec2(1.);Sample[1]=tc+w2/Weight[1];Sample[2]=tc+vec2(2.);Sample[0]*=invTexSize;Sample[1]*=invTexSize;Sample[2]*=invTexSize;float sampleWeight[5];sampleWeight[0]=Weight[1].x*Weight[0].y;sampleWeight[1]=Weight[0].x*Weight[1].y;sampleWeight[2]=Weight[1].x*Weight[1].y;sampleWeight[3]=Weight[2].x*Weight[1].y;sampleWeight[4]=Weight[1].x*Weight[2].y;vec4 Ct=textureLod(tex,vec2(Sample[1].x,Sample[0].y),0.)*sampleWeight[0];vec4 Cl=textureLod(tex,vec2(Sample[0].x,Sample[1].y),0.)*sampleWeight[1];vec4 Cc=textureLod(tex,vec2(Sample[1].x,Sample[1].y),0.)*sampleWeight[2];vec4 Cr=textureLod(tex,vec2(Sample[2].x,Sample[1].y),0.)*sampleWeight[3];vec4 Cb=textureLod(tex,vec2(Sample[1].x,Sample[2].y),0.)*sampleWeight[4];float WeightMultiplier=1./(sampleWeight[0]+sampleWeight[1]+sampleWeight[2]+sampleWeight[3]+sampleWeight[4]);return max((Ct+Cl+Cc+Cr+Cb)*WeightMultiplier,vec4(0.));}vec4 sampleReprojectedTexture(const sampler2D tex,const vec2 reprojectedUv){vec4 catmull=BiCubicCatmullRom5Tap(tex,reprojectedUv);return catmull;}float getCurvature(vec3 n){float curvature=length(fwidth(n));return curvature;}"; // eslint-disable-line

var gbuffer_packing = "#define GLSLIFY 1\nuniform highp sampler2D gBufferTexture;struct Material{highp vec4 diffuse;highp vec3 normal;highp float roughness;highp float metalness;highp vec3 emissive;};\n#define ONE_SAFE 0.999999\n#define NON_ZERO_OFFSET 0.0001\nconst highp float c_precision=256.0;const highp float c_precisionp1=c_precision+1.0;highp float color2float(in highp vec3 color){color=min(color+NON_ZERO_OFFSET,vec3(ONE_SAFE));return floor(color.r*c_precision+0.5)+floor(color.b*c_precision+0.5)*c_precisionp1+floor(color.g*c_precision+0.5)*c_precisionp1*c_precisionp1;}highp vec3 float2color(in highp float value){highp vec3 color;color.r=mod(value,c_precisionp1)/c_precision;color.b=mod(floor(value/c_precisionp1),c_precisionp1)/c_precision;color.g=floor(value/(c_precisionp1*c_precisionp1))/c_precision;color-=NON_ZERO_OFFSET;color=max(color,vec3(0.0));return color;}highp vec2 OctWrap(highp vec2 v){highp vec2 w=1.0-abs(v.yx);if(v.x<0.0)w.x=-w.x;if(v.y<0.0)w.y=-w.y;return w;}highp vec2 encodeOctWrap(highp vec3 n){n/=(abs(n.x)+abs(n.y)+abs(n.z));n.xy=n.z>0.0 ? n.xy : OctWrap(n.xy);n.xy=n.xy*0.5+0.5;return n.xy;}highp vec3 decodeOctWrap(highp vec2 f){f=f*2.0-1.0;highp vec3 n=vec3(f.x,f.y,1.0-abs(f.x)-abs(f.y));highp float t=max(-n.z,0.0);n.x+=n.x>=0.0 ?-t : t;n.y+=n.y>=0.0 ?-t : t;return normalize(n);}highp float packNormal(highp vec3 normal){return uintBitsToFloat(packHalf2x16(encodeOctWrap(normal)));}highp vec3 unpackNormal(highp float packedNormal){return decodeOctWrap(unpackHalf2x16(floatBitsToUint(packedNormal)));}highp vec4 packTwoVec4(highp vec4 v1,highp vec4 v2){highp vec4 encoded=vec4(0.0);highp uint v1r=packHalf2x16(v1.rg);highp uint v1g=packHalf2x16(v1.ba);highp uint v2r=packHalf2x16(v2.rg);highp uint v2g=packHalf2x16(v2.ba);encoded.r=uintBitsToFloat(v1r);encoded.g=uintBitsToFloat(v1g);encoded.b=uintBitsToFloat(v2r);encoded.a=uintBitsToFloat(v2g);return encoded;}void unpackTwoVec4(highp vec4 encoded,out highp vec4 v1,out highp vec4 v2){highp uint r=floatBitsToUint(encoded.r);highp uint g=floatBitsToUint(encoded.g);highp uint b=floatBitsToUint(encoded.b);highp uint a=floatBitsToUint(encoded.a);v1.rg=unpackHalf2x16(r);v1.ba=unpackHalf2x16(g);v2.rg=unpackHalf2x16(b);v2.ba=unpackHalf2x16(a);}vec4 unpackTwoVec4(highp vec4 encoded,const int index){highp uint r=floatBitsToUint(index==0 ? encoded.r : encoded.b);highp uint g=floatBitsToUint(index==0 ? encoded.g : encoded.a);vec4 v;v.rg=unpackHalf2x16(r);v.ba=unpackHalf2x16(g);v-=NON_ZERO_OFFSET;v=max(v,vec4(0.0));return v;}highp float packVec2(highp vec2 value){value=min(value+NON_ZERO_OFFSET,vec2(ONE_SAFE));return uintBitsToFloat(packUnorm2x16(value));}highp vec2 unpackVec2(highp float packedValue){vec2 v=unpackUnorm2x16(floatBitsToUint(packedValue));v=max(v-NON_ZERO_OFFSET,vec2(0.0));return v;}highp vec4 encodeRGBE8(highp vec3 rgb){highp vec4 vEncoded;highp float maxComponent=max(max(rgb.r,rgb.g),rgb.b);highp float fExp=ceil(log2(maxComponent));vEncoded.rgb=rgb/exp2(fExp);vEncoded.a=(fExp+128.0)/255.0;return vEncoded;}highp vec3 decodeRGBE8(highp vec4 rgbe){highp vec3 vDecoded;highp float fExp=rgbe.a*255.0-128.0;vDecoded=rgbe.rgb*exp2(fExp);return vDecoded;}highp float vec4ToFloat(highp vec4 vec){highp uvec4 v=uvec4(vec*255.0);highp uint value=(v.a<<24u)|(v.b<<16u)|(v.g<<8u)|(v.r);return uintBitsToFloat(value);}highp vec4 floatToVec4(highp float f){highp uint value=floatBitsToUint(f);highp vec4 v;v.r=float(value&0xFFu)/255.0;v.g=float((value>>8u)&0xFFu)/255.0;v.b=float((value>>16u)&0xFFu)/255.0;v.a=float((value>>24u)&0xFFu)/255.0;return v;}highp vec4 packGBuffer(highp vec4 diffuse,highp vec3 normal,highp float roughness,highp float metalness,highp vec3 emissive){highp vec4 gBuffer;gBuffer.r=vec4ToFloat(diffuse);gBuffer.g=packNormal(normal);gBuffer.b=color2float(vec3(roughness,metalness,0.));gBuffer.a=vec4ToFloat(encodeRGBE8(emissive));return gBuffer;}Material getMaterial(highp sampler2D gBufferTexture,highp vec2 uv){highp vec4 gBuffer=textureLod(gBufferTexture,uv,0.0);highp vec4 diffuse=floatToVec4(gBuffer.r);highp vec3 normal=unpackNormal(gBuffer.g);highp vec3 roughnessMetalness=float2color(gBuffer.b);highp float roughness=roughnessMetalness.r;highp float metalness=roughnessMetalness.g;highp vec3 emissive=decodeRGBE8(floatToVec4(gBuffer.a));return Material(diffuse,normal,roughness,metalness,emissive);}Material getMaterial(highp vec2 uv){return getMaterial(gBufferTexture,uv);}highp vec3 getNormal(highp sampler2D gBufferTexture,highp vec2 uv){return unpackNormal(textureLod(gBufferTexture,uv,0.0).g);}"; // eslint-disable-line

const getMaxMipLevel = texture => {
  const {
    width,
    height
  } = texture.image;
  return Math.floor(Math.log2(Math.max(width, height))) + 1;
};
const createGlobalDisableIblRadianceUniform = () => {
  if (!ShaderChunk.envmap_physical_pars_fragment.includes("iblRadianceDisabled")) {
    ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace("vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {",
    /* glsl */
    `
		uniform bool iblRadianceDisabled;
	
		vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		 if(iblRadianceDisabled) return vec3(0.);
		`);
  }

  if ("iblRadianceDisabled" in ShaderLib.physical.uniforms) return ShaderLib.physical.uniforms["iblRadianceDisabled"];
  const globalIblRadianceDisabledUniform = {
    value: false
  };
  ShaderLib.physical.uniforms.iblRadianceDisabled = globalIblRadianceDisabledUniform;
  const {
    clone
  } = UniformsUtils;

  UniformsUtils.clone = uniforms => {
    const result = clone(uniforms);

    if ("iblRadianceDisabled" in uniforms) {
      result.iblRadianceDisabled = globalIblRadianceDisabledUniform;
    }

    return result;
  };

  return globalIblRadianceDisabledUniform;
}; // source: https://github.com/mrdoob/three.js/blob/b9bc47ab1978022ab0947a9bce1b1209769b8d91/src/renderers/webgl/WebGLProgram.js#L228
// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}

function loopReplacer(match, start, end, snippet) {
  let string = "";

  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }

  return string;
} //

/* eslint-disable camelcase */
class TemporalReprojectMaterial extends ShaderMaterial {
  constructor(textureCount = 1) {
    let finalFragmentShader = fragmentShader$7.replace("#include <reproject>", reproject).replace("#include <gbuffer_packing>", gbuffer_packing);
    let definitions = "";

    for (let i = 0; i < textureCount; i++) {
      definitions +=
      /* glsl */
      `
				uniform sampler2D accumulatedTexture${i};

				layout(location = ${i}) out vec4 gOutput${i};
			`;
    }

    finalFragmentShader = definitions + finalFragmentShader.replaceAll("textureCount", textureCount);
    finalFragmentShader = unrollLoops(finalFragmentShader);
    const matches2 = finalFragmentShader.matchAll(/accumulatedTexture\[\s*[0-9]+\s*]/g);

    for (const [key] of matches2) {
      const number = key.replace(/[^0-9]/g, "");
      finalFragmentShader = finalFragmentShader.replace(key, "accumulatedTexture" + number);
    }

    const matches3 = finalFragmentShader.matchAll(/gOutput\[\s*[0-9]+\s*]/g);

    for (const [key] of matches3) {
      const number = key.replace(/[^0-9]/g, "");
      finalFragmentShader = finalFragmentShader.replace(key, "gOutput" + number);
    }

    super({
      type: "TemporalReprojectMaterial",
      uniforms: {
        inputTexture: new Uniform(null),
        velocityTexture: new Uniform(null),
        depthTexture: new Uniform(null),
        lastVelocityTexture: new Uniform(null),
        neighborhoodClampIntensity: new Uniform(0),
        fullAccumulate: new Uniform(false),
        keepData: new Uniform(1),
        delta: new Uniform(0),
        invTexSize: new Uniform(new Vector2()),
        projectionMatrix: new Uniform(new Matrix4()),
        projectionMatrixInverse: new Uniform(new Matrix4()),
        cameraMatrixWorld: new Uniform(new Matrix4()),
        viewMatrix: new Uniform(new Matrix4()),
        prevViewMatrix: new Uniform(new Matrix4()),
        prevCameraMatrixWorld: new Uniform(new Matrix4()),
        prevProjectionMatrix: new Uniform(new Matrix4()),
        prevProjectionMatrixInverse: new Uniform(new Matrix4()),
        cameraPos: new Uniform(new Vector3()),
        prevCameraPos: new Uniform(new Vector3()),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(0),
        maxBlend: new Uniform(0)
      },
      vertexShader,
      fragmentShader: finalFragmentShader,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false,
      glslVersion: GLSL3
    });

    for (let i = 0; i < textureCount; i++) {
      this.uniforms["inputTexture" + i] = new Uniform(null);
      this.uniforms["accumulatedTexture" + i] = new Uniform(null);
    }
  }

}

const isGroundProjectedEnv = c => {
  var _c$material$fragmentS;

  return (_c$material$fragmentS = c.material.fragmentShader) == null ? void 0 : _c$material$fragmentS.includes("float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );");
};
const isChildMaterialRenderable = (c, material = c.material) => {
  return material.visible && material.depthWrite && material.depthTest && (!material.transparent || material.opacity > 0) && !isGroundProjectedEnv(c);
};
const didCameraMove = (camera, lastCameraPosition, lastCameraQuaternion) => {
  if (camera.position.distanceToSquared(lastCameraPosition) > 0.000001) {
    return true;
  }

  if (camera.quaternion.angleTo(lastCameraQuaternion) > 0.001) {
    return true;
  }

  return false;
};
const getVisibleChildren$1 = object => {
  const queue = [object];
  const objects = [];

  while (queue.length !== 0) {
    const mesh = queue.shift();
    if (mesh.material) objects.push(mesh);

    for (const c of mesh.children) {
      if (c.visible) queue.push(c);
    }
  }

  return objects;
};

const defaultTemporalReprojectPassOptions = {
  dilation: false,
  fullAccumulate: false,
  neighborhoodClamp: false,
  neighborhoodClampRadius: 1,
  neighborhoodClampIntensity: 1,
  maxBlend: 1,
  logTransform: false,
  depthDistance: 2,
  worldDistance: 4,
  reprojectSpecular: false,
  renderTarget: null,
  copyTextures: true,
  confidencePower: 1,
  inputType: "diffuse"
};
const tmpProjectionMatrix$1 = new Matrix4();
const tmpProjectionMatrixInverse$1 = new Matrix4();
const tmpVec2 = new Vector2();
class TemporalReprojectPass extends Pass {
  constructor(scene, camera, velocityDepthNormalPass, texture, textureCount, options = defaultTemporalReprojectPassOptions) {
    var _indexOf;

    super("TemporalReprojectPass");
    this.needsSwap = false;
    this.overrideAccumulatedTextures = [];
    this.clock = new Clock();
    this.r2Sequence = [];
    this.frame = 0;
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    };
    this._scene = scene;
    this._camera = camera;
    this.textureCount = textureCount;
    options = { ...defaultTemporalReprojectPassOptions,
      ...options
    };
    this.renderTarget = new WebGLMultipleRenderTargets(1, 1, textureCount, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: texture.type,
      depthBuffer: false
    });
    this.renderTarget.texture.forEach((texture, index) => texture.name = "TemporalReprojectPass.accumulatedTexture" + index);
    this.fullscreenMaterial = new TemporalReprojectMaterial(textureCount);
    this.fullscreenMaterial.defines.textureCount = textureCount;
    if (options.dilation) this.fullscreenMaterial.defines.dilation = "";
    if (options.neighborhoodClamp) this.fullscreenMaterial.defines.neighborhoodClamp = "";
    if (options.logTransform) this.fullscreenMaterial.defines.logTransform = "";
    if (camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "";
    this.fullscreenMaterial.defines.neighborhoodClampRadius = parseInt(options.neighborhoodClampRadius);
    this.fullscreenMaterial.defines.depthDistance = options.depthDistance.toPrecision(5);
    this.fullscreenMaterial.defines.worldDistance = options.worldDistance.toPrecision(5);
    this.fullscreenMaterial.uniforms.fullAccumulate.value = options.fullAccumulate;
    this.fullscreenMaterial.uniforms.neighborhoodClampIntensity.value = options.neighborhoodClampIntensity;
    this.fullscreenMaterial.uniforms.maxBlend.value = options.maxBlend;
    this.fullscreenMaterial.uniforms.projectionMatrix.value = camera.projectionMatrix.clone();
    this.fullscreenMaterial.uniforms.projectionMatrixInverse.value = camera.projectionMatrixInverse.clone();
    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = camera.matrixWorld;
    this.fullscreenMaterial.uniforms.viewMatrix.value = camera.matrixWorldInverse;
    this.fullscreenMaterial.uniforms.cameraPos.value = camera.position;
    this.fullscreenMaterial.uniforms.prevViewMatrix.value = camera.matrixWorldInverse.clone();
    this.fullscreenMaterial.uniforms.prevCameraMatrixWorld.value = camera.matrixWorld.clone();
    this.fullscreenMaterial.uniforms.prevProjectionMatrix.value = camera.projectionMatrix.clone();
    this.fullscreenMaterial.uniforms.prevProjectionMatrixInverse.value = camera.projectionMatrixInverse.clone();
    this.fullscreenMaterial.uniforms.velocityTexture.value = velocityDepthNormalPass.renderTarget.texture;
    this.fullscreenMaterial.uniforms.depthTexture.value = velocityDepthNormalPass.depthTexture;
    this.fullscreenMaterial.defines.inputType = (_indexOf = ["diffuseSpecular", "diffuse", "specular"].indexOf(options.inputType)) !== null && _indexOf !== void 0 ? _indexOf : 1;

    for (const opt of ["reprojectSpecular", "neighborhoodClamp"]) {
      let value = options[opt];
      if (typeof value !== "array") value = Array(textureCount).fill(value);
      this.fullscreenMaterial.defines[opt] =
      /* glsl */
      `bool[](${value.join(", ")})`;
    }

    this.fullscreenMaterial.defines.confidencePower = options.confidencePower.toPrecision(5);
    this.options = options;
    this.velocityDepthNormalPass = velocityDepthNormalPass;
    this.fullscreenMaterial.uniforms.inputTexture.value = texture;
  }

  dispose() {
    super.dispose();
    this.renderTarget.dispose();
    this.fullscreenMaterial.dispose();
  }

  setSize(width, height) {
    var _this$framebufferText;

    this.renderTarget.setSize(width, height);
    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height);
    (_this$framebufferText = this.framebufferTexture) == null ? void 0 : _this$framebufferText.dispose();
    const inputTexture = this.fullscreenMaterial.uniforms.inputTexture.value;
    this.framebufferTexture = new FramebufferTexture(width, height, inputTexture.format);
    this.framebufferTexture.type = inputTexture.type;
    this.framebufferTexture.minFilter = LinearFilter;
    this.framebufferTexture.magFilter = LinearFilter;
    this.framebufferTexture.needsUpdate = true;

    for (let i = 0; i < this.textureCount; i++) {
      var _this$overrideAccumul;

      const accumulatedTexture = (_this$overrideAccumul = this.overrideAccumulatedTextures[i]) !== null && _this$overrideAccumul !== void 0 ? _this$overrideAccumul : this.framebufferTexture;
      this.fullscreenMaterial.uniforms["accumulatedTexture" + i].value = accumulatedTexture;
    }
  }

  get texture() {
    return this.renderTarget.texture[0];
  }

  reset() {
    this.fullscreenMaterial.uniforms.keepData.value = 0;
  }

  render(renderer) {
    this.frame = (this.frame + 1) % 4096;
    const delta = Math.min(1 / 10, this.clock.getDelta());
    this.fullscreenMaterial.uniforms.delta.value = delta;
    tmpProjectionMatrix$1.copy(this._camera.projectionMatrix);
    tmpProjectionMatrixInverse$1.copy(this._camera.projectionMatrixInverse);
    if (this._camera.view) this._camera.view.enabled = false;

    this._camera.updateProjectionMatrix();

    this.fullscreenMaterial.uniforms.projectionMatrix.value.copy(this._camera.projectionMatrix);
    this.fullscreenMaterial.uniforms.projectionMatrixInverse.value.copy(this._camera.projectionMatrixInverse);
    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.velocityDepthNormalPass.lastVelocityTexture;
    this.fullscreenMaterial.uniforms.fullAccumulate.value = this.options.fullAccumulate && !didCameraMove(this._camera, this.lastCameraTransform.position, this.lastCameraTransform.quaternion);
    this.lastCameraTransform.position.copy(this._camera.position);
    this.lastCameraTransform.quaternion.copy(this._camera.quaternion);
    if (this._camera.view) this._camera.view.enabled = true;

    this._camera.projectionMatrix.copy(tmpProjectionMatrix$1);

    this._camera.projectionMatrixInverse.copy(tmpProjectionMatrixInverse$1);

    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
    this.fullscreenMaterial.uniforms.keepData.value = 1;

    if (this.overrideAccumulatedTextures.length === 0) {
      this.framebufferTexture.needsUpdate = true;
      renderer.copyFramebufferToTexture(tmpVec2, this.framebufferTexture);
    } // save last transformations


    this.fullscreenMaterial.uniforms.prevCameraMatrixWorld.value.copy(this._camera.matrixWorld);
    this.fullscreenMaterial.uniforms.prevViewMatrix.value.copy(this._camera.matrixWorldInverse);
    this.fullscreenMaterial.uniforms.prevProjectionMatrix.value.copy(this.fullscreenMaterial.uniforms.projectionMatrix.value);
    this.fullscreenMaterial.uniforms.prevProjectionMatrixInverse.value.copy(this.fullscreenMaterial.uniforms.projectionMatrixInverse.value);
    this.fullscreenMaterial.uniforms.prevCameraPos.value.copy(this._camera.position);
  }

  jitter(jitterScale = 1) {
    this.unjitter();
    jitter(this.renderTarget.width, this.renderTarget.height, this._camera, this.frame, jitterScale);
  }

  unjitter() {
    if (this._camera.clearViewOffset) this._camera.clearViewOffset();
  }

}

var traa_compose = "#define GLSLIFY 1\nuniform sampler2D accumulatedTexture;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 accumulatedTexel=textureLod(accumulatedTexture,uv,0.);outputColor=vec4(accumulatedTexel.rgb,1.);}"; // eslint-disable-line

class TRAAEffect extends Effect {
  constructor(scene, camera, velocityDepthNormalPass, options = defaultTemporalReprojectPassOptions) {
    super("TRAAEffect", traa_compose, {
      type: "FinalTRAAEffectMaterial",
      uniforms: new Map([["accumulatedTexture", new Uniform(null)]])
    });
    this._scene = scene;
    this._camera = camera;
    this.velocityDepthNormalPass = velocityDepthNormalPass;
    options = { ...options,
      ...{
        maxBlend: 0.9,
        neighborhoodClamp: true,
        neighborhoodClampIntensity: 1,
        neighborhoodClampRadius: 1,
        logTransform: true,
        confidencePower: 4
      }
    };
    this.options = { ...defaultTemporalReprojectPassOptions,
      ...options
    };
    this.setSize(options.width, options.height);
  }

  setSize(width, height) {
    var _this$temporalReproje;

    (_this$temporalReproje = this.temporalReprojectPass) == null ? void 0 : _this$temporalReproje.setSize(width, height);
  }

  dispose() {
    super.dispose();
    this.temporalReprojectPass.dispose();
  }

  reset() {
    this.temporalReprojectPass.reset();
  }

  update(renderer, inputBuffer) {
    if (!this.temporalReprojectPass) {
      this.temporalReprojectPass = new TemporalReprojectPass(this._scene, this._camera, this.velocityDepthNormalPass, inputBuffer.texture, 1, this.options);
      this.temporalReprojectPass.setSize(inputBuffer.width, inputBuffer.height);
      this.uniforms.get("accumulatedTexture").value = this.temporalReprojectPass.texture;
    }

    this.temporalReprojectPass.unjitter();
    this.unjitteredProjectionMatrix = this._camera.projectionMatrix.clone();

    this._camera.projectionMatrix.copy(this.unjitteredProjectionMatrix);

    this.temporalReprojectPass.jitter();
    this.temporalReprojectPass.render(renderer);
  }

}
TRAAEffect.DefaultOptions = defaultTemporalReprojectPassOptions;

class CubeToEquirectEnvPass extends Pass {
  constructor() {
    super("CubeToEquirectEnvPass");
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      depthBuffer: false,
      type: FloatType
    });
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader:
      /* glsl */
      `
            varying vec2 vUv;
			uniform samplerCube cubeMap;

			#define M_PI 3.1415926535897932384626433832795
			
			// source: https://github.com/spite/CubemapToEquirectangular/blob/master/src/CubemapToEquirectangular.js
            void main() {
				float longitude = vUv.x * 2. * M_PI - M_PI + M_PI / 2.;
				float latitude = vUv.y * M_PI;

				vec3 dir = vec3(
					- sin( longitude ) * sin( latitude ),
					cos( latitude ),
					- cos( longitude ) * sin( latitude )
				);

				dir.y = -dir.y;

				gl_FragColor = textureCube( cubeMap, dir );
            }
            `,
      vertexShader: vertexShader,
      uniforms: {
        cubeMap: {
          value: null
        }
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    });
  }

  dispose() {
    this.renderTarget.dispose();
  }

  generateEquirectEnvMap(renderer, cubeMap, width = null, height = null, maxWidth = 4096) {
    if (width === null && height === null) {
      const w = cubeMap.source.data[0].width;
      const widthEquirect = 2 ** Math.ceil(Math.log2(2 * w * 3 ** 0.5));
      const heightEquirect = 2 ** Math.ceil(Math.log2(w * 3 ** 0.5));
      width = widthEquirect;
      height = heightEquirect;
    }

    if (width > maxWidth) {
      width = maxWidth;
      height = maxWidth / 2;
    }

    this.renderTarget.setSize(width, height);
    this.fullscreenMaterial.uniforms.cubeMap.value = cubeMap;
    const {
      renderTarget
    } = this;
    renderer.setRenderTarget(renderTarget);
    renderer.render(this.scene, this.camera); // Create a new Float32Array to store the pixel data

    const pixelBuffer = new Float32Array(width * height * 4);
    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, pixelBuffer); // Create a new data texture

    const equirectEnvMap = new DataTexture(pixelBuffer, width, height, RGBAFormat, FloatType); // Set texture options

    equirectEnvMap.wrapS = ClampToEdgeWrapping;
    equirectEnvMap.wrapT = ClampToEdgeWrapping;
    equirectEnvMap.minFilter = LinearMipMapLinearFilter;
    equirectEnvMap.magFilter = LinearMipMapLinearFilter;
    equirectEnvMap.needsUpdate = true;
    equirectEnvMap.mapping = EquirectangularReflectionMapping;
    return equirectEnvMap;
  }

}

var img = "data:image/png;base64,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";
  var blueNoiseImage = img;

var blue_noise = "#define GLSLIFY 1\nuniform sampler2D blueNoiseTexture;uniform vec2 blueNoiseSize;uniform int blueNoiseIndex;uvec4 s1;ivec2 pixel;void rng_initialize(vec2 p,int index){pixel=ivec2(p);s1=uvec4(index,index*15843,index*31+4566,index*2345+58585);}void pcg4d(inout uvec4 v){v=v*1664525u+1013904223u;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z;v=v ^(v>>16u);v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z;}ivec2 shift2(ivec2 size){pcg4d(s1);return(pixel+ivec2(s1.xy % 0x0fffffffu))% size;}vec4 blueNoise(vec2 uv,int index){if(index==0)return textureLod(blueNoiseTexture,uv*resolution/blueNoiseSize,0.0);rng_initialize(vUv*resolution,index);vec4 blueNoise=texelFetch(blueNoiseTexture,shift2(ivec2(blueNoiseSize)),0);return blueNoise;}vec4 blueNoise(){return blueNoise(vUv,int(blueNoiseIndex));}vec4 blueNoise(vec2 uv){return blueNoise(uv,int(blueNoiseIndex));}"; // eslint-disable-line

/* eslint-disable camelcase */
const blueNoiseSize = 128;
const highestSignedInt = 0x7fffffff;
const blueNoiseTexture = new TextureLoader().load(blueNoiseImage, () => {
  blueNoiseTexture.minFilter = NearestFilter;
  blueNoiseTexture.magFilter = NearestFilter;
  blueNoiseTexture.wrapS = RepeatWrapping;
  blueNoiseTexture.wrapT = RepeatWrapping;
  blueNoiseTexture.colorSpace = NoColorSpace;
});
const setupBlueNoise = fragmentShader => {
  let blueNoiseIndex = 0;
  const startIndex = Math.floor(Math.random() * highestSignedInt);
  const uniforms = {
    blueNoiseTexture: {
      value: blueNoiseTexture
    },
    blueNoiseSize: {
      value: new Vector2(blueNoiseSize, blueNoiseSize)
    },
    blueNoiseIndex: {
      get value() {
        blueNoiseIndex = (startIndex + blueNoiseIndex + 1) % highestSignedInt;
        return blueNoiseIndex;
      },

      set value(v) {
        blueNoiseIndex = v;
      }

    }
  };
  fragmentShader = fragmentShader.replace("uniform vec2 resolution;", "uniform vec2 resolution;\n" + blue_noise);
  return {
    uniforms,
    fragmentShader
  };
};
const useBlueNoise = material => {
  const {
    fragmentShader,
    uniforms
  } = setupBlueNoise(material.fragmentShader);
  material.fragmentShader = fragmentShader;
  material.uniforms = { ...material.uniforms,
    ...uniforms
  };
  material.needsUpdate = true;
};

/* eslint-disable camelcase */

class GBufferMaterial extends MeshPhysicalMaterial {
  onBeforeCompile(shader) {
    this.uniforms = shader.uniforms;
    shader.uniforms.resolution = {
      value: new Vector2(1, 1)
    };
    shader.uniforms.cameraNotMovedFrames = {
      value: 0
    }; // delete all includes that have the pattern "#include <lights_something>"

    shader.vertexShader = shader.vertexShader.replace(/#include <lights_.*>/g, "");
    shader.fragmentShader = shader.fragmentShader.replace(/#include <lights_.*>/g, ""); // delete all includes that have the pattern "#include <alpha...>"

    shader.vertexShader = shader.vertexShader.replace(/#include <alpha.*>/g, "");
    shader.fragmentShader = shader.fragmentShader.replace(/#include <alpha.*>/g, ""); // delete all includes that have the pattern "#include <aomap...>"

    shader.vertexShader = shader.vertexShader.replace(/#include <aomap.*>/g, "");
    shader.fragmentShader = shader.fragmentShader.replace(/#include <aomap.*>/g, ""); // delete all includes that have the pattern "#include <lightmap...>"

    shader.vertexShader = shader.vertexShader.replace(/#include <lightmap.*>/g, "");
    shader.fragmentShader = shader.fragmentShader.replace(/#include <lightmap.*>/g, ""); // delete all includes that have the pattern "#include <alphahash...>"

    shader.vertexShader = shader.vertexShader.replace(/#include <alphahash.*>/g, "");
    shader.fragmentShader = shader.fragmentShader.replace(/#include <alphahash.*>/g, ""); // delete all includes that have the pattern "#include <alphatest...>"

    shader.vertexShader = shader.vertexShader.replace(/#include <alphatest.*>/g, "");
    shader.fragmentShader = shader.fragmentShader.replace(/#include <alphatest.*>/g, ""); // remove opaque_fragment include

    shader.fragmentShader = shader.fragmentShader.replace("#include <opaque_fragment>", ""); // remove colorspace_fragment include

    shader.fragmentShader = shader.fragmentShader.replace("#include <colorspace_fragment>", ""); // delete the fog_fragment include

    shader.fragmentShader = shader.fragmentShader.replace("#include <fog_fragment>", "");
    shader.fragmentShader = shader.fragmentShader.replace("void main() {",
    /* glsl */
    `
			#define vUv gl_FragCoord.xy
            uniform vec2 resolution;
            uniform float cameraNotMovedFrames;

            ${gbuffer_packing}

            void main() {
					float a = opacity;

					#ifdef USE_ALPHAMAP
						a *= texture2D( alphaMap, vAlphaMapUv ).g;
					#endif

					if (cameraNotMovedFrames == 0.) {
						if(a < 0.5) {
							discard;
							return;
						}

						a = 1.;
					} else if (a != 1.) {
						float aStep = a > 0.5 ? 1. : 0.;
						a = mix(a, aStep, (1. / (cameraNotMovedFrames * 0.1 + 1.)));

						vec4 noise = blueNoise();
						if (noise.x > a) {
							discard;
							return;
						}
					}
        `).replace("#include <dithering_fragment>",
    /* glsl */
    `
            #include <dithering_fragment>

            vec3 worldNormal = normalize((vec4(normal, 1.) * viewMatrix).xyz);

            vec4 gBuffer = packGBuffer(diffuseColor, worldNormal, roughnessFactor, metalnessFactor, totalEmissiveRadiance);

            gl_FragColor = gBuffer;`);
    const {
      uniforms,
      fragmentShader
    } = setupBlueNoise(shader.fragmentShader);
    shader.uniforms = { ...shader.uniforms,
      ...uniforms
    };
    shader.fragmentShader = fragmentShader;
  }

}

const gBufferMaterial = new GBufferMaterial();
function createGBufferMaterial(originalMaterial) {
  const material = gBufferMaterial.clone();
  copyAllPropsToGBufferMaterial(originalMaterial, material);
  return material;
}
let props = Object.keys(gBufferMaterial); // delete the ones that start with "_"

props = props.filter(key => !key.startsWith("_") && !key.startsWith("is") && key !== "uuid" && key !== "type" && key !== "transparent"); // this function attempts to copy all the props from the original material to the new GBufferMaterial

function copyAllPropsToGBufferMaterial(originalMaterial, gBufferMaterial) {
  for (const key of props) {
    if (originalMaterial[key] !== undefined) {
      gBufferMaterial[key] = originalMaterial[key];
    }
  }
}

const propsPrimitive = props.filter(key => typeof gBufferMaterial[key] === "string" || typeof gBufferMaterial[key] === "number");
function copyPropsToGBufferMaterial(originalMaterial, gBufferMaterial) {
  for (const prop of propsPrimitive) {
    gBufferMaterial[prop] = originalMaterial[prop];
  }
}

const backgroundColor$1 = new Color(0);
class GBufferPass extends Pass {
  constructor(scene, camera) {
    super("GBufferPass");
    this.frame = 21483;
    this.cachedMaterials = new WeakMap();
    this.visibleMeshes = [];
    this.lastCameraPosition = new Vector3();
    this.lastCameraQuaternion = new Quaternion();
    this._scene = scene;
    this._camera = camera;
    this.initGBufferRenderTarget();
  }

  get texture() {
    return this.renderTarget.texture;
  }

  get depthTexture() {
    return this.renderTarget.depthTexture;
  }

  initGBufferRenderTarget() {
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: true
    });
    this.renderTarget.texture.name = "GBufferPass.Texture";
    this.renderTarget.depthTexture = new DepthTexture(1, 1);
    this.renderTarget.depthTexture.type = FloatType;
    this.renderTarget.depthTexture.name = "GBufferPass.DepthTexture";
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }

  dispose() {
    super.dispose();
    this.renderTarget.dispose();
  }

  setGBufferMaterialInScene() {
    this.visibleMeshes = getVisibleChildren$1(this._scene);
    const cameraMoved = didCameraMove(this._camera, this.lastCameraPosition, this.lastCameraQuaternion);

    for (const c of this.visibleMeshes) {
      const originalMaterial = c.material;
      let [cachedOriginalMaterial, gBufferMaterial] = this.cachedMaterials.get(c) || []; // init a new material if the original material changed or if the cached material is missing

      if (originalMaterial !== cachedOriginalMaterial) {
        if (gBufferMaterial) gBufferMaterial.dispose();
        gBufferMaterial = createGBufferMaterial(originalMaterial);
        this.cachedMaterials.set(c, [originalMaterial, gBufferMaterial]);
      } // gBufferMaterial.uniforms.resolution.value.set(this.renderTarget.width, this.renderTarget.height)
      // gBufferMaterial.uniforms.frame.value = this.frame


      if (gBufferMaterial.uniforms) {
        gBufferMaterial.uniforms.cameraNotMovedFrames.value = cameraMoved ? 0 : (gBufferMaterial.uniforms.cameraNotMovedFrames.value + 1) % 0xffff;
      }

      c.visible = isChildMaterialRenderable(c, originalMaterial);
      copyPropsToGBufferMaterial(originalMaterial, gBufferMaterial);
      c.material = gBufferMaterial;
    }
  }

  unsetGBufferMaterialInScene() {
    for (const c of this.visibleMeshes) {
      const [originalMaterial] = this.cachedMaterials.get(c);
      c.material = originalMaterial;
    }
  }

  render(renderer) {
    this.frame = (this.frame + 1) % 4096;
    const {
      background
    } = this._scene;
    this._scene.background = backgroundColor$1;
    this.setGBufferMaterialInScene();
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this._scene, this._camera);
    this.unsetGBufferMaterialInScene(); // reset state

    this.lastCameraPosition.copy(this._camera.position);
    this.lastCameraQuaternion.copy(this._camera.quaternion);
    this._scene.background = background;
  }

}

var fragmentShader$6 = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D accumulatedTexture;uniform highp sampler2D depthTexture;uniform highp sampler2D velocityTexture;uniform sampler2D directLightTexture;uniform vec3 backgroundColor;uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;uniform float maxEnvMapMipLevel;uniform float rayDistance;uniform float thickness;uniform float envBlur;uniform vec2 resolution;uniform float cameraNear;uniform float cameraFar;uniform float nearMinusFar;uniform float nearMulFar;uniform float farMinusNear;struct EquirectHdrInfo{sampler2D marginalWeights;sampler2D conditionalWeights;sampler2D map;vec2 size;float totalSumWhole;float totalSumDecimal;};uniform EquirectHdrInfo envMapInfo;\n#define INVALID_RAY_COORDS vec2(-1.0);\n#define EPSILON 0.00001\n#define ONE_MINUS_EPSILON 1.0 - EPSILON\nvec2 invTexSize;\n#define MODE_SSGI 0\n#define MODE_SSR 1\n#include <packing>\n#include <gbuffer_packing>\n#include <ssgi_utils>\nvec2 RayMarch(inout vec3 dir,inout vec3 hitPos,vec4 random);vec2 BinarySearch(inout vec3 dir,inout vec3 hitPos);struct RayTracingInfo{float NoV;float NoL;float NoH;float LoH;float VoH;bool isDiffuseSample;bool isEnvSample;};struct RayTracingResult{vec3 gi;vec3 l;vec3 hitPos;bool isMissedRay;vec3 brdf;float pdf;};struct EnvMisSample{float pdf;float probability;bool isEnvSample;};vec3 worldNormal;vec3 doSample(const vec3 viewPos,const vec3 viewDir,const vec3 viewNormal,const vec3 worldPos,const float metalness,const float roughness,const bool isDiffuseSample,const bool isEnvSample,const float NoV,const float NoL,const float NoH,const float LoH,const float VoH,const vec4 random,inout vec3 l,inout vec3 hitPos,out bool isMissedRay,out vec3 brdf,out float pdf);void calculateAngles(inout vec3 h,inout vec3 l,inout vec3 v,inout vec3 n,inout float NoL,inout float NoH,inout float LoH,inout float VoH){h=normalize(v+l);NoL=clamp(dot(n,l),EPSILON,ONE_MINUS_EPSILON);NoH=clamp(dot(n,h),EPSILON,ONE_MINUS_EPSILON);LoH=clamp(dot(l,h),EPSILON,ONE_MINUS_EPSILON);VoH=clamp(dot(v,h),EPSILON,ONE_MINUS_EPSILON);}vec3 worldPos;Material mat;void main(){float unpackedDepth=textureLod(depthTexture,vUv,0.0).r;if(unpackedDepth==1.0){vec4 directLight=textureLod(directLightTexture,vUv,0.0);gl_FragColor=packTwoVec4(directLight,directLight);return;}mat=getMaterial(gBufferTexture,vUv);float roughnessSq=clamp(mat.roughness*mat.roughness,0.000001,1.0);invTexSize=1./resolution;float viewZ=getViewZ(unpackedDepth);vec3 viewPos=getViewPosition(viewZ);vec3 viewDir=normalize(viewPos);worldNormal=mat.normal;vec3 viewNormal=normalize((vec4(worldNormal,0.)*cameraMatrixWorld).xyz);worldPos=(cameraMatrixWorld*vec4(viewPos,1.)).xyz;vec3 n=viewNormal;vec3 v=-viewDir;float NoV=max(EPSILON,dot(n,v));vec3 V=(vec4(v,0.)*viewMatrix).xyz;vec3 N=worldNormal;vec4 random;vec3 H,l,h,F,T,B,envMisDir,gi;vec3 diffuseGI,specularGI,brdf,hitPos,specularHitPos;Onb(N,T,B);V=ToLocal(T,B,N,V);vec3 f0=mix(vec3(0.04),mat.diffuse.rgb,mat.metalness);float NoL,NoH,LoH,VoH,diffW,specW,invW,pdf,envPdf,diffuseSamples,specularSamples;bool isDiffuseSample,isEnvSample,isMissedRay;random=blueNoise();H=SampleGGXVNDF(V,roughnessSq,roughnessSq,random.r,random.g);if(H.z<0.0)H=-H;l=normalize(reflect(-V,H));l=ToWorld(T,B,N,l);l=(vec4(l,0.)*cameraMatrixWorld).xyz;l=normalize(l);calculateAngles(h,l,v,n,NoL,NoH,LoH,VoH);\n#if mode == MODE_SSGI\nF=F_Schlick(f0,VoH);diffW=(1.-mat.metalness)*luminance(mat.diffuse.rgb);specW=luminance(F);diffW=max(diffW,EPSILON);specW=max(specW,EPSILON);invW=1./(diffW+specW);diffW*=invW;isDiffuseSample=random.b<diffW;\n#else\nisDiffuseSample=false;\n#endif\nEnvMisSample ems;ems.pdf=1.;envMisDir=vec3(0.0);envPdf=1.;\n#ifdef importanceSampling\nems.pdf=sampleEquirectProbability(envMapInfo,random.rg,envMisDir);envMisDir=normalize((vec4(envMisDir,0.)*cameraMatrixWorld).xyz);ems.probability=dot(envMisDir,viewNormal);ems.probability*=mat.roughness;ems.probability=min(ONE_MINUS_EPSILON,ems.probability);ems.isEnvSample=random.a<ems.probability;if(ems.isEnvSample){ems.pdf/=1.-ems.probability;l=envMisDir;calculateAngles(h,l,v,n,NoL,NoH,LoH,VoH);}else{ems.pdf=1.-ems.probability;}\n#endif\nvec3 diffuseRay=ems.isEnvSample ? envMisDir : cosineSampleHemisphere(viewNormal,random.rg);vec3 specularRay=ems.isEnvSample ? envMisDir : l;\n#if mode == MODE_SSGI\nif(isDiffuseSample){l=diffuseRay;calculateAngles(h,l,v,n,NoL,NoH,LoH,VoH);gi=doSample(viewPos,viewDir,viewNormal,worldPos,mat.metalness,roughnessSq,isDiffuseSample,ems.isEnvSample,NoV,NoL,NoH,LoH,VoH,random,l,hitPos,isMissedRay,brdf,pdf);gi*=brdf;if(ems.isEnvSample){gi*=misHeuristic(ems.pdf,pdf);}else{gi/=pdf;}gi/=ems.pdf;diffuseSamples++;diffuseGI=mix(diffuseGI,gi,1./diffuseSamples);}\n#endif\nl=specularRay;calculateAngles(h,l,v,n,NoL,NoH,LoH,VoH);gi=doSample(viewPos,viewDir,viewNormal,worldPos,mat.metalness,roughnessSq,isDiffuseSample,ems.isEnvSample,NoV,NoL,NoH,LoH,VoH,random,l,hitPos,isMissedRay,brdf,pdf);gi*=brdf;if(ems.isEnvSample){gi*=misHeuristic(ems.pdf,pdf);}else{gi/=pdf;}gi/=ems.pdf;specularHitPos=hitPos;specularSamples++;specularGI=mix(specularGI,gi,1./specularSamples);\n#ifdef useDirectLight\nvec3 directLight=textureLod(directLightTexture,vUv,0.).rgb;diffuseGI+=directLight;specularGI+=directLight;\n#endif\nhighp vec4 gDiffuse,gSpecular;\n#if mode == MODE_SSGI\nif(diffuseSamples==0.0)diffuseGI=vec3(-1.0);gDiffuse=vec4(diffuseGI,mat.roughness);\n#endif\nhighp float rayLength=0.0;vec4 hitPosWS;vec3 cameraPosWS=cameraMatrixWorld[3].xyz;isMissedRay=hitPos.x>10.0e8;if(!isMissedRay){hitPosWS=cameraMatrixWorld*vec4(specularHitPos,1.0);rayLength=distance(cameraPosWS,hitPosWS.xyz);}highp uint packedRoughnessRayLength=packHalf2x16(vec2(rayLength,mat.roughness));highp float a=uintBitsToFloat(packedRoughnessRayLength);\n#if mode == MODE_SSGI\ngSpecular=vec4(specularGI,rayLength);gl_FragColor=packTwoVec4(gDiffuse,gSpecular);\n#else\ngSpecular=vec4(specularGI,a);gl_FragColor=gSpecular;\n#endif\n}vec3 getEnvColor(vec3 l,vec3 worldPos,float roughness,bool isDiffuseSample,bool isEnvSample){vec3 envMapSample;\n#ifdef USE_ENVMAP\nvec3 reflectedWS=normalize((vec4(l,0.)*viewMatrix).xyz);\n#ifdef BOX_PROJECTED_ENV_MAP\nreflectedWS=parallaxCorrectNormal(reflectedWS.xyz,envMapSize,envMapPosition,worldPos);reflectedWS=normalize(reflectedWS.xyz);\n#endif\nfloat mip=envBlur*maxEnvMapMipLevel;if(!isDiffuseSample&&roughness<0.15)mip*=roughness/0.15;envMapSample=sampleEquirectEnvMapColor(reflectedWS,envMapInfo.map,mip);float maxEnvLum=isEnvSample ? 100.0 : 25.0;if(maxEnvLum!=0.0){float envLum=luminance(envMapSample);if(envLum>maxEnvLum){envMapSample*=maxEnvLum/envLum;}}return envMapSample;\n#else\nreturn vec3(0.0);\n#endif\n}float getSaturation(vec3 c){float maxComponent=max(max(c.r,c.g),c.b);float minComponent=min(min(c.r,c.g),c.b);float delta=maxComponent-minComponent;if(maxComponent==minComponent){return 0.0;}else{return delta/maxComponent;}}vec3 doSample(const vec3 viewPos,const vec3 viewDir,const vec3 viewNormal,const vec3 worldPos,const float metalness,const float roughness,const bool isDiffuseSample,const bool isEnvSample,const float NoV,const float NoL,const float NoH,const float LoH,const float VoH,const vec4 random,inout vec3 l,inout vec3 hitPos,out bool isMissedRay,out vec3 brdf,out float pdf){float cosTheta=max(0.0,dot(viewNormal,l));if(isDiffuseSample){vec3 diffuseBrdf=evalDisneyDiffuse(NoL,NoV,LoH,roughness,metalness);pdf=NoL/M_PI;brdf=diffuseBrdf;}else{vec3 specularBrdf=evalDisneySpecular(roughness,NoH,NoV,NoL);pdf=GGXVNDFPdf(NoH,NoV,roughness);brdf=specularBrdf;}brdf*=cosTheta;pdf=max(EPSILON,pdf);hitPos=viewPos;vec2 coords=RayMarch(l,hitPos,random);bool allowMissedRays=false;\n#ifdef missedRays\nallowMissedRays=true;\n#endif\nisMissedRay=hitPos.x==10.0e9;vec3 envMapSample=vec3(0.);if(isMissedRay&&!allowMissedRays)return getEnvColor(l,worldPos,roughness,isDiffuseSample,isEnvSample);vec4 velocity=textureLod(velocityTexture,coords.xy,0.0);vec2 reprojectedUv=coords.xy-velocity.xy;vec3 SSGI;vec3 envColor=getEnvColor(l,worldPos,roughness,isDiffuseSample,isEnvSample);if(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){vec4 reprojectedGI=textureLod(accumulatedTexture,reprojectedUv,0.);float saturation=getSaturation(mat.diffuse.rgb);reprojectedGI.rgb=mix(reprojectedGI.rgb,vec3(luminance(reprojectedGI.rgb)),(1.-roughness)*saturation*0.4);SSGI=reprojectedGI.rgb;float aspect=resolution.x/resolution.y;float border=0.15;float borderFactor=smoothstep(0.0,border,coords.x)*smoothstep(1.0,1.0-border,coords.x)*smoothstep(0.0,border,coords.y)*smoothstep(1.0,1.0-border,coords.y);borderFactor=sqrt(borderFactor);SSGI=mix(envColor,SSGI,borderFactor);}else{return envColor;}if(allowMissedRays){float ssgiLum=luminance(SSGI);float envLum=luminance(envMapSample);if(envLum>ssgiLum)SSGI=envMapSample;}return SSGI;}vec2 RayMarch(inout vec3 dir,inout vec3 hitPos,vec4 random){float rayHitDepthDifference;dir*=rayDistance/float(steps);vec2 uv;for(int i=1;i<steps;i++){float cs=1.-exp(-0.25*pow(float(i)+random.b-0.5,2.));hitPos+=dir*cs;uv=viewSpaceToScreenSpace(hitPos);float unpackedDepth=textureLod(depthTexture,uv,0.0).r;float z=getViewZ(unpackedDepth);rayHitDepthDifference=z-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<thickness){if(refineSteps==0){return uv;}else{return BinarySearch(dir,hitPos);}}}hitPos.xyz=vec3(10.0e9);return uv;}vec2 BinarySearch(inout vec3 dir,inout vec3 hitPos){float rayHitDepthDifference;vec2 uv;dir*=0.5;hitPos-=dir;for(int i=0;i<refineSteps;i++){uv=viewSpaceToScreenSpace(hitPos);float unpackedDepth=textureLod(depthTexture,uv,0.0).r;float z=getViewZ(unpackedDepth);rayHitDepthDifference=z-hitPos.z;dir*=0.5;if(rayHitDepthDifference>=0.0){hitPos-=dir;}else{hitPos+=dir;}}uv=viewSpaceToScreenSpace(hitPos);return uv;}"; // eslint-disable-line

var ssgi_utils = "#define GLSLIFY 1\n#define PI M_PI\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nfloat getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\n#else\nreturn depth*nearMinusFar-cameraNear;\n#endif\n}vec3 getViewPosition(float viewZ){float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,viewZ)-0.5)*2.0,1.0);clipPosition*=clipW;vec3 p=(projectionMatrixInverse*clipPosition).xyz;p.z=viewZ;return p;}vec2 viewSpaceToScreenSpace(const vec3 position){vec4 projectedCoord=projectionMatrix*vec4(position,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;return projectedCoord.xy;}vec3 worldSpaceToViewSpace(vec3 worldPosition){vec4 viewPosition=viewMatrix*vec4(worldPosition,1.0);return viewPosition.xyz/viewPosition.w;}\n#ifdef BOX_PROJECTED_ENV_MAP\nuniform vec3 envMapSize;uniform vec3 envMapPosition;vec3 parallaxCorrectNormal(const vec3 v,const vec3 cubeSize,const vec3 cubePos,const vec3 worldPosition){vec3 nDir=normalize(v);vec3 rbmax=(.5*cubeSize+cubePos-worldPosition)/nDir;vec3 rbmin=(-.5*cubeSize+cubePos-worldPosition)/nDir;vec3 rbminmax;rbminmax.x=(nDir.x>0.)? rbmax.x : rbmin.x;rbminmax.y=(nDir.y>0.)? rbmax.y : rbmin.y;rbminmax.z=(nDir.z>0.)? rbmax.z : rbmin.z;float correction=min(min(rbminmax.x,rbminmax.y),rbminmax.z);vec3 boxIntersection=worldPosition+nDir*correction;return boxIntersection-cubePos;}\n#endif\n#define M_PI 3.1415926535897932384626433832795\nvec2 equirectDirectionToUv(const vec3 direction){vec2 uv=vec2(atan(direction.z,direction.x),acos(direction.y));uv/=vec2(2.0*M_PI,M_PI);uv.x+=0.5;uv.y=1.0-uv.y;return uv;}vec3 equirectUvToDirection(vec2 uv){uv.x-=0.5;uv.y=1.0-uv.y;float theta=uv.x*2.0*PI;float phi=uv.y*PI;float sinPhi=sin(phi);return vec3(sinPhi*cos(theta),cos(phi),sinPhi*sin(theta));}vec3 sampleEquirectEnvMapColor(const vec3 direction,const sampler2D map,const float lod){return textureLod(map,equirectDirectionToUv(direction),lod).rgb;}mat3 getBasisFromNormal(const vec3 normal){vec3 other;if(abs(normal.x)>0.5){other=vec3(0.0,1.0,0.0);}else{other=vec3(1.0,0.0,0.0);}vec3 ortho=normalize(cross(normal,other));vec3 ortho2=normalize(cross(normal,ortho));return mat3(ortho2,ortho,normal);}vec3 F_Schlick(const vec3 f0,const float theta){return f0+(1.-f0)*pow(1.0-theta,5.);}float F_Schlick(const float f0,const float f90,const float theta){return f0+(f90-f0)*pow(1.0-theta,5.0);}float D_GTR(const float roughness,const float NoH,const float k){float a2=pow(roughness,2.);return a2/(PI*pow((NoH*NoH)*(a2*a2-1.)+1.,k));}float SmithG(const float NDotV,const float alphaG){float a=alphaG*alphaG;float b=NDotV*NDotV;return(2.0*NDotV)/(NDotV+sqrt(a+b-a*b));}float GGXVNDFPdf(const float NoH,const float NoV,const float roughness){float D=D_GTR(roughness,NoH,2.);float G1=SmithG(NoV,roughness*roughness);return(D*G1)/max(0.00001,4.0*NoV);}float GeometryTerm(const float NoL,const float NoV,const float roughness){float a2=roughness*roughness;float G1=SmithG(NoV,a2);float G2=SmithG(NoL,a2);return G1*G2;}vec3 evalDisneyDiffuse(const float NoL,const float NoV,const float LoH,const float roughness,const float metalness){float FD90=0.5+2.*roughness*pow(LoH,2.);float a=F_Schlick(1.,FD90,NoL);float b=F_Schlick(1.,FD90,NoV);return vec3((a*b/PI)*(1.-metalness));}vec3 evalDisneySpecular(const float roughness,const float NoH,const float NoV,const float NoL){float D=D_GTR(roughness,NoH,2.);float G=GeometryTerm(NoL,NoV,pow(0.5+roughness*.5,2.));vec3 spec=vec3(D*G/(4.*NoL*NoV));return spec;}vec3 SampleGGXVNDF(const vec3 V,const float ax,const float ay,const float r1,const float r2){vec3 Vh=normalize(vec3(ax*V.x,ay*V.y,V.z));float lensq=Vh.x*Vh.x+Vh.y*Vh.y;vec3 T1=lensq>0. ? vec3(-Vh.y,Vh.x,0.)*inversesqrt(lensq): vec3(1.,0.,0.);vec3 T2=cross(Vh,T1);float r=sqrt(r1);float phi=2.0*PI*r2;float t1=r*cos(phi);float t2=r*sin(phi);float s=0.5*(1.0+Vh.z);t2=(1.0-s)*sqrt(1.0-t1*t1)+s*t2;vec3 Nh=t1*T1+t2*T2+sqrt(max(0.0,1.0-t1*t1-t2*t2))*Vh;return normalize(vec3(ax*Nh.x,ay*Nh.y,max(0.0,Nh.z)));}void Onb(const vec3 N,inout vec3 T,inout vec3 B){vec3 up=abs(N.z)<0.9999999 ? vec3(0,0,1): vec3(1,0,0);T=normalize(cross(up,N));B=cross(N,T);}vec3 ToLocal(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return vec3(dot(V,X),dot(V,Y),dot(V,Z));}vec3 ToWorld(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return V.x*X+V.y*Y+V.z*Z;}vec3 cosineSampleHemisphere(const vec3 n,const vec2 u){float r=sqrt(u.x);float theta=2.0*PI*u.y;vec3 b=normalize(cross(n,vec3(0.0,1.0,1.0)));vec3 t=cross(b,n);return normalize(r*sin(theta)*b+sqrt(1.0-u.x)*n+r*cos(theta)*t);}float equirectDirectionPdf(vec3 direction){vec2 uv=equirectDirectionToUv(direction);float theta=uv.y*PI;float sinTheta=sin(theta);if(sinTheta==0.0){return 0.0;}return 1.0/(2.0*PI*PI*sinTheta);}float sampleEquirectProbability(EquirectHdrInfo info,vec2 blueNoise,out vec3 direction){float v=textureLod(info.marginalWeights,vec2(blueNoise.x,0.0),0.).x;float u=textureLod(info.conditionalWeights,vec2(blueNoise.y,v),0.).x;vec2 uv=vec2(u,v);vec3 derivedDirection=equirectUvToDirection(uv);direction=derivedDirection;vec3 color=texture(info.map,uv).rgb;float totalSum=info.totalSumWhole+info.totalSumDecimal;float lum=luminance(color);float pdf=lum/totalSum;return info.size.x*info.size.y*pdf;}float misHeuristic(float a,float b){float aa=a*a;float bb=b*b;return aa/(aa+bb);}vec3 alignToNormal(const vec3 normal,const vec3 direction){vec3 tangent;vec3 bitangent;Onb(normal,tangent,bitangent);vec3 localDir=ToLocal(tangent,bitangent,normal,direction);vec3 localDirAligned=vec3(localDir.x,localDir.y,abs(localDir.z));vec3 alignedDir=ToWorld(tangent,bitangent,normal,localDirAligned);return alignedDir;}float getFlatness(vec3 g,vec3 rp){vec3 gw=fwidth(g);vec3 pw=fwidth(rp);float wfcurvature=length(gw)/length(pw);wfcurvature=smoothstep(0.0,30.,wfcurvature);return clamp(wfcurvature,0.,1.);}"; // eslint-disable-line

// source: https://github.com/gkjohnson/three-gpu-pathtracer/blob/main/src/uniforms/EquirectHdrInfoUniform.js

const workerOnMessage = ({
  data: {
    width,
    height,
    isFloatType,
    flipY,
    data
  }
}) => {
  // from: https://github.com/mrdoob/three.js/blob/dev/src/extras/DataUtils.js
  // importing modules doesn't seem to work for workers that were generated through createObjectURL() for some reason
  const _tables = /* @__PURE__*/_generateTables();

  function _generateTables() {
    // float32 to float16 helpers
    const buffer = new ArrayBuffer(4);
    const floatView = new Float32Array(buffer);
    const uint32View = new Uint32Array(buffer);
    const baseTable = new Uint32Array(512);
    const shiftTable = new Uint32Array(512);

    for (let i = 0; i < 256; ++i) {
      const e = i - 127; // very small number (0, -0)

      if (e < -27) {
        baseTable[i] = 0x0000;
        baseTable[i | 0x100] = 0x8000;
        shiftTable[i] = 24;
        shiftTable[i | 0x100] = 24; // small number (denorm)
      } else if (e < -14) {
        baseTable[i] = 0x0400 >> -e - 14;
        baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
        shiftTable[i] = -e - 1;
        shiftTable[i | 0x100] = -e - 1; // normal number
      } else if (e <= 15) {
        baseTable[i] = e + 15 << 10;
        baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
        shiftTable[i] = 13;
        shiftTable[i | 0x100] = 13; // large number (Infinity, -Infinity)
      } else if (e < 128) {
        baseTable[i] = 0x7c00;
        baseTable[i | 0x100] = 0xfc00;
        shiftTable[i] = 24;
        shiftTable[i | 0x100] = 24; // stay (NaN, Infinity, -Infinity)
      } else {
        baseTable[i] = 0x7c00;
        baseTable[i | 0x100] = 0xfc00;
        shiftTable[i] = 13;
        shiftTable[i | 0x100] = 13;
      }
    } // float16 to float32 helpers


    const mantissaTable = new Uint32Array(2048);
    const exponentTable = new Uint32Array(64);
    const offsetTable = new Uint32Array(64);

    for (let i = 1; i < 1024; ++i) {
      let m = i << 13; // zero pad mantissa bits

      let e = 0; // zero exponent
      // normalized

      while ((m & 0x00800000) === 0) {
        m <<= 1;
        e -= 0x00800000; // decrement exponent
      }

      m &= ~0x00800000; // clear leading 1 bit

      e += 0x38800000; // adjust bias

      mantissaTable[i] = m | e;
    }

    for (let i = 1024; i < 2048; ++i) {
      mantissaTable[i] = 0x38000000 + (i - 1024 << 13);
    }

    for (let i = 1; i < 31; ++i) {
      exponentTable[i] = i << 23;
    }

    exponentTable[31] = 0x47800000;
    exponentTable[32] = 0x80000000;

    for (let i = 33; i < 63; ++i) {
      exponentTable[i] = 0x80000000 + (i - 32 << 23);
    }

    exponentTable[63] = 0xc7800000;

    for (let i = 1; i < 64; ++i) {
      if (i !== 32) {
        offsetTable[i] = 1024;
      }
    }

    return {
      floatView: floatView,
      uint32View: uint32View,
      baseTable: baseTable,
      shiftTable: shiftTable,
      mantissaTable: mantissaTable,
      exponentTable: exponentTable,
      offsetTable: offsetTable
    };
  }

  function fromHalfFloat(val) {
    const m = val >> 10;
    _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
    return _tables.floatView[0];
  }

  function colorToLuminance(r, g, b) {
    // https://en.wikipedia.org/wiki/Relative_luminance
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  const binarySearchFindClosestIndexOf = (array, targetValue, offset = 0, count = array.length) => {
    let lower = offset;
    let upper = offset + count - 1;

    while (lower < upper) {
      const mid = lower + upper >> 1; // check if the middle array value is above or below the target and shift
      // which half of the array we're looking at

      if (array[mid] < targetValue) {
        lower = mid + 1;
      } else {
        upper = mid;
      }
    }

    return lower - offset;
  };

  const gatherData = (data, width, height, flipY, marginalDataArray, conditionalDataArray) => {
    // "conditional" = "pixel relative to row pixels sum"
    // "marginal" = "row relative to row sum"
    // remove any y flipping for cdf computation
    if (flipY) {
      for (let y = 0, h = height - 1; y <= h; y++) {
        for (let x = 0, w = width * 4; x < w; x += 4) {
          const newY = h - y;
          const ogIndex = y * w + x;
          const newIndex = newY * w + x;
          data[newIndex] = data[ogIndex];
          data[newIndex + 1] = data[ogIndex + 1];
          data[newIndex + 2] = data[ogIndex + 2];
          data[newIndex + 3] = data[ogIndex + 3];
        }
      }
    } // track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image


    const pdfConditional = new Float32Array(width * height);
    const cdfConditional = new Float32Array(width * height);
    const pdfMarginal = new Float32Array(height);
    const cdfMarginal = new Float32Array(height);
    let totalSumValue = 0.0;
    let cumulativeWeightMarginal = 0.0;

    for (let y = 0; y < height; y++) {
      let cumulativeRowWeight = 0.0;

      for (let x = 0; x < width; x++) {
        const i = y * width + x;
        const r = data[4 * i + 0];
        const g = data[4 * i + 1];
        const b = data[4 * i + 2]; // the probability of the pixel being selected in this row is the
        // scale of the luminance relative to the rest of the pixels.
        // TODO: this should also account for the solid angle of the pixel when sampling

        const weight = colorToLuminance(r, g, b);
        cumulativeRowWeight += weight;
        totalSumValue += weight;
        pdfConditional[i] = weight;
        cdfConditional[i] = cumulativeRowWeight;
      } // can happen if the row is all black


      if (cumulativeRowWeight !== 0) {
        // scale the pdf and cdf to [0.0, 1.0]
        for (let i = y * width, l = y * width + width; i < l; i++) {
          pdfConditional[i] /= cumulativeRowWeight;
          cdfConditional[i] /= cumulativeRowWeight;
        }
      }

      cumulativeWeightMarginal += cumulativeRowWeight; // compute the marginal pdf and cdf along the height of the map.

      pdfMarginal[y] = cumulativeRowWeight;
      cdfMarginal[y] = cumulativeWeightMarginal;
    } // can happen if the texture is all black


    if (cumulativeWeightMarginal !== 0) {
      // scale the marginal pdf and cdf to [0.0, 1.0]
      for (let i = 0, l = pdfMarginal.length; i < l; i++) {
        pdfMarginal[i] /= cumulativeWeightMarginal;
        cdfMarginal[i] /= cumulativeWeightMarginal;
      }
    } // compute a sorted index of distributions and the probabilities along them for both
    // the marginal and conditional data. These will be used to sample with a random number
    // to retrieve a uv value to sample in the environment map.
    // These values continually increase so it's okay to interpolate between them.
    // we add a half texel offset so we're sampling the center of the pixel


    for (let i = 0; i < height; i++) {
      const dist = (i + 1) / height;
      const row = binarySearchFindClosestIndexOf(cdfMarginal, dist);
      marginalDataArray[i] = (row + 0.5) / height;
    }

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const i = y * width + x;
        const dist = (x + 1) / width;
        const col = binarySearchFindClosestIndexOf(cdfConditional, dist, y * width, width);
        conditionalDataArray[i] = (col + 0.5) / width;
      }
    }

    return totalSumValue;
  };

  if (!isFloatType) {
    const newData = new Float32Array(data.length); // eslint-disable-next-line guard-for-in

    for (let i = 0; i < data.length; i++) {
      newData[i] = fromHalfFloat(data[i]);
    }

    data = newData;
  }

  const marginalDataArray = new Float32Array(height);
  const conditionalDataArray = new Float32Array(width * height);
  const totalSumValue = gatherData(data, width, height, flipY, marginalDataArray, conditionalDataArray);
  postMessage({
    totalSumValue,
    marginalDataArray,
    conditionalDataArray
  });
};

const blob = new Blob(["onmessage = " + workerOnMessage], {
  type: "application/javascript"
});
const workerUrl = URL.createObjectURL(blob);
class EquirectHdrInfoUniform {
  constructor() {
    // we use NearestFilter instead of LinearFilter because on many recent Apple devices filtering from such a texture does not work
    // Default to a white texture and associated weights so we don't
    // just render black initially.
    const whiteTex = new DataTexture(new Float32Array([1, 1, 1, 1]), 1, 1);
    whiteTex.type = FloatType;
    whiteTex.format = RGBAFormat;
    whiteTex.minFilter = NearestFilter;
    whiteTex.magFilter = NearestFilter;
    whiteTex.wrapS = RepeatWrapping;
    whiteTex.wrapT = RepeatWrapping;
    whiteTex.generateMipmaps = false;
    whiteTex.needsUpdate = true; // Stores a map of [0, 1] value -> cumulative importance row & pdf
    // used to sampling a random value to a relevant row to sample from

    const marginalWeights = new DataTexture(new Float32Array([0, 1]), 1, 2);
    marginalWeights.type = FloatType;
    marginalWeights.format = RedFormat;
    marginalWeights.minFilter = NearestFilter;
    marginalWeights.magFilter = NearestFilter;
    marginalWeights.generateMipmaps = false;
    marginalWeights.needsUpdate = true; // Stores a map of [0, 1] value -> cumulative importance column & pdf
    // used to sampling a random value to a relevant pixel to sample from

    const conditionalWeights = new DataTexture(new Float32Array([0, 0, 1, 1]), 2, 2);
    conditionalWeights.type = FloatType;
    conditionalWeights.format = RedFormat;
    conditionalWeights.minFilter = NearestFilter;
    conditionalWeights.magFilter = NearestFilter;
    conditionalWeights.generateMipmaps = false;
    conditionalWeights.needsUpdate = true;
    this.map = whiteTex;
    this.marginalWeights = marginalWeights;
    this.conditionalWeights = conditionalWeights; // the total sum value is separated into two values to work around low precision
    // storage of floating values in structs

    this.totalSumWhole = 1;
    this.totalSumDecimal = 0;
    this.size = new Vector2();
  }

  dispose() {
    this.marginalWeights.dispose();
    this.conditionalWeights.dispose();
    this.map.dispose();
  }

  updateFrom(map) {
    map = map.clone();
    const {
      width,
      height,
      data
    } = map.image;
    const {
      type
    } = map;
    this.size.set(width, height);
    return new Promise(resolve => {
      var _this$worker;

      (_this$worker = this.worker) == null ? void 0 : _this$worker.terminate();
      this.worker = new Worker(workerUrl);
      this.worker.postMessage({
        width,
        height,
        isFloatType: type === FloatType,
        flipY: map.flipY,
        data
      });

      this.worker.onmessage = ({
        data: {
          totalSumValue,
          marginalDataArray,
          conditionalDataArray
        }
      }) => {
        this.dispose();
        const {
          marginalWeights,
          conditionalWeights
        } = this;
        marginalWeights.image = {
          width: height,
          height: 1,
          data: marginalDataArray
        };
        marginalWeights.needsUpdate = true;
        conditionalWeights.image = {
          width,
          height,
          data: conditionalDataArray
        };
        conditionalWeights.needsUpdate = true;
        const totalSumWhole = ~~totalSumValue;
        const totalSumDecimal = totalSumValue - totalSumWhole;
        this.totalSumWhole = totalSumWhole;
        this.totalSumDecimal = totalSumDecimal;
        this.map = map;
        this.worker = null;
        resolve(map);
      };
    });
  }

}

/* eslint-disable camelcase */
class SSGIMaterial extends ShaderMaterial {
  constructor() {
    super({
      type: "SSGIMaterial",
      uniforms: {
        accumulatedTexture: new Uniform(null),
        gBufferTexture: new Uniform(null),
        depthTexture: new Uniform(null),
        velocityTexture: new Uniform(null),
        directLightTexture: new Uniform(null),
        blueNoiseTexture: new Uniform(null),
        projectionMatrix: new Uniform(new Matrix4()),
        projectionMatrixInverse: new Uniform(new Matrix4()),
        cameraMatrixWorld: new Uniform(new Matrix4()),
        viewMatrix: new Uniform(new Matrix4()),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(0),
        nearMulFar: new Uniform(0),
        nearMinusFar: new Uniform(0),
        farMinusNear: new Uniform(0),
        rayDistance: new Uniform(0),
        thickness: new Uniform(0),
        frame: new Uniform(0),
        envBlur: new Uniform(0),
        maxEnvMapMipLevel: new Uniform(0),
        envMapInfo: {
          value: new EquirectHdrInfoUniform()
        },
        envMapPosition: new Uniform(new Vector3()),
        envMapSize: new Uniform(new Vector3()),
        backgroundColor: new Uniform(new Color()),
        resolution: new Uniform(new Vector2()),
        blueNoiseRepeat: new Uniform(new Vector2())
      },
      defines: {
        steps: 20,
        refineSteps: 5,
        CUBEUV_TEXEL_WIDTH: 0,
        CUBEUV_TEXEL_HEIGHT: 0,
        CUBEUV_MAX_MIP: 0,
        vWorldPosition: "worldPos"
      },
      fragmentShader: fragmentShader$6.replace("#include <ssgi_utils>", ssgi_utils).replace("#include <gbuffer_packing>", gbuffer_packing),
      vertexShader,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    });
    useBlueNoise(this);
  }

}

const blackColor = new Color(0);
class SSGIPass extends Pass {
  constructor(ssgiEffect, options) {
    super("SSGIPass");
    this.defaultFragmentShader = "";
    this.frame = 21483;
    this.ssgiEffect = ssgiEffect;
    this._scene = ssgiEffect._scene;
    this._camera = ssgiEffect._camera;
    this.fullscreenMaterial = new SSGIMaterial();
    this.defaultFragmentShader = this.fullscreenMaterial.fragmentShader; // const { mode } = options

    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false
    });
    this.renderTarget.texture.name = "SSGIPass.Texture"; // set up basic uniforms that we don't have to update

    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld;
    this.fullscreenMaterial.uniforms.viewMatrix.value = this._camera.matrixWorldInverse;
    this.fullscreenMaterial.uniforms.projectionMatrix.value = this._camera.projectionMatrix;
    this.fullscreenMaterial.uniforms.projectionMatrixInverse.value = this._camera.projectionMatrixInverse;
    if (ssgiEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "";
    this.fullscreenMaterial.defines.mode = ["ssgi", "ssr"].indexOf(options.mode);
    this.gBufferPass = new GBufferPass(this._scene, this._camera);
    this.fullscreenMaterial.uniforms.gBufferTexture.value = this.gBufferPass.texture;
    this.fullscreenMaterial.uniforms.depthTexture.value = this.gBufferPass.depthTexture;
  }

  get texture() {
    return this.renderTarget.texture;
  }

  setSize(width, height) {
    this.renderTarget.setSize(width * this.ssgiEffect.resolutionScale, height * this.ssgiEffect.resolutionScale);
    this.gBufferPass.setSize(width, height);
    this.fullscreenMaterial.uniforms.resolution.value.set(this.renderTarget.width, this.renderTarget.height);
  }

  dispose() {
    super.dispose();
    this.renderTarget.dispose();
    this.renderTarget.dispose();
    this.fullscreenMaterial.dispose();
  }

  render(renderer) {
    this.frame = (this.frame + 1) % 4096;
    const {
      mask
    } = this._camera.layers;
    const hasSelection = this.ssgiEffect.selection.size > 0;

    this._camera.layers.set(hasSelection ? this.ssgiEffect.selection.layer : 0); // render G-Buffers


    this.gBufferPass.render(renderer);
    this._camera.layers.mask = mask; // update uniforms

    this.fullscreenMaterial.uniforms.frame.value = this.frame;
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
    this.fullscreenMaterial.uniforms.nearMinusFar.value = this._camera.near - this._camera.far;
    this.fullscreenMaterial.uniforms.farMinusNear.value = this._camera.far - this._camera.near;
    this.fullscreenMaterial.uniforms.nearMulFar.value = this._camera.near * this._camera.far;
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssgiEffect.denoiser.texture;
    this.fullscreenMaterial.uniforms.velocityTexture.value = this.ssgiEffect.velocityTexture;
    const bgColor = this._scene.background instanceof Color ? this._scene.background : blackColor;
    this.fullscreenMaterial.uniforms.backgroundColor.value.copy(bgColor);
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
  }

}

// this shader is from: https://github.com/gkjohnson/threejs-sandbox
// a second set of bone information from the previous frame

const prev_skinning_pars_vertex =
/* glsl */
`
		#ifdef USE_SKINNING
		#ifdef BONE_TEXTURE
			uniform sampler2D prevBoneTexture;
			mat4 getPrevBoneMatrix( const in float i ) {
				float j = i * 4.0;
				float x = mod( j, float( boneTextureSize ) );
				float y = floor( j / float( boneTextureSize ) );
				float dx = 1.0 / float( boneTextureSize );
				float dy = 1.0 / float( boneTextureSize );
				y = dy * ( y + 0.5 );
				vec4 v1 = textureLod( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ), 0. );
				vec4 v2 = textureLod( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ), 0. );
				vec4 v3 = textureLod( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ), 0. );
				vec4 v4 = textureLod( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ), 0. );
				mat4 bone = mat4( v1, v2, v3, v4 );
				return bone;
			}
		#else
			uniform mat4 prevBoneMatrices[ MAX_BONES ];
			mat4 getPrevBoneMatrix( const in float i ) {
				mat4 bone = prevBoneMatrices[ int(i) ];
				return bone;
			}
		#endif
		#endif
`;
const velocity_vertex_pars =
/* glsl */
`
#define MAX_BONES 64
                    
${ShaderChunk.skinning_pars_vertex}
${prev_skinning_pars_vertex}

uniform mat4 velocityMatrix;
uniform mat4 prevVelocityMatrix;
varying vec4 prevPosition;
varying vec4 newPosition;

varying vec2 vHighPrecisionZW;
`; // Returns the body of the vertex shader for the velocity buffer

const velocity_vertex_main =
/* glsl */
`
// Get the current vertex position
transformed = vec3( position );
${ShaderChunk.skinning_vertex}
newPosition = velocityMatrix * vec4( transformed, 1.0 );

// Get the previous vertex position
transformed = vec3( position );
${ShaderChunk.skinbase_vertex.replace(/mat4 /g, "").replace(/getBoneMatrix/g, "getPrevBoneMatrix")}
${ShaderChunk.skinning_vertex.replace(/vec4 /g, "")}
prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );

gl_Position = newPosition;

vHighPrecisionZW = gl_Position.zw;
`;
const velocity_fragment_pars =
/* glsl */
`
varying vec4 prevPosition;
varying vec4 newPosition;

varying vec2 vHighPrecisionZW;
`;
const velocity_fragment_main =
/* glsl */
`
vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;
vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;

vec2 vel = pos1 - pos0;

float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

gl_FragColor = vec4(vel.x, vel.y, 0., 0.);
`;
const velocity_uniforms = {
  prevVelocityMatrix: {
    value: new Matrix4()
  },
  velocityMatrix: {
    value: new Matrix4()
  },
  prevBoneTexture: {
    value: null
  },
  boneTexture: {
    value: null
  },
  normalMap: {
    value: null
  },
  normalScale: {
    value: new Vector2(1, 1)
  },
  uvTransform: {
    value: new Matrix3()
  }
};
class VelocityDepthNormalMaterial extends ShaderMaterial {
  constructor(camera) {
    super({
      uniforms: { ...UniformsUtils.clone(velocity_uniforms),
        ...{
          cameraMatrixWorld: {
            value: camera.matrixWorld
          }
        }
      },
      vertexShader:
      /* glsl */
      `
					#include <common>
					#include <uv_pars_vertex>
					#include <displacementmap_pars_vertex>
					#include <normal_pars_vertex>
					#include <morphtarget_pars_vertex>
					#include <logdepthbuf_pars_vertex>
					#include <clipping_planes_pars_vertex>

					varying vec2 vUv;

					varying vec3 vViewPosition;
					
                    ${velocity_vertex_pars}
        
                    void main() {
						vec3 transformed;

						#include <uv_vertex>

						#include <skinbase_vertex>
						#include <beginnormal_vertex>
						#include <skinnormal_vertex>
						#include <defaultnormal_vertex>

						#include <morphnormal_vertex>
						#include <normal_vertex>
						#include <morphtarget_vertex>
						#include <displacementmap_vertex>
						#include <project_vertex>
						#include <logdepthbuf_vertex>
						#include <clipping_planes_vertex>

						${velocity_vertex_main}

						vViewPosition = - mvPosition.xyz;

						vUv = uv;

                    }`,
      fragmentShader:
      /* glsl */
      `
					precision highp float;
					uniform mat4 cameraMatrixWorld;

					varying vec3 vViewPosition;

					${velocity_fragment_pars}
					#include <packing>

					#include <uv_pars_fragment>
					#include <normal_pars_fragment>
					#include <normalmap_pars_fragment>

					varying vec2 vUv;

					// source: https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/
					vec2 OctWrap( vec2 v ) {
						vec2 w = 1.0 - abs( v.yx );
						if (v.x < 0.0) w.x = -w.x;
						if (v.y < 0.0) w.y = -w.y;
						return w;
					}

					vec2 encodeOctWrap(vec3 n) {
						n /= (abs(n.x) + abs(n.y) + abs(n.z));
						n.xy = n.z > 0.0 ? n.xy : OctWrap(n.xy);
						n.xy = n.xy * 0.5 + 0.5;
						return n.xy;
					}

					float packNormal(vec3 normal) {
						return uintBitsToFloat(packHalf2x16(encodeOctWrap(normal)));
					}

                    void main() {
						#define vNormalMapUv vUv

						#include <normal_fragment_begin>
                    	#include <normal_fragment_maps>

						${velocity_fragment_main}
						vec3 worldNormal = normalize((cameraMatrixWorld * vec4(normal, 0.)).xyz);
						gl_FragColor.b = packNormal(worldNormal);
						gl_FragColor.a = fragCoordZ;
                    }`
    });
  }

}

const materialProps = ["vertexTangent", "vertexColors", "vertexAlphas", "vertexUvs", "uvsVertexOnly", "supportsVertexTextures", "instancing", "instancingColor", "side", "flatShading", "skinning", "doubleSided", "flipSided"];
const copyNecessaryProps = (originalMaterial, newMaterial) => {
  for (const props of materialProps) newMaterial[props] = originalMaterial[props];
};
const keepMaterialMapUpdated = (mrtMaterial, originalMaterial, prop, define, useKey) => {
  if (useKey) {
    if (originalMaterial[prop] !== mrtMaterial[prop]) {
      mrtMaterial[prop] = originalMaterial[prop];
      mrtMaterial.uniforms[prop].value = originalMaterial[prop];

      if (originalMaterial[prop]) {
        mrtMaterial.defines[define] = "";
      } else {
        delete mrtMaterial.defines[define];
      }

      mrtMaterial.needsUpdate = true;
    }
  } else if (mrtMaterial[prop] !== undefined) {
    mrtMaterial[prop] = undefined;
    mrtMaterial.uniforms[prop].value = undefined;
    delete mrtMaterial.defines[define];
    mrtMaterial.needsUpdate = true;
  }
};
const getVisibleChildren = object => {
  const queue = [object];
  const objects = [];

  while (queue.length !== 0) {
    const mesh = queue.shift();
    if (mesh.material) objects.push(mesh);

    for (const c of mesh.children) {
      if (c.visible) queue.push(c);
    }
  }

  return objects;
};

const backgroundColor = new Color(0);
const zeroVec2 = new Vector2();
const tmpProjectionMatrix = new Matrix4();
const tmpProjectionMatrixInverse = new Matrix4();

const saveBoneTexture = object => {
  let boneTexture = object.material.uniforms.prevBoneTexture.value;

  if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {
    boneTexture = object.material.uniforms.prevBoneTexture.value;
    boneTexture.image.data.set(object.skeleton.boneTexture.image.data);
  } else {
    var _boneTexture;

    (_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose();
    const boneMatrices = object.skeleton.boneTexture.image.data.slice();
    const size = object.skeleton.boneTexture.image.width;
    boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    object.material.uniforms.prevBoneTexture.value = boneTexture;
    boneTexture.needsUpdate = true;
  }
};

const updateVelocityDepthNormalMaterialBeforeRender = (c, camera) => {
  var _c$skeleton;

  if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) {
    c.material.uniforms.boneTexture.value = c.skeleton.boneTexture;

    if (!("USE_SKINNING" in c.material.defines)) {
      c.material.defines.USE_SKINNING = "";
      c.material.defines.BONE_TEXTURE = "";
      c.material.needsUpdate = true;
    }
  }

  c.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, c.matrixWorld);
  c.material.uniforms.velocityMatrix.value.multiplyMatrices(camera.projectionMatrix, c.modelViewMatrix);
};

const updateVelocityDepthNormalMaterialAfterRender = (c, camera) => {
  var _c$skeleton2;

  c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(camera.projectionMatrix, c.modelViewMatrix);
  if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) saveBoneTexture(c);
};

class VelocityDepthNormalPass extends Pass {
  constructor(scene, camera) {
    super("VelocityDepthNormalPass");
    this.cachedMaterials = new WeakMap();
    this.visibleMeshes = [];
    this.needsSwap = false;
    this._scene = scene;
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.renderTarget.texture.name = "VelocityDepthNormalPass.Texture";
    this.renderTarget.depthTexture = new DepthTexture(1, 1);
    this.renderTarget.depthTexture.type = FloatType;
  }

  get texture() {
    return this.renderTarget.texture;
  }

  setVelocityDepthNormalMaterialInScene() {
    this.visibleMeshes = getVisibleChildren$1(this._scene);

    for (const c of this.visibleMeshes) {
      const originalMaterial = c.material;
      let [cachedOriginalMaterial, velocityDepthNormalMaterial] = this.cachedMaterials.get(c) || [];

      if (originalMaterial !== cachedOriginalMaterial) {
        var _c$skeleton3;

        velocityDepthNormalMaterial = new VelocityDepthNormalMaterial(this._camera);
        copyNecessaryProps(originalMaterial, velocityDepthNormalMaterial);
        c.material = velocityDepthNormalMaterial;
        if ((_c$skeleton3 = c.skeleton) != null && _c$skeleton3.boneTexture) saveBoneTexture(c);
        this.cachedMaterials.set(c, [originalMaterial, velocityDepthNormalMaterial]);
      }

      c.material = velocityDepthNormalMaterial;
      c.visible = isChildMaterialRenderable(c, originalMaterial);
      keepMaterialMapUpdated(velocityDepthNormalMaterial, originalMaterial, "normalMap", "USE_NORMALMAP_TANGENTSPACE", true);
      velocityDepthNormalMaterial.uniforms.normalMap.value = originalMaterial.normalMap;
      const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap;
      if (map) velocityDepthNormalMaterial.uniforms.uvTransform.value = map.matrix;
      updateVelocityDepthNormalMaterialBeforeRender(c, this._camera);
    }
  }

  unsetVelocityDepthNormalMaterialInScene() {
    for (const c of this.visibleMeshes) {
      c.visible = true;
      updateVelocityDepthNormalMaterialAfterRender(c, this._camera);
      c.material = this.cachedMaterials.get(c)[0];
    }
  }

  setSize(width, height) {
    var _this$lastVelocityTex;

    this.renderTarget.setSize(width, height);
    (_this$lastVelocityTex = this.lastVelocityTexture) == null ? void 0 : _this$lastVelocityTex.dispose();
    this.lastVelocityTexture = new FramebufferTexture(width, height, RGBAFormat);
    this.lastVelocityTexture.type = FloatType;
    this.lastVelocityTexture.minFilter = NearestFilter;
    this.lastVelocityTexture.magFilter = NearestFilter;
  }

  dispose() {
    super.dispose();
    this.renderTarget.dispose();
  }

  render(renderer) {
    tmpProjectionMatrix.copy(this._camera.projectionMatrix);
    tmpProjectionMatrixInverse.copy(this._camera.projectionMatrixInverse);
    if (this._camera.view) this._camera.view.enabled = false;

    this._camera.updateProjectionMatrix(); // in case a RenderPass is not being used, so we need to update the camera's world matrix manually


    this._camera.updateMatrixWorld();

    this.setVelocityDepthNormalMaterialInScene();
    const {
      background
    } = this._scene;
    this._scene.background = backgroundColor;
    renderer.setRenderTarget(this.renderTarget);
    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture);
    renderer.render(this._scene, this._camera);
    this._scene.background = background;
    this.unsetVelocityDepthNormalMaterialInScene();
    if (this._camera.view) this._camera.view.enabled = true;

    this._camera.projectionMatrix.copy(tmpProjectionMatrix);

    this._camera.projectionMatrixInverse.copy(tmpProjectionMatrixInverse);
  }

}

var ssgi_poisson_compose_functions = "#define GLSLIFY 1\nfloat getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 getViewPosition(float viewZ){float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,viewZ)-0.5)*2.0,1.0);clipPosition*=clipW;vec3 p=(projectionMatrixInverse*clipPosition).xyz;p.z=-viewZ;return p;}vec3 F_Schlick(const vec3 f0,const float theta){return f0+(1.-f0)*pow(1.0-theta,5.);}vec3 SampleGGXVNDF(const vec3 V,const float ax,const float ay,const float r1,const float r2){vec3 Vh=normalize(vec3(ax*V.x,ay*V.y,V.z));float lensq=Vh.x*Vh.x+Vh.y*Vh.y;vec3 T1=lensq>0. ? vec3(-Vh.y,Vh.x,0.)*inversesqrt(lensq): vec3(1.,0.,0.);vec3 T2=cross(Vh,T1);float r=sqrt(r1);float phi=2.0*PI*r2;float t1=r*cos(phi);float t2=r*sin(phi);float s=0.5*(1.0+Vh.z);t2=(1.0-s)*sqrt(1.0-t1*t1)+s*t2;vec3 Nh=t1*T1+t2*T2+sqrt(max(0.0,1.0-t1*t1-t2*t2))*Vh;return normalize(vec3(ax*Nh.x,ay*Nh.y,max(0.0,Nh.z)));}void Onb(const vec3 N,inout vec3 T,inout vec3 B){vec3 up=abs(N.z)<0.9999999 ? vec3(0,0,1): vec3(1,0,0);T=normalize(cross(up,N));B=cross(N,T);}vec3 ToLocal(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return vec3(dot(V,X),dot(V,Y),dot(V,Z));}vec3 ToWorld(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return V.x*X+V.y*Y+V.z*Z;}vec3 constructGlobalIllumination(vec3 diffuseGi,vec3 specularGi,vec3 cameraRay,vec3 viewNormal,vec3 diffuse,vec3 emissive,float roughness,float metalness){roughness*=roughness;vec3 normal=(vec4(viewNormal,0.)*viewMatrix).xyz;vec3 T,B;vec3 v=-cameraRay;vec3 V=(vec4(v,0.)*viewMatrix).xyz;vec3 N=normal;Onb(N,T,B);V=ToLocal(T,B,N,V);vec3 H=SampleGGXVNDF(V,roughness,roughness,0.25,0.25);if(H.z<0.0)H=-H;vec3 l=normalize(reflect(-V,H));l=ToWorld(T,B,N,l);l=(vec4(l,1.)*cameraMatrixWorld).xyz;l=normalize(l);if(dot(viewNormal,l)<0.)l=-l;vec3 h=normalize(v+l);float VoH=max(EPSILON,dot(v,h));vec3 f0=mix(vec3(0.04),diffuse,metalness);vec3 F=F_Schlick(f0,VoH);\n#if inputType != TYPE_SPECULAR\nvec3 diffuseComponent=diffuse*(1.-metalness)*(1.-F)*diffuseGi;\n#else\nvec3 diffuseComponent=textureLod(sceneTexture,vUv,0.).rgb;\n#endif\nvec3 specularComponent=specularGi*F;vec3 globalIllumination=diffuseComponent+specularComponent+emissive;return globalIllumination;}"; // eslint-disable-line

/* eslint-disable camelcase */
class DenoiserComposePass extends Pass {
  constructor(camera, textures, gBufferTexture, depthTexture, options = {}) {
    var _indexOf;

    super("DenoiserComposePass");
    this._camera = camera;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      depthBuffer: false,
      type: FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.renderTarget.texture.name = "DenoiserComposePass.Texture";
    let diffuseGiTexture;
    let specularGiTexture;

    if (options.inputType === "diffuseSpecular") {
      diffuseGiTexture = textures[0];
      specularGiTexture = textures[1];
    } else if (options.inputType === "diffuse") {
      diffuseGiTexture = textures[0];
    } else if (options.inputType === "specular") {
      specularGiTexture = textures[0];
    }

    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader:
      /* glsl */
      `
            varying vec2 vUv;
            uniform sampler2D sceneTexture;
            uniform highp sampler2D depthTexture;
            uniform sampler2D diffuseGiTexture;
            uniform sampler2D specularGiTexture;
            uniform mat4 cameraMatrixWorld;
            uniform mat4 projectionMatrix;
            uniform mat4 projectionMatrixInverse;
			uniform float cameraNear;
			uniform float cameraFar;

            #include <common>
            #include <packing>

			#define TYPE_DIFFUSE_SPECULAR 0
			#define TYPE_DIFFUSE 1
			#define TYPE_SPECULAR 2

            ${gbuffer_packing}
            ${ssgi_poisson_compose_functions}

            void main() {
                float depth = textureLod(depthTexture, vUv, 0.).r;

				if(depth == 1.){
					discard;
					return;
				}

				// on Android there's a bug where using "vec3 normal = unpackNormal(textureLod(velocityTexture, vUv, 0.).b);" instead of
				// "vec3 normal = unpackNormal(velocity.b);" causes the normal to be distorted (possibly due to packHalf2x16 function)

                Material mat = getMaterial(gBufferTexture, vUv);

                vec3 viewNormal = (vec4(mat.normal, 0.) * cameraMatrixWorld).xyz;

				float viewZ = -getViewZ(depth);

                // view-space position of the current texel
				vec3 viewPos = getViewPosition(viewZ);
                vec3 viewDir = normalize(viewPos);

                vec4 diffuseGi = textureLod(diffuseGiTexture, vUv, 0.);
                vec4 specularGi = textureLod(specularGiTexture, vUv, 0.);

                vec3 gi = constructGlobalIllumination(diffuseGi.rgb, specularGi.rgb, viewDir, viewNormal, mat.diffuse.rgb, mat.emissive, mat.roughness, mat.metalness);

				gl_FragColor = vec4(gi, 1.);
            }
            `,
      vertexShader: vertexShader,
      uniforms: {
        sceneTexture: {
          value: null
        },
        viewMatrix: {
          value: camera.matrixWorldInverse
        },
        cameraMatrixWorld: {
          value: camera.matrixWorld
        },
        projectionMatrix: {
          value: camera.projectionMatrix
        },
        projectionMatrixInverse: {
          value: camera.projectionMatrixInverse
        },
        cameraNear: {
          value: camera.near
        },
        cameraFar: {
          value: camera.far
        },
        gBufferTexture: {
          value: gBufferTexture
        },
        depthTexture: {
          value: depthTexture
        },
        diffuseGiTexture: {
          value: diffuseGiTexture
        },
        specularGiTexture: {
          value: specularGiTexture
        }
      },
      defines: {
        inputType: (_indexOf = ["diffuseSpecular", "diffuse", "specular"].indexOf(options.inputType)) !== null && _indexOf !== void 0 ? _indexOf : 0
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    });
    if (camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = "";
  }

  get texture() {
    return this.renderTarget.texture;
  }

  dispose() {
    this.renderTarget.dispose();
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }

  setSceneTexture(texture) {
    this.fullscreenMaterial.uniforms.sceneTexture.value = texture;
  }

  render(renderer) {
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
  }

}

var fragmentShader$5 = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform highp sampler2D depthTexture;uniform sampler2D normalTexture;uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;uniform float radius;uniform float phi;uniform float lumaPhi;uniform float depthPhi;uniform float normalPhi;uniform float roughnessPhi;uniform float specularPhi;uniform vec2 resolution;layout(location=0)out vec4 gOutput0;\n#if textureCount == 2\nuniform sampler2D inputTexture2;layout(location=1)out vec4 gOutput1;\n#endif\n#include <common>\n#include <gbuffer_packing>\n#define luminance(a) pow(dot(vec3(0.2125, 0.7154, 0.0721), a), 0.125)\n#if textureCount == 1\n#define inputTexture2 inputTexture\n#endif\nMaterial mat;vec3 normal;float depth;float glossiness;float specularFactor;struct InputTexel{vec3 rgb;float a;float luminance;float w;float totalWeight;bool isSpecular;};void toDenoiseSpace(inout vec3 color){color=log(color+1.);}void toLinearSpace(inout vec3 color){color=exp(color)-1.;}float getBasicNeighborWeight(inout vec2 neighborUv){\n#ifdef GBUFFER_TEXTURE\nMaterial neighborMat=getMaterial(gBufferTexture,neighborUv);vec3 neighborNormal=neighborMat.normal;float neighborDepth=textureLod(depthTexture,neighborUv,0.0).r;\n#else\nvec3 neighborDepthVelocityTexel=textureLod(normalTexture,neighborUv,0.).xyz;vec3 neighborNormal=unpackNormal(neighborDepthVelocityTexel.b);float neighborDepth=neighborDepthVelocityTexel.a;\n#endif\nif(neighborDepth==1.0)return 0.;float normalDiff=1.-max(dot(normal,neighborNormal),0.);float depthDiff=10000.*abs(depth-neighborDepth);\n#ifdef GBUFFER_TEXTURE\nfloat roughnessDiff=abs(mat.roughness-neighborMat.roughness);float wBasic=exp(-normalDiff*normalPhi-depthDiff*depthPhi-roughnessDiff*roughnessPhi);\n#else\nfloat wBasic=exp(-normalDiff*normalPhi-depthDiff*depthPhi);\n#endif\nreturn wBasic;}vec3 getNormal(Material mat){\n#ifdef GBUFFER_TEXTURE\nreturn mat.normal;\n#else\nvec3 depthVelocityTexel=textureLod(normalTexture,vUv,0.).xyz;return unpackNormal(depthVelocityTexel.b);\n#endif\n}const vec2 VOGEL[64]=vec2[64](vec2(-0.8858256694307908,0.11039874717355916),vec2(0.5786055880516664,-0.26733045744057155),vec2(-0.7672635753829038,-0.07110981571233982),vec2(0.3759135641688252,-0.37408420479070015),vec2(-0.5954329857479317,-0.1899593627155645),vec2(0.6218140149124645,-0.47193466799806244),vec2(-0.06221497017514103,-0.4801086309223219),vec2(-0.09217110975978997,0.08443628678269048),vec2(-0.30125974586790694,0.9286374779856799),vec2(0.7263803908706608,-0.060179130590147525),vec2(0.12407653552140382,0.39557554693510294),vec2(0.13173087756434085,0.1718196027702562),vec2(0.3044598633838641,0.5313230576478671),vec2(0.8189188737699155,-0.2524814412653198),vec2(0.5842520778248396,-0.6864033140635013),vec2(0.5398828029871907,0.7840768833722203),vec2(-0.437881804270381,0.7471676689264035),vec2(-0.3581673004861461,-0.42920412959624094),vec2(0.9258154000939673,0.04733756382459124),vec2(-0.7211110218604363,0.5958178363823942),vec2(-0.4812708600359053,0.33485572905402117),vec2(0.3161598772626051,0.7766388684641624),vec2(-0.9356925873941437,-0.21530067788015092),vec2(-0.7661115267608417,-0.363074549595771),vec2(-0.5677230447829313,-0.4396766362025594),vec2(0.5108647397618087,0.5631538135075527),vec2(0.44018182266498107,-0.09677273890582583),vec2(-0.14149894660914825,0.777803347966889),vec2(-0.6447488862874866,-0.6542544410480113),vec2(0.16753984018648072,-0.35802290701893436),vec2(-0.5149480895113892,0.021294720204086372),vec2(0.130404621326362,-0.9346762191993162),vec2(0.13157445867645465,-0.584861660415519),vec2(0.7812833956192815,0.21411738773300346),vec2(0.0036587078725838114,-0.749991075851375),vec2(0.595861375743875,0.31316803939197974),vec2(-0.2507540284511754,0.5991639318379463),vec2(-0.2238651405383096,-0.622402119896585),vec2(-0.18370833162606243,-0.8554976615345997),vec2(-0.5021859490837312,0.5428482960670248),vec2(0.1197670401489102,0.6968901320107563),vec2(0.2882286396384206,-0.7774472659236673),vec2(-0.2689921596114732,0.38261366685934745),vec2(0.7205834015598361,0.5118686954644287),vec2(0.3321002291718612,0.12128247105001326),vec2(0.3823244977280216,0.32222349144191215),vec2(-0.15243067061428453,-0.2934959806472305),vec2(0.567706325350643,0.07638408313824151),vec2(-0.24617837132885717,-0.04354548759482791),vec2(0.3764071357129037,-0.5853995799318681),vec2(-0.6620391053587746,0.17451138351337778),vec2(0.8424338915846228,-0.47728936538497074),vec2(0,0),vec2(0.23583677444698697,-0.15002005138794278),vec2(0.033163833687322425,0.9094092368868701),vec2(-0.07948726025481911,0.29568864614182033),vec2(-0.02516798061375822,0.544280784845309),vec2(0.9133585918338107,0.3874933324889068),vec2(0.015454830699377673,-0.17609982455429526),vec2(-0.4084534119550491,-0.8954975210810351),vec2(-0.7292579037700506,0.3742431158871351),vec2(-0.3466295835516768,0.1430836531781011),vec2(-0.42629247348014454,-0.6774213807182204),vec2(-0.37464744364268177,-0.21711585149869544));void outputTexel(inout vec4 outputFrag,InputTexel inp){inp.rgb/=inp.totalWeight;outputFrag.rgb=inp.rgb;toLinearSpace(outputFrag.rgb);outputFrag.a=inp.a;}void applyWeight(inout InputTexel inp,vec2 neighborUv,float wBasic){float w=wBasic;float disocclW=pow(w,0.1);vec4 t;if(inp.isSpecular){t=textureLod(inputTexture2,neighborUv,0.);w*=specularFactor;disocclW*=specularFactor;}else{t=textureLod(inputTexture,neighborUv,0.);}float lumaDiff=abs(inp.luminance-luminance(t.rgb));float lumaFactor=exp(-lumaDiff*lumaPhi);w=mix(w*lumaFactor,disocclW,pow(inp.w,3.))*inp.w;if(w>0.01){toDenoiseSpace(t.rgb);inp.rgb+=w*t.rgb;inp.totalWeight+=w;}}void main(){depth=textureLod(depthTexture,vUv,0.).r;if(depth==1.0&&fwidth(depth)==0.){discard;return;}InputTexel[textureCount]inputs;float maxAlpha=0.;\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){{vec4 t;if(isTextureSpecular[i]){t=textureLod(inputTexture2,vUv,0.);}else{t=textureLod(inputTexture,vUv,0.);}float age=1./log(exp(t.a*phi)+1.718281828459045);InputTexel inp=InputTexel(t.rgb,t.a,luminance(t.rgb),age,1.,isTextureSpecular[i]);maxAlpha=max(maxAlpha,inp.a);toDenoiseSpace(inp.rgb);inputs[i]=inp;}}\n#pragma unroll_loop_end\nmat=getMaterial(gBufferTexture,vUv);normal=getNormal(mat);glossiness=max(0.,4.*(1.-mat.roughness/0.25));specularFactor=exp(-glossiness*specularPhi);float flatness=1.-min(length(fwidth(normal)),1.);flatness=pow(flatness,2.)*0.75+0.25;float roughnessRadius=mix(sqrt(mat.roughness),1.,0.5*(1.-mat.metalness));vec4 random=blueNoise();float r=radius*roughnessRadius*exp(-maxAlpha*0.01);float angle=random.r*2.*PI;float s=sin(angle),c=cos(angle);mat2 rm=mat2(c,-s,s,c)*r;int index=blueNoiseIndex;for(int i=0;i<8;i++){{index++;index=index % VOGEL.length();vec2 offset=VOGEL[index];vec2 neighborUv=vUv+flatness*rm*(offset/resolution);float wBasic=getBasicNeighborWeight(neighborUv);applyWeight(inputs[0],neighborUv,wBasic);\n#if textureCount == 2\napplyWeight(inputs[1],neighborUv,wBasic);\n#endif\n}}outputTexel(gOutput0,inputs[0]);\n#if textureCount == 2\noutputTexel(gOutput1,inputs[1]);\n#endif\n}"; // eslint-disable-line

/* eslint-disable camelcase */
const finalFragmentShader$1 = fragmentShader$5.replace("#include <gbuffer_packing>", gbuffer_packing);
const defaultPoissonBlurOptions = {
  iterations: 1,
  radius: 3,
  phi: 0.5,
  lumaPhi: 5,
  depthPhi: 2,
  normalPhi: 3.25,
  inputType: "diffuseSpecular" // can be "diffuseSpecular", "diffuse" or "specular"

};
class PoissonDenoisePass extends Pass {
  constructor(camera, textures, options = defaultPoissonBlurOptions) {
    super("PoissonBlurPass");
    this.iterations = defaultPoissonBlurOptions.iterations;
    this.index = 0;
    options = { ...defaultPoissonBlurOptions,
      ...options
    };
    this.textures = textures;
    let isTextureSpecular = [false, true];
    if (options.inputType === "diffuse") isTextureSpecular = [false, false];
    if (options.inputType === "specular") isTextureSpecular = [true, true];
    const textureCount = options.inputType === "diffuseSpecular" ? 2 : 1;
    const fragmentShader = unrollLoops(finalFragmentShader$1.replaceAll("textureCount", textureCount));
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader,
      vertexShader,
      uniforms: {
        depthTexture: {
          value: null
        },
        inputTexture: {
          value: textures[0]
        },
        inputTexture2: {
          value: textures[1]
        },
        gBufferTexture: {
          value: null
        },
        normalTexture: {
          value: null
        },
        projectionMatrix: {
          value: camera.projectionMatrix
        },
        projectionMatrixInverse: {
          value: camera.projectionMatrixInverse
        },
        cameraMatrixWorld: {
          value: camera.matrixWorld
        },
        viewMatrix: {
          value: camera.matrixWorldInverse
        },
        radius: {
          value: defaultPoissonBlurOptions.radius
        },
        phi: {
          value: defaultPoissonBlurOptions.phi
        },
        lumaPhi: {
          value: defaultPoissonBlurOptions.lumaPhi
        },
        depthPhi: {
          value: defaultPoissonBlurOptions.depthPhi
        },
        normalPhi: {
          value: defaultPoissonBlurOptions.normalPhi
        },
        roughnessPhi: {
          value: defaultPoissonBlurOptions.roughnessPhi
        },
        specularPhi: {
          value: defaultPoissonBlurOptions.specularPhi
        },
        resolution: {
          value: new Vector2()
        }
      },
      defines: {
        isTextureSpecular: "bool[2](" + isTextureSpecular.join(",") + ")"
      },
      glslVersion: GLSL3
    });
    useBlueNoise(this.fullscreenMaterial);
    const renderTargetOptions = {
      type: HalfFloatType,
      // using HalfFloatType as FloatType with bilinear filtering isn't supported on some Apple devices
      depthBuffer: false
    };
    this.renderTargetA = new WebGLMultipleRenderTargets(1, 1, textureCount, renderTargetOptions);
    this.renderTargetB = new WebGLMultipleRenderTargets(1, 1, textureCount, renderTargetOptions); // give the textures of renderTargetA and renderTargetB names

    this.renderTargetB.texture[0].name = "PoissonDenoisePass." + (isTextureSpecular[0] ? "specular" : "diffuse");

    if (textureCount > 1) {
      this.renderTargetB.texture[1].name = "PoissonDenoisePass." + (isTextureSpecular[1] ? "specular" : "diffuse");
    }

    const {
      uniforms
    } = this.fullscreenMaterial;
    uniforms["depthPhi"].value = options.depthPhi;
    uniforms["normalPhi"].value = options.normalPhi;
  }

  setSize(width, height) {
    this.renderTargetA.setSize(width, height);
    this.renderTargetB.setSize(width, height);
    this.fullscreenMaterial.uniforms.resolution.value.set(width, height);
  }

  get texture() {
    return this.renderTargetB.texture;
  } // can either be a GBufferPass or a VelocityDepthNormalPass


  setGBufferPass(gBufferPass) {
    if (gBufferPass instanceof GBufferPass) {
      this.fullscreenMaterial.uniforms.gBufferTexture.value = gBufferPass.texture;
      this.fullscreenMaterial.defines.GBUFFER_TEXTURE = "";
    } else {
      this.fullscreenMaterial.uniforms.normalTexture.value = gBufferPass.texture;
    }

    this.fullscreenMaterial.uniforms.depthTexture.value = gBufferPass.renderTarget.depthTexture;
  }

  setnNormalTexture(texture) {
    this.fullscreenMaterial.uniforms.normalTexture.value = texture;
  }

  setDepthTexture(texture) {
    this.fullscreenMaterial.uniforms.depthTexture.value = texture;
  }

  dispose() {
    super.dispose();
    this.renderTargetA.dispose();
    this.renderTargetB.dispose();
    this.fullscreenMaterial.dispose();
  }

  render(renderer) {
    for (let i = 0; i < 2 * this.iterations; i++) {
      const horizontal = i % 2 === 0;
      const inputRenderTarget = horizontal ? this.renderTargetB : this.renderTargetA;
      this.fullscreenMaterial.uniforms["inputTexture"].value = i === 0 ? this.textures[0] : inputRenderTarget.texture[0];
      this.fullscreenMaterial.uniforms["inputTexture2"].value = i === 0 ? this.textures[1] : inputRenderTarget.texture[1];
      const renderTarget = horizontal ? this.renderTargetA : this.renderTargetB;
      renderer.setRenderTarget(renderTarget);
      renderer.render(this.scene, this.camera);
    }
  }

}
PoissonDenoisePass.DefaultOptions = defaultPoissonBlurOptions;

const defaultDenosierOptions = {
  denoiseMode: "full",
  // can be "full" | "full_temporal" | "denoised" | "temporal"
  inputType: "diffuseSpecular",
  // can be "diffuseSpecular" | "diffuse" | "specular"
  gBufferPass: null,
  velocityDepthNormalPass: null
}; // a spatio-temporal denoiser
// temporal: temporal reprojection to reproject previous frames
// spatial: poisson denoiser to denoise the current frame recurrently

class Denoiser {
  constructor(scene, camera, texture, options = defaultDenosierOptions) {
    var _options$velocityDept, _this$denoisePass$tex, _this$denoisePass;

    options = { ...defaultDenosierOptions,
      ...options
    };
    this.options = options;
    this.velocityDepthNormalPass = (_options$velocityDept = options.velocityDepthNormalPass) !== null && _options$velocityDept !== void 0 ? _options$velocityDept : new VelocityDepthNormalPass(scene, camera);
    this.isOwnVelocityDepthNormalPass = !options.velocityDepthNormalPass;
    const textureCount = options.inputType === "diffuseSpecular" ? 2 : 1;
    this.temporalReprojectPass = new TemporalReprojectPass(scene, camera, this.velocityDepthNormalPass, texture, textureCount, {
      fullAccumulate: true,
      logTransform: true,
      copyTextures: !options.denoise,
      reprojectSpecular: [false, true],
      neighborhoodClamp: [true, true],
      neighborhoodClampRadius: 2,
      neighborhoodClampIntensity: 0.5,
      ...options
    });
    const textures = this.temporalReprojectPass.renderTarget.texture.slice(0, textureCount);

    if (this.options.denoiseMode === "full" || this.options.denoiseMode === "denoised") {
      var _options$gBufferPass;

      this.denoisePass = new PoissonDenoisePass(camera, textures, options);
      this.denoisePass.setGBufferPass((_options$gBufferPass = options.gBufferPass) !== null && _options$gBufferPass !== void 0 ? _options$gBufferPass : this.velocityDepthNormalPass);
      this.temporalReprojectPass.overrideAccumulatedTextures = this.denoisePass.renderTargetB.texture;
    }

    const composerInputTextures = (_this$denoisePass$tex = (_this$denoisePass = this.denoisePass) == null ? void 0 : _this$denoisePass.texture) !== null && _this$denoisePass$tex !== void 0 ? _this$denoisePass$tex : textures;

    if (options.denoiseMode.startsWith("full")) {
      this.denoiserComposePass = new DenoiserComposePass(camera, composerInputTextures, options.gBufferPass.texture, options.gBufferPass.renderTarget.depthTexture, options);
    }
  }

  get texture() {
    switch (this.options.denoiseMode) {
      case "full":
      case "full_temporal":
        return this.denoiserComposePass.texture;

      case "denoised":
        return this.denoisePass.texture;

      case "temporal":
        return this.temporalReprojectPass.texture;
    }
  }

  reset() {
    this.temporalReprojectPass.reset();
  }

  setSize(width, height) {
    var _this$denoisePass2, _this$denoiserCompose;

    this.velocityDepthNormalPass.setSize(width, height);
    this.temporalReprojectPass.setSize(width, height);
    (_this$denoisePass2 = this.denoisePass) == null ? void 0 : _this$denoisePass2.setSize(width, height);
    (_this$denoiserCompose = this.denoiserComposePass) == null ? void 0 : _this$denoiserCompose.setSize(width, height);
  }

  dispose() {
    var _this$denoisePass3, _this$denoiserCompose2;

    this.velocityDepthNormalPass.dispose();
    this.temporalReprojectPass.dispose();
    (_this$denoisePass3 = this.denoisePass) == null ? void 0 : _this$denoisePass3.dispose();
    (_this$denoiserCompose2 = this.denoiserComposePass) == null ? void 0 : _this$denoiserCompose2.dispose();
  }

  render(renderer, inputBuffer = null) {
    var _this$denoisePass4, _this$denoiserCompose4;

    if (this.isOwnVelocityDepthNormalPass) this.velocityDepthNormalPass.render(renderer);
    this.temporalReprojectPass.render(renderer);

    if (this.options.inputType !== "diffuseSpecular") {
      var _this$denoiserCompose3;

      (_this$denoiserCompose3 = this.denoiserComposePass) == null ? void 0 : _this$denoiserCompose3.setSceneTexture(inputBuffer.texture);
    }

    (_this$denoisePass4 = this.denoisePass) == null ? void 0 : _this$denoisePass4.render(renderer);
    (_this$denoiserCompose4 = this.denoiserComposePass) == null ? void 0 : _this$denoiserCompose4.render(renderer);
  }

}

/* eslint-disable camelcase */
class GBufferDebugPass extends Pass {
  constructor(gBufferTexture) {
    super("GBufferDebugPass");
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      depthBuffer: false,
      type: FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    this.renderTarget.texture.name = "GBufferDebugPass.Texture";
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader:
      /* glsl */
      `
            varying vec2 vUv;
            uniform highp sampler2D depthTexture;
			uniform int mode;

            #include <common>
            #include <packing>

            ${gbuffer_packing}

            void main() {
                highp float depth = textureLod(depthTexture, vUv, 0.).r;

				if(depth == 0.){
					gl_FragColor = vec4(0.);
					return;
				}

                Material mat = getMaterial(gBufferTexture, vUv);

                if (mode == 0) {
                    gl_FragColor = vec4(mat.diffuse.rgb, 1.);
                } else if (mode == 1) {
                    gl_FragColor = vec4(mat.diffuse.aaa, 1.);
                } else if (mode == 2) {
                    gl_FragColor = vec4(mat.normal, 1.);
                } else if (mode == 3) {
                    gl_FragColor = vec4(vec3(mat.roughness), 1.);
                } else if (mode == 4) {
                    gl_FragColor = vec4(vec3(mat.metalness), 1.);
                } else {
                    gl_FragColor = vec4(mat.emissive, 1.);
                }
            }
            `,
      vertexShader: vertexShader,
      uniforms: {
        gBufferTexture: {
          value: gBufferTexture
        },
        mode: {
          value: 0
        }
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    });
  }

  get texture() {
    return this.renderTarget.texture;
  }

  dispose() {
    this.renderTarget.dispose();
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height);
  }

  render(renderer) {
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
  }

}

/* eslint-disable max-len */

/**
 * Options of the SSGI effect
 * @typedef {Object} SSGIOptions
 * @property {Number} [distance] maximum distance a SSGI ray can travel to find what it reflects
 * @property {Number} [thickness] maximum depth difference between a ray and the particular depth at its screen position before refining with binary search; higher values will result in better performance
 * @property {Number} [envBlur] higher values will result in lower mipmaps being sampled which will cause less noise but also less detail regarding environment lighting
 * @property {Number} [importanceSampling] whether to use importance sampling for the environment map
 * @property {Number} [denoiseIterations] how many times the denoise filter runs, more iterations will denoise the frame better but need more performance
 * @property {Number} [radius] the radius of the denoiser, higher values will result in less noise on less detailled surfaces but more noise on detailled surfaces
 * @property {Number} [depthPhi] depth factor of the denoiser, higher values will use neighboring areas with different depth values more resulting in less noise but loss of details
 * @property {Number} [normalPhi] normals factor of the denoiser, higher values will use neighboring areas with different normals more resulting in less noise but loss of details and sharpness
 * @property {Number} [roughnessPhi] roughness factor of the denoiser setting how much the denoiser should only apply the blur to rougher surfaces, a value of 0 means the denoiser will blur mirror-like surfaces the same as rough surfaces
 * @property {Number} [specularPhi] specular factor of the denoiser setting how much the denoiser will blur specular reflections
 * @property {Number} [lumaPhi] luminance factor of the denoiser setting how aggressive the denoiser is on areas with different luminance
 * @property {Number} [steps] number of steps a SSGI ray can maximally do to find an object it intersected (and thus reflects)
 * @property {Number} [refineSteps] once we had our ray intersect something, we need to find the exact point in space it intersected and thus it reflects; this can be done through binary search with the given number of maximum steps
 * @property {boolean} [missedRays] if there should still be SSGI for rays for which a reflecting point couldn't be found; enabling this will result in stretched looking SSGI which can look good or bad depending on the angle
 * @property {Number} [resolutionScale] resolution of the SSGI effect, a resolution of 0.5 means the effect will be rendered at half resolution
 */

/**
 * The options of the SSGI effect
 * @type {SSGIOptions}
 */
const defaultSSGIOptions = {
  mode: "ssgi",
  distance: 10,
  thickness: 10,
  denoiseIterations: 1,
  denoiseKernel: 2,
  denoiseDiffuse: 10,
  denoiseSpecular: 10,
  radius: 3,
  phi: 0.5,
  lumaPhi: 5,
  depthPhi: 2,
  normalPhi: 50,
  roughnessPhi: 50,
  specularPhi: 50,
  envBlur: 0.5,
  importanceSampling: true,
  steps: 20,
  refineSteps: 5,
  resolutionScale: 1,
  missedRays: false,
  outputTexture: null
};

var ssgi_compose = "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D sceneTexture;uniform highp sampler2D depthTexture;uniform bool isDebug;uniform float cameraNear;uniform float cameraFar;\n#include <fog_pars_fragment>\nfloat getViewZ(const in float depth){\n#if PERSPECTIVE_CAMERA == 1\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){if(isDebug){outputColor=textureLod(inputTexture,uv,0.);return;}float depth=textureLod(depthTexture,uv,0.).r;vec3 ssgiClr;if(depth==1.0){ssgiClr=textureLod(sceneTexture,uv,0.).rgb;}else{ssgiClr=textureLod(inputTexture,uv,0.).rgb;\n#ifdef USE_FOG\nfloat viewZ=getViewZ(depth)*0.4;vFogDepth=-viewZ;\n#include <fog_fragment>\nssgiClr=mix(ssgiClr,fogColor,fogFactor);\n#endif\n}outputColor=vec4(ssgiClr,1.0);}"; // eslint-disable-line

const {
  render
} = RenderPass.prototype;
const globalIblRadianceDisabledUniform = createGlobalDisableIblRadianceUniform();
class SSGIEffect extends Effect {
  constructor(composer, scene, camera, options) {
    var _scene$fog;

    options = { ...defaultSSGIOptions,
      ...options
    };
    let fragmentShader = ssgi_compose.replace("#include <fog_pars_fragment>", ShaderChunk.fog_pars_fragment.replace("varying", "")); // delete the line starting with gl_FragColor using a regex

    fragmentShader = fragmentShader.replace("#include <fog_fragment>", ShaderChunk.fog_fragment.replace(/.*gl_FragColor.*/g, ""));
    const defines = new Map();
    if (scene.fog) defines.set("USE_FOG", "");
    if ((_scene$fog = scene.fog) != null && _scene$fog.isFogExp2) defines.set("FOG_EXP2", "");
    super("SSGIEffect", fragmentShader, {
      type: "FinalSSGIMaterial",
      uniforms: new Map([["inputTexture", new Uniform(null)], ["sceneTexture", new Uniform(null)], ["depthTexture", new Uniform(null)], ["isDebug", new Uniform(false)], ["fogColor", new Uniform(new Color())], ["fogNear", new Uniform(0)], ["fogFar", new Uniform(0)], ["fogDensity", new Uniform(0)], ["cameraNear", new Uniform(0)], ["cameraFar", new Uniform(0)]]),
      defines: new Map([["PERSPECTIVE_CAMERA", camera.isPerspectiveCamera ? "1" : "0"], ...defines])
    });
    this.selection = new Selection();
    this.isUsingRenderPass = true;
    this._scene = scene;
    this._camera = camera;
    this.composer = composer;

    if (options.mode === "ssr") {
      options.reprojectSpecular = true;
      options.neighborhoodClamp = true;
      options.inputType = "specular";
    } else if (options.mode === "ssgi") {
      options.reprojectSpecular = [false, true];
      options.neighborhoodClamp = [false, true];
    }

    if (typeof options.preset === "string") {
      switch (options.preset) {
        case "low":
          options.steps = 10;
          options.refineSteps = 2;
          options.denoiseMode = "full_temporal";
          break;

        case "medium":
          options.steps = 20;
          options.refineSteps = 4;
          options.denoiseMode = "full";
          break;

        case "medium":
          options.steps = 40;
          options.refineSteps = 4;
          options.denoiseMode = "full";
          break;
      }
    }

    this.ssgiPass = new SSGIPass(this, options);
    this.denoiser = new Denoiser(scene, camera, this.ssgiPass.texture, {
      gBufferPass: this.ssgiPass.gBufferPass,
      velocityDepthNormalPass: options.velocityDepthNormalPass,
      ...options
    });
    this.lastSize = {
      width: options.width,
      height: options.height,
      resolutionScale: options.resolutionScale
    };
    this.sceneRenderTarget = new WebGLRenderTarget(1, 1, {
      colorSpace: SRGBColorSpace
    });
    this.renderPass = new RenderPass(this._scene, this._camera);
    this.renderPass.renderToScreen = false;
    this.setSize(options.width, options.height);
    const th = this;
    const ssgiRenderPass = this.renderPass; // eslint-disable-next-line space-before-function-paren

    RenderPass.prototype.render = function (...args) {
      if (this !== ssgiRenderPass) {
        const wasUsingRenderPass = th.isUsingRenderPass;
        th.isUsingRenderPass = true;
        if (wasUsingRenderPass != th.isUsingRenderPass) th.updateUsingRenderPass();
      }

      render.call(this, ...args);
    };

    this.makeOptionsReactive(options);
    this.outputTexture = this.denoiser.texture; // this.outputTexture = this.denoiser.denoisePass.textures[1]
  }

  updateUsingRenderPass() {
    if (this.isUsingRenderPass) {
      this.ssgiPass.fullscreenMaterial.defines.useDirectLight = "";
    } else {
      delete this.ssgiPass.fullscreenMaterial.defines.useDirectLight;
    }

    this.ssgiPass.fullscreenMaterial.needsUpdate = true;
  }

  reset() {
    this.denoiser.reset();
  }

  makeOptionsReactive(options) {
    let needsUpdate = false;
    const ssgiPassFullscreenMaterialUniforms = this.ssgiPass.fullscreenMaterial.uniforms;
    const ssgiPassFullscreenMaterialUniformsKeys = Object.keys(ssgiPassFullscreenMaterialUniforms);

    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key];
        },

        set(value) {
          var _this$denoiser$denois;

          if (options[key] === value && needsUpdate) return;
          options[key] = value;

          switch (key) {
            // denoiser
            case "denoiseIterations":
              if (this.denoiser.denoisePass) this.denoiser.denoisePass.iterations = value;
              break;

            case "radius":
            case "phi":
            case "lumaPhi":
            case "depthPhi":
            case "normalPhi":
            case "roughnessPhi":
            case "specularPhi":
              if ((_this$denoiser$denois = this.denoiser.denoisePass) != null && _this$denoiser$denois.fullscreenMaterial.uniforms[key]) {
                this.denoiser.denoisePass.fullscreenMaterial.uniforms[key].value = value;
                this.reset();
              }

              break;

            case "denoiseIterations":
            case "radius":
              if (this.denoiser.denoisePass) this.denoiser.denoisePass[key] = value;
              break;
            // SSGI

            case "resolutionScale":
              this.setSize(this.lastSize.width, this.lastSize.height);
              this.reset();
              break;

            case "steps":
            case "refineSteps":
              this.ssgiPass.fullscreenMaterial.defines[key] = parseInt(value);
              this.ssgiPass.fullscreenMaterial.needsUpdate = needsUpdate;
              this.reset();
              break;

            case "importanceSampling":
            case "missedRays":
              if (value) {
                this.ssgiPass.fullscreenMaterial.defines[key] = "";
              } else {
                delete this.ssgiPass.fullscreenMaterial.defines[key];
              }

              this.ssgiPass.fullscreenMaterial.needsUpdate = needsUpdate;
              this.reset();
              break;

            case "distance":
              ssgiPassFullscreenMaterialUniforms.rayDistance.value = value;
              this.reset();
              break;

            case "outputTexture":
              if (!this.outputTexture) {
                return;
              }

              if (typeof value === "string") {
                if (this.gBufferDebugPass === undefined) {
                  this.gBufferDebugPass = new GBufferDebugPass(this.ssgiPass.gBufferPass.texture);
                  this.gBufferDebugPass.setSize(this.lastSize.width, this.lastSize.height);
                }

                const modes = ["diffuse", "alpha", "normal", "roughness", "metalness", "emissive"];
                const mode = modes.indexOf(value);
                this.gBufferDebugPass.fullscreenMaterial.uniforms.mode.value = mode;
                this.outputTexture = this.gBufferDebugPass.texture;
              } else if (this.gBufferDebugPass !== undefined && this.outputTexture !== this.gBufferDebugPass.texture) {
                this.gBufferDebugPass.dispose();
                delete this.gBufferDebugPass;
              }

              this.uniforms.get("isDebug").value = this.outputTexture !== this.denoiser.texture;
              break;
            // must be a uniform

            default:
              if (ssgiPassFullscreenMaterialUniformsKeys.includes(key)) {
                ssgiPassFullscreenMaterialUniforms[key].value = value;
                this.reset();
              }

          }
        }

      }); // apply all uniforms and defines

      this[key] = options[key];
    }

    needsUpdate = true;
  }

  initialize(renderer, ...args) {
    super.initialize(renderer, ...args);
    this.ssgiPass.initialize(renderer, ...args);
  }

  setSize(width, height, force = false) {
    var _this$gBufferDebugPas, _this$cubeToEquirectE;

    if (width === undefined && height === undefined) return;

    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale) {
      return;
    }

    this.ssgiPass.setSize(width, height);
    this.denoiser.setSize(width, height);
    (_this$gBufferDebugPas = this.gBufferDebugPass) == null ? void 0 : _this$gBufferDebugPas.setSize(width, height);
    this.sceneRenderTarget.setSize(width, height);
    (_this$cubeToEquirectE = this.cubeToEquirectEnvPass) == null ? void 0 : _this$cubeToEquirectE.setSize(width, height);
    this.lastSize = {
      width,
      height,
      resolutionScale: this.resolutionScale
    };
  }

  dispose() {
    var _this$cubeToEquirectE2;

    super.dispose();
    this.ssgiPass.dispose();
    this.denoiser.dispose();
    (_this$cubeToEquirectE2 = this.cubeToEquirectEnvPass) == null ? void 0 : _this$cubeToEquirectE2.dispose();
    RenderPass.prototype.render = render;
  }

  keepEnvMapUpdated(renderer) {
    const ssgiMaterial = this.ssgiPass.fullscreenMaterial;
    let environment = this._scene.environment;

    if (environment) {
      if (ssgiMaterial.uniforms.envMapInfo.value.mapUuid !== environment.uuid) {
        // if the environment is a cube texture, convert it to an equirectangular texture so we can sample it in the SSGI pass and use MIS
        if (environment.isCubeTexture) {
          if (!this.cubeToEquirectEnvPass) this.cubeToEquirectEnvPass = new CubeToEquirectEnvPass();
          environment = this.cubeToEquirectEnvPass.generateEquirectEnvMap(renderer, environment);
          environment.uuid = this._scene.environment.uuid;
        }

        if (!environment.generateMipmaps) {
          environment.generateMipmaps = true;
          environment.minFilter = LinearMipMapLinearFilter;
          environment.magFilter = LinearFilter;
          environment.needsUpdate = true;
        }

        if (environment.type === FloatType) {
          console.warn("SSGI: Environment map is FloatType, this causes the environment map to be black in the SSGI pass for many modern Apple devices. Please use HalfFloatType instead.");
        }

        ssgiMaterial.uniforms.envMapInfo.value.mapUuid = environment.uuid;
        const maxEnvMapMipLevel = getMaxMipLevel(environment);
        ssgiMaterial.uniforms.maxEnvMapMipLevel.value = maxEnvMapMipLevel;
        ssgiMaterial.uniforms.envMapInfo.value.map = environment;
        ssgiMaterial.defines.USE_ENVMAP = "";
        delete ssgiMaterial.defines.importanceSampling;

        if (this.importanceSampling) {
          ssgiMaterial.uniforms.envMapInfo.value.updateFrom(environment, renderer).then(() => {
            ssgiMaterial.defines.importanceSampling = "";
            ssgiMaterial.needsUpdate = true;
          });
        } else {
          ssgiMaterial.uniforms.envMapInfo.value.map = environment;
        }

        this.reset();
        ssgiMaterial.needsUpdate = true;
      }
    } else if ("USE_ENVMAP" in ssgiMaterial.defines) {
      delete ssgiMaterial.defines.USE_ENVMAP;
      delete ssgiMaterial.defines.importanceSampling;
      ssgiMaterial.needsUpdate = true;
    }
  }

  get depthTexture() {
    return this.ssgiPass.gBufferPass.depthTexture;
  }

  update(renderer, inputBuffer) {
    var _this$gBufferDebugPas2, _this$outputTexture$;

    this.keepEnvMapUpdated(renderer);
    const sceneBuffer = this.isUsingRenderPass ? inputBuffer : this.sceneRenderTarget;
    const hideMeshes = [];

    if (!this.isUsingRenderPass) {
      const children = [];

      for (const c of getVisibleChildren(this._scene)) {
        if (c.isScene) return;
        c.visible = !isChildMaterialRenderable(c);
        c.visible ? hideMeshes.push(c) : children.push(c);
      }

      this.renderPass.render(renderer, this.sceneRenderTarget);

      for (const c of children) c.visible = true;

      for (const c of hideMeshes) c.visible = false;
    }

    this.ssgiPass.fullscreenMaterial.uniforms.directLightTexture.value = sceneBuffer.texture;
    this.ssgiPass.render(renderer);
    (_this$gBufferDebugPas2 = this.gBufferDebugPass) == null ? void 0 : _this$gBufferDebugPas2.render(renderer);
    this.denoiser.render(renderer, inputBuffer);
    this.uniforms.get("inputTexture").value = (_this$outputTexture$ = this.outputTexture[0]) !== null && _this$outputTexture$ !== void 0 ? _this$outputTexture$ : this.outputTexture;
    this.uniforms.get("sceneTexture").value = sceneBuffer.texture;
    this.uniforms.get("depthTexture").value = this.ssgiPass.gBufferPass.depthTexture; // update the fog uniforms

    if (this._scene.fog) {
      this.uniforms.get("fogColor").value = this._scene.fog.color;
      this.uniforms.get("fogNear").value = this._scene.fog.near;
      this.uniforms.get("fogFar").value = this._scene.fog.far;
      this.uniforms.get("fogDensity").value = this._scene.fog.density;
      this.uniforms.get("cameraNear").value = this._camera.near;
      this.uniforms.get("cameraFar").value = this._camera.far;
    }

    for (const c of hideMeshes) c.visible = true;

    globalIblRadianceDisabledUniform.value = true;
    cancelAnimationFrame(this.rAF2);
    cancelAnimationFrame(this.rAF);
    cancelAnimationFrame(this.usingRenderPassRAF);
    this.rAF = requestAnimationFrame(() => {
      this.rAF2 = requestAnimationFrame(() => {
        globalIblRadianceDisabledUniform.value = false;
      });
    });
    this.usingRenderPassRAF = requestAnimationFrame(() => {
      const wasUsingRenderPass = this.isUsingRenderPass;
      this.isUsingRenderPass = false;
      if (wasUsingRenderPass != this.isUsingRenderPass) this.updateUsingRenderPass();
    });
  }

}
SSGIEffect.DefaultOptions = defaultSSGIOptions;

class SSREffect extends SSGIEffect {
  constructor(composer, scene, camera, options = {}) {
    options.mode = "ssr";
    super(composer, scene, camera, options);
  }

}

var motion_blur = "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform highp sampler2D velocityTexture;uniform vec2 resolution;uniform float intensity;uniform float jitter;uniform float deltaTime;uniform int frame;uniform vec2 texSize;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 velocity=textureLod(velocityTexture,vUv,0.0).xy;bool didMove=dot(velocity,velocity)>0.000000001;if(!didMove){outputColor=inputColor;return;}velocity*=intensity;vec4 blueNoise=blueNoise(vUv,frame);vec2 jitterOffset=jitter*velocity*blueNoise.xy;float frameSpeed=(1./100.)/deltaTime;vec2 startUv=vUv+(jitterOffset-velocity*0.5)*frameSpeed;vec2 endUv=vUv+(jitterOffset+velocity*0.5)*frameSpeed;startUv=max(vec2(0.),startUv);endUv=min(vec2(1.),endUv);vec3 motionBlurredColor=inputColor.rgb;for(float i=0.0;i<=samplesFloat;i++){vec2 reprojectedUv=mix(startUv,endUv,i/samplesFloat);vec3 neighborColor=textureLod(inputTexture,reprojectedUv,0.0).rgb;motionBlurredColor+=neighborColor;}motionBlurredColor/=samplesFloat+2.;outputColor=vec4(motionBlurredColor,inputColor.a);}"; // eslint-disable-line

/* eslint-disable camelcase */
// http://john-chapman-graphics.blogspot.com/2013/01/per-object-motion-blur.html
// reference code: https://github.com/gkjohnson/threejs-sandbox/blob/master/motionBlurPass/src/CompositeShader.js

const defaultOptions$1 = {
  intensity: 1,
  jitter: 1,
  samples: 16
};
class MotionBlurEffect extends Effect {
  constructor(velocityPass, options = defaultOptions$1) {
    options = { ...defaultOptions$1,
      ...options
    };
    const {
      fragmentShader,
      uniforms
    } = setupBlueNoise(motion_blur); // convert the uniforms from type { uniform: value,... } to type ["uniform", value,...]

    const formattedUniforms = [];

    for (const key of Object.keys(uniforms)) {
      formattedUniforms.push([key, uniforms[key]]);
    }

    super("MotionBlurEffect", fragmentShader, {
      type: "MotionBlurMaterial",
      uniforms: new Map([...formattedUniforms, ["inputTexture", new Uniform(null)], ["velocityTexture", new Uniform(velocityPass.texture)], ["resolution", new Uniform(new Vector2())], ["intensity", new Uniform(1)], ["jitter", new Uniform(1)], ["frame", new Uniform(0)], ["deltaTime", new Uniform(0)]]),
      defines: new Map([["samples", options.samples.toFixed(0)], ["samplesFloat", options.samples.toFixed(0) + ".0"]])
    });
    this.pointsIndex = 0;
    this.makeOptionsReactive(options);
  }

  makeOptionsReactive(options) {
    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key];
        },

        set(value) {
          options[key] = value;

          switch (key) {
            case "intensity":
            case "jitter":
              this.uniforms.get(key).value = value;
              break;
          }
        }

      });
      this[key] = options[key];
    }
  }

  initialize(renderer, ...args) {
    super.initialize(renderer, ...args);
    new TextureLoader().load(blueNoiseImage, blueNoiseTexture => {
      blueNoiseTexture.minFilter = NearestFilter;
      blueNoiseTexture.magFilter = NearestFilter;
      blueNoiseTexture.wrapS = RepeatWrapping;
      blueNoiseTexture.wrapT = RepeatWrapping;
      blueNoiseTexture.colorSpace = NoColorSpace;
      this.uniforms.get("blueNoiseTexture").value = blueNoiseTexture;
    });
  }

  update(renderer, inputBuffer, deltaTime) {
    this.uniforms.get("inputTexture").value = inputBuffer.texture;
    this.uniforms.get("deltaTime").value = Math.max(1 / 1000, deltaTime);
    const frame = renderer.info.render.frame % 4096;
    this.uniforms.get("frame").value = frame;
    this.uniforms.get("resolution").value.set(window.innerWidth, window.innerHeight);
    const noiseTexture = this.uniforms.get("blueNoiseTexture").value;

    if (noiseTexture) {
      const {
        width,
        height
      } = noiseTexture.source.data;
      this.uniforms.get("blueNoiseSize").value.set(width, height);
    }
  }

}

class VelocityPass extends VelocityDepthNormalPass {
  constructor(scene, camera) {
    super(scene, camera, false);
  }

}

class AOPass extends Pass {
  constructor(camera, scene, fragmentShader) {
    super();
    this._camera = camera;
    this._scene = scene;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: HalfFloatType,
      depthBuffer: false
    });
    const finalFragmentShader = fragmentShader;
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader: finalFragmentShader,
      vertexShader,
      uniforms: {
        depthTexture: {
          value: null
        },
        normalTexture: {
          value: null
        },
        cameraNear: {
          value: 0
        },
        cameraFar: {
          value: 0
        },
        viewMatrix: {
          value: this._camera.matrixWorldInverse
        },
        projectionViewMatrix: {
          value: new Matrix4()
        },
        projectionMatrixInverse: {
          value: this._camera.projectionMatrixInverse
        },
        cameraMatrixWorld: {
          value: this._camera.matrixWorld
        },
        resolution: {
          value: new Vector2()
        },
        blueNoiseTexture: {
          value: null
        },
        blueNoiseRepeat: {
          value: new Vector2()
        },
        aoDistance: {
          value: 0
        },
        distancePower: {
          value: 0
        },
        bias: {
          value: 0
        },
        thickness: {
          value: 0
        },
        power: {
          value: 0
        },
        frame: {
          value: 0
        }
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    });
    useBlueNoise(this.fullscreenMaterial);
    new TextureLoader().load(blueNoiseImage, blueNoiseTexture => {
      blueNoiseTexture.minFilter = NearestFilter;
      blueNoiseTexture.magFilter = NearestFilter;
      blueNoiseTexture.wrapS = RepeatWrapping;
      blueNoiseTexture.wrapT = RepeatWrapping;
      blueNoiseTexture.colorSpace = NoColorSpace;
      this.fullscreenMaterial.uniforms.blueNoiseTexture.value = blueNoiseTexture;
    });
  }

  get texture() {
    return this.renderTarget.texture;
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height);
    this.fullscreenMaterial.uniforms.resolution.value.set(this.renderTarget.width, this.renderTarget.height);
  }

  render(renderer) {
    const spp = +this.fullscreenMaterial.defines.spp;
    this.fullscreenMaterial.uniforms.frame.value = (this.fullscreenMaterial.uniforms.frame.value + spp) % 4096;
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near;
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far;
    this.fullscreenMaterial.uniforms.projectionViewMatrix.value.multiplyMatrices(this._camera.projectionMatrix, this._camera.matrixWorldInverse);
    const noiseTexture = this.fullscreenMaterial.uniforms.blueNoiseTexture.value;

    if (noiseTexture) {
      const {
        width,
        height
      } = noiseTexture.source.data;
      this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / width, this.renderTarget.height / height);
    }

    renderer.setRenderTarget(this.renderTarget);
    renderer.render(this.scene, this.camera);
  }

}

var hbao_utils = "#define GLSLIFY 1\n#include <sampleBlueNoise>\nuniform sampler2D normalTexture;uniform float cameraNear;uniform float cameraFar;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;float getViewZ(const float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 getWorldPos(const float depth,const vec2 coord){float z=depth*2.0-1.0;vec4 clipSpacePosition=vec4(coord*2.0-1.0,z,1.0);vec4 viewSpacePosition=projectionMatrixInverse*clipSpacePosition;vec4 worldSpacePosition=cameraMatrixWorld*viewSpacePosition;worldSpacePosition.xyz/=worldSpacePosition.w;return worldSpacePosition.xyz;}vec3 slerp(const vec3 a,const vec3 b,const float t){float cosAngle=dot(a,b);float angle=acos(cosAngle);if(abs(angle)<0.001){return mix(a,b,t);}float sinAngle=sin(angle);float t1=sin((1.0-t)*angle)/sinAngle;float t2=sin(t*angle)/sinAngle;return(a*t1)+(b*t2);}vec3 computeWorldNormal(){vec2 size=vec2(textureSize(depthTexture,0));ivec2 p=ivec2(vUv*size);float c0=texelFetch(depthTexture,p,0).x;float l2=texelFetch(depthTexture,p-ivec2(2,0),0).x;float l1=texelFetch(depthTexture,p-ivec2(1,0),0).x;float r1=texelFetch(depthTexture,p+ivec2(1,0),0).x;float r2=texelFetch(depthTexture,p+ivec2(2,0),0).x;float b2=texelFetch(depthTexture,p-ivec2(0,2),0).x;float b1=texelFetch(depthTexture,p-ivec2(0,1),0).x;float t1=texelFetch(depthTexture,p+ivec2(0,1),0).x;float t2=texelFetch(depthTexture,p+ivec2(0,2),0).x;float dl=abs((2.0*l1-l2)-c0);float dr=abs((2.0*r1-r2)-c0);float db=abs((2.0*b1-b2)-c0);float dt=abs((2.0*t1-t2)-c0);vec3 ce=getWorldPos(c0,vUv).xyz;vec3 dpdx=(dl<dr)? ce-getWorldPos(l1,(vUv-vec2(1.0/size.x,0.0))).xyz:-ce+getWorldPos(r1,(vUv+vec2(1.0/size.x,0.0))).xyz;vec3 dpdy=(db<dt)? ce-getWorldPos(b1,(vUv-vec2(0.0,1.0/size.y))).xyz:-ce+getWorldPos(t1,(vUv+vec2(0.0,1.0/size.y))).xyz;return normalize(cross(dpdx,dpdy));}vec3 getWorldNormal(const vec2 uv){\n#ifdef useNormalTexture\nvec3 worldNormal=unpackRGBToNormal(textureLod(normalTexture,uv,0.).rgb);worldNormal=(vec4(worldNormal,1.)*viewMatrix).xyz;return normalize(worldNormal);\n#else\nreturn computeWorldNormal();\n#endif\n}\n#define PI 3.14159265358979323846264338327950288\nvec3 cosineSampleHemisphere(const vec3 n,const vec2 u){float r=sqrt(u.x);float theta=2.0*PI*u.y;vec3 b=normalize(cross(n,vec3(0.0,1.0,1.0)));vec3 t=cross(b,n);return normalize(r*sin(theta)*b+sqrt(1.0-u.x)*n+r*cos(theta)*t);}"; // eslint-disable-line

var fragmentShader$4 = "#define GLSLIFY 1\nvarying vec2 vUv;uniform highp sampler2D depthTexture;uniform mat4 projectionViewMatrix;uniform int frame;uniform sampler2D blueNoiseTexture;uniform vec2 blueNoiseRepeat;uniform vec2 resolution;uniform float aoDistance;uniform float distancePower;uniform float bias;uniform float thickness;\n#include <packing>\n#include <hbao_utils>\nfloat getOcclusion(const vec3 cameraPosition,const vec3 worldPos,const vec3 worldNormal,const float depth,const int seed,inout float totalWeight){vec4 blueNoise=blueNoise();vec3 sampleWorldDir=cosineSampleHemisphere(worldNormal,blueNoise.rg);vec3 sampleWorldPos=worldPos+aoDistance*pow(blueNoise.b,distancePower+1.0)*sampleWorldDir;vec4 sampleUv=projectionViewMatrix*vec4(sampleWorldPos,1.);sampleUv.xy/=sampleUv.w;sampleUv.xy=sampleUv.xy*0.5+0.5;float sampleDepth=textureLod(depthTexture,sampleUv.xy,0.0).r;float deltaDepth=depth-sampleDepth;float d=distance(sampleWorldPos,cameraPosition);deltaDepth*=0.001*d*d;float th=thickness*0.01;float theta=dot(worldNormal,sampleWorldDir);totalWeight+=theta;if(deltaDepth<th){float horizon=sampleDepth+deltaDepth*bias*1000.;float occlusion=max(0.0,horizon-depth)*theta;float m=max(0.,1.-deltaDepth/th);occlusion=10.*occlusion*m/d;occlusion=sqrt(occlusion);return occlusion;}return 0.;}void main(){float depth=textureLod(depthTexture,vUv,0.0).r;if(depth==1.0){discard;return;}vec4 cameraPosition=cameraMatrixWorld*vec4(0.0,0.0,0.0,1.0);vec3 worldPos=getWorldPos(depth,vUv);vec3 worldNormal=getWorldNormal(vUv);float ao=0.0,totalWeight=0.0;for(int i=0;i<spp;i++){int seed=i;\n#ifdef animatedNoise\nseed+=frame;\n#endif\nfloat occlusion=getOcclusion(cameraPosition.xyz,worldPos,worldNormal,depth,seed,totalWeight);ao+=occlusion;}if(totalWeight>0.)ao/=totalWeight;ao=clamp(1.-ao,0.,1.);gl_FragColor=vec4(worldNormal,ao);}"; // eslint-disable-line

const finalFragmentShader = fragmentShader$4.replace("#include <hbao_utils>", hbao_utils);

class HBAOPass extends AOPass {
  constructor(camera, scene) {
    super(camera, scene, finalFragmentShader);
  }

}

var ao_compose = "#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform highp sampler2D depthTexture;uniform float power;uniform vec3 color;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float unpackedDepth=textureLod(depthTexture,uv,0.).r;float ao=unpackedDepth>0.9999 ? 1.0 : textureLod(inputTexture,uv,0.0).a;ao=pow(ao,power);vec3 aoColor=mix(color,vec3(1.),ao);aoColor*=inputColor.rgb;outputColor=vec4(aoColor,inputColor.a);}"; // eslint-disable-line

const defaultAOOptions = {
  resolutionScale: 1,
  spp: 8,
  distance: 2,
  distancePower: 1,
  power: 2,
  bias: 40,
  thickness: 0.075,
  color: new Color("black"),
  useNormalPass: false,
  velocityDepthNormalPass: null,
  normalTexture: null,
  ...PoissonDenoisePass.DefaultOptions
};

class AOEffect extends Effect {
  constructor(composer, camera, scene, aoPass, options = defaultAOOptions) {
    super("AOEffect", ao_compose, {
      type: "FinalAOMaterial",
      uniforms: new Map([["inputTexture", new Uniform(null)], ["depthTexture", new Uniform(null)], ["power", new Uniform(0)], ["color", new Uniform(new Color("black"))]])
    });
    this.lastSize = {
      width: 0,
      height: 0,
      resolutionScale: 0
    };
    this.composer = composer;
    this.aoPass = aoPass;
    options = { ...defaultAOOptions,
      ...options
    }; // set up depth texture

    if (!composer.depthTexture) composer.createDepthTexture();
    this.aoPass.fullscreenMaterial.uniforms.depthTexture.value = composer.depthTexture;
    this.uniforms.get("depthTexture").value = composer.depthTexture; // set up optional normal texture

    if (options.useNormalPass || options.normalTexture) {
      var _options$normalTextur;

      if (options.useNormalPass) this.normalPass = new NormalPass(scene, camera);
      const normalTexture = (_options$normalTextur = options.normalTexture) !== null && _options$normalTextur !== void 0 ? _options$normalTextur : this.normalPass.texture;
      this.aoPass.fullscreenMaterial.uniforms.normalTexture.value = normalTexture;
      this.aoPass.fullscreenMaterial.defines.useNormalTexture = "";
    }

    this.PoissonDenoisePass = new PoissonDenoisePass(camera, this.aoPass.texture, composer.depthTexture, {
      normalInRgb: true
    });
    this.makeOptionsReactive(options);
  }

  makeOptionsReactive(options) {
    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key];
        },

        set(value) {
          if (value === null || value === undefined) return;
          options[key] = value;

          switch (key) {
            case "spp":
              this.aoPass.fullscreenMaterial.defines.spp = value.toFixed(0);
              this.aoPass.fullscreenMaterial.needsUpdate = true;
              break;

            case "distance":
              this.aoPass.fullscreenMaterial.uniforms.aoDistance.value = value;
              break;

            case "resolutionScale":
              this.setSize(this.lastSize.width, this.lastSize.height);
              break;

            case "power":
              this.uniforms.get("power").value = value;
              break;

            case "color":
              this.uniforms.get("color").value.copy(new Color(value));
              break;
            // denoiser

            case "iterations":
            case "radius":
            case "rings":
            case "samples":
              this.PoissonDenoisePass[key] = value;
              break;

            case "lumaPhi":
            case "depthPhi":
            case "normalPhi":
              this.PoissonDenoisePass.fullscreenMaterial.uniforms[key].value = Math.max(value, 0.0001);
              break;

            default:
              if (key in this.aoPass.fullscreenMaterial.uniforms) {
                this.aoPass.fullscreenMaterial.uniforms[key].value = value;
              }

          }
        },

        configurable: true
      }); // apply all uniforms and defines

      this[key] = options[key];
    }
  }

  setSize(width, height) {
    var _this$normalPass;

    if (width === undefined || height === undefined) return;

    if (width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale) {
      return;
    }

    (_this$normalPass = this.normalPass) == null ? void 0 : _this$normalPass.setSize(width, height);
    this.aoPass.setSize(width * this.resolutionScale, height * this.resolutionScale);
    this.PoissonDenoisePass.setSize(width, height);
    this.lastSize = {
      width,
      height,
      resolutionScale: this.resolutionScale
    };
  }

  get texture() {
    if (this.iterations > 0) {
      return this.PoissonDenoisePass.texture;
    }

    return this.aoPass.texture;
  }

  update(renderer) {
    var _this$normalPass2;

    // check if TRAA is being used so we can animate the noise
    const hasTRAA = this.composer.passes.some(pass => {
      var _pass$effects;

      return pass.enabled && !pass.skipRendering && ((_pass$effects = pass.effects) == null ? void 0 : _pass$effects.some(effect => effect instanceof TRAAEffect));
    }); // set animated noise depending on TRAA

    if (hasTRAA && !("animatedNoise" in this.aoPass.fullscreenMaterial.defines)) {
      this.aoPass.fullscreenMaterial.defines.animatedNoise = "";
      this.aoPass.fullscreenMaterial.needsUpdate = true;
    } else if (!hasTRAA && "animatedNoise" in this.aoPass.fullscreenMaterial.defines) {
      delete this.aoPass.fullscreenMaterial.defines.animatedNoise;
      this.aoPass.fullscreenMaterial.needsUpdate = true;
    }

    this.uniforms.get("inputTexture").value = this.texture;
    (_this$normalPass2 = this.normalPass) == null ? void 0 : _this$normalPass2.render(renderer);
    this.aoPass.render(renderer);
    this.PoissonDenoisePass.render(renderer);
  }

}

AOEffect.DefaultOptions = defaultAOOptions;

class HBAOEffect extends AOEffect {
  constructor(composer, camera, scene, options = AOEffect.DefaultOptions) {
    const hbaoPass = new HBAOPass(camera, scene);
    options = { ...AOEffect.DefaultOptions,
      ...HBAOEffect.DefaultOptions,
      ...options
    };
    super(composer, camera, scene, hbaoPass, options);
    this.lastSize = {
      width: 0,
      height: 0,
      resolutionScale: 0
    };
    options = { ...AOEffect.DefaultOptions,
      ...options
    };
  }

}

var taa = "#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D acculumatedTexture;uniform float cameraNotMovedFrames;void main(){vec4 color=linearToOutputTexel(textureLod(inputTexture,vUv,0.));if(cameraNotMovedFrames==0.){gl_FragColor=color;return;}vec4 acculumatedColor=textureLod(acculumatedTexture,vUv,0.);gl_FragColor=mix(acculumatedColor,color,1./(cameraNotMovedFrames+1.));}"; // eslint-disable-line

class TAAPass extends Pass {
  constructor(camera) {
    super("TAAPass");
    this.accumulatedTexture = null;
    this.lastCameraPosition = new Vector3();
    this.lastCameraQuaternion = new Quaternion();
    this.lastCameraProjectionMatrix = null;
    this.cameraNotMovedFrames = 0;
    this.frame = 0;
    this.needsUpdate = false;
    this.renderToScreen = true;
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      depthBuffer: false
    });
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader: taa,
      vertexShader,
      uniforms: {
        inputTexture: {
          value: null
        },
        acculumatedTexture: {
          value: null
        },
        cameraNotMovedFrames: {
          value: 0
        },
        invTexSize: {
          value: new Vector2(1, 1)
        }
      },
      toneMapped: false,
      depthWrite: false,
      depthTest: false
    });
    this._camera = camera;
  }

  setSize(width, height) {
    var _this$framebufferText;

    this.renderTarget.setSize(width, height);
    (_this$framebufferText = this.framebufferTexture) == null ? void 0 : _this$framebufferText.dispose();
    this.framebufferTexture = new FramebufferTexture(width, height, RGBAFormat);
    this.framebufferTexture.needsUpdate = true;
    this.fullscreenMaterial.uniforms.acculumatedTexture.value = this.framebufferTexture;
    this.needsUpdate = true;
  }

  render(renderer, inputBuffer) {
    this.frame = (this.frame + 1) % 4096;
    this.fullscreenMaterial.uniforms.inputTexture.value = inputBuffer.texture;
    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / inputBuffer.width, 1 / inputBuffer.height); // check if the camera has moved by comparing the camera's world matrix and projection matrix

    const cameraMoved = this.needsUpdate || didCameraMove(this._camera, this.lastCameraPosition, this.lastCameraQuaternion);
    this.needsUpdate = false;
    const cameraNotMovedFrames = this.fullscreenMaterial.uniforms.cameraNotMovedFrames.value;

    if (cameraNotMovedFrames > 0) {
      const {
        width,
        height
      } = this.framebufferTexture.image;
      jitter(width, height, this._camera, this.frame, 1);
    }

    this.fullscreenMaterial.uniforms.cameraNotMovedFrames.value = cameraMoved ? 0 : (cameraNotMovedFrames + 1) % 4096;
    this.lastCameraPosition.copy(this._camera.position);
    this.lastCameraQuaternion.copy(this._camera.quaternion);
    renderer.setRenderTarget(null);
    renderer.render(this.scene, this.camera);
    renderer.copyFramebufferToTexture(this.renderTarget, this.framebufferTexture);
  }

}

const fragmentShader$3 =
/* glsl */
`
uniform sampler2D inputTexture;
uniform float sharpness;

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    vec4 blurredPixel = texture(inputTexture, uv - 1.0 * texelSize);
    blurredPixel += texture(inputTexture, uv + vec2(0.0, -1.0) * texelSize);
    blurredPixel += texture(inputTexture, uv + vec2(1.0, -1.0) * texelSize);
    blurredPixel += texture(inputTexture, uv + vec2(-1.0, 0.0) * texelSize);
    blurredPixel += inputColor;
    blurredPixel += texture(inputTexture, uv + vec2(1.0, 0.0) * texelSize);
    blurredPixel += texture(inputTexture, uv + vec2(-1.0, 1.0) * texelSize);
    blurredPixel += texture(inputTexture, uv + vec2(0.0, 1.0) * texelSize);
    blurredPixel += texture(inputTexture, uv + 1.0 * texelSize);
    blurredPixel /= 9.0;

    // Calculate the sharpness difference
    vec4 sharpDiff = inputColor - blurredPixel;

    // Apply the sharpness effect by adding the difference scaled by the sharpness value
    vec4 sharpenedPixel = inputColor + sharpDiff * sharpness;

	// set minimun to 0 as otherwise we get severe edge artifacts on Mac Sonoma Firefox v120 for example
	sharpenedPixel.rgb = max(sharpenedPixel.rgb, vec3(0.0));

    outputColor = sharpenedPixel;
}
`;
const defaultOptions = {
  sharpness: 1
};
class SharpnessEffect extends Effect {
  constructor(options = defaultOptions) {
    options = { ...defaultOptions,
      ...options
    };
    super("SharpnessEffect", fragmentShader$3, {
      uniforms: new Map([["sharpness", new Uniform(options.sharpness)], ["inputTexture", new Uniform(null)]])
    });
    this.setSharpness(options.sharpness);
  }

  setSharpness(sharpness) {
    this.uniforms.get("sharpness").value = sharpness;
  }

  update(renderer, inputBuffer) {
    this.uniforms.get("inputTexture").value = inputBuffer.texture;
  }

}

const fragmentShader$2 =
/* glsl */
`
        uniform highp sampler2D depthTexture;
        uniform mat4 projectionMatrix;
        uniform mat4 projectionMatrixInverse;
        uniform mat4 cameraMatrixWorld;
        uniform vec3 backgroundColor;
        uniform float maxDistance;

        // source: https://github.com/mrdoob/three.js/blob/79ea10830dfc97b6c0a7e29d217c7ff04c081095/examples/jsm/shaders/BokehShader.js#L66
        float getViewZ(const in float depth) {
            #if PERSPECTIVE_CAMERA == 1
            return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
            #else
            return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
            #endif
        }

        // source:
        // https://github.com/mrdoob/three.js/blob/dev/examples/js/shaders/SSAOShader.js
        vec3 getViewPosition(float viewZ) {
            float clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];
            vec4 clipPosition = vec4((vec3(vUv, viewZ) - 0.5) * 2.0, 1.0);
            clipPosition *= clipW;
            vec3 p = (projectionMatrixInverse * clipPosition).xyz;
            p.z = viewZ;
            return p;
        }

        void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
            float depth = textureLod(depthTexture, uv, 0.).r;

            // get the world position from the depth texture
            float viewZ = getViewZ(depth);
            // view-space position of the current texel
            vec3 viewPos = getViewPosition(viewZ);
            vec3 worldPos = (cameraMatrixWorld * vec4(viewPos, 1.)).xyz;
            float distToCenter = length(worldPos.xz) + max(0., -worldPos.y);
            float fade = clamp(pow(distToCenter, 0.1) * 15.0 - maxDistance, 0., 1.);

            vec3 color = mix(inputColor.rgb, backgroundColor, fade);

            outputColor = vec4(color, 1.);
        }
`;
class GradualBackgroundEffect extends Effect {
  constructor(camera, depthTexture, backgroundColor, maxDistance = 5) {
    super("GradualBackgroundEffect", fragmentShader$2, {
      uniforms: new Map([["projectionMatrix", {
        value: camera.projectionMatrix
      }], ["projectionMatrixInverse", {
        value: camera.projectionMatrixInverse
      }], ["cameraMatrixWorld", {
        value: camera.matrixWorld
      }], ["depthTexture", {
        value: depthTexture
      }], ["backgroundColor", {
        value: backgroundColor
      }], ["maxDistance", {
        value: maxDistance
      }]]),
      defines: new Map([["PERSPECTIVE_CAMERA", camera.isPerspectiveCamera ? "1" : "0"]])
    });
  }

  setBackgroundColor(color) {
    this.uniforms.get("backgroundColor").value = color;
  }

  setMaxDistance(distance) {
    this.uniforms.get("maxDistance").value = distance;
  }

}

const fragmentShader$1 =
/* glsl */
`
    #define luminance(c) dot(c.rgb, vec3(0.299, 0.587, 0.114))

    ${gbuffer_packing}

    uniform highp sampler2D velocityTexture;
    uniform mat4 projectionMatrix;
    uniform mat4 projectionMatrixInverse;
    uniform mat4 viewMatrix;
    uniform mat4 cameraMatrixWorld;
    uniform vec3 backgroundColor;
    uniform float spread;
    uniform float intensity;

    // source: https://github.com/mrdoob/three.js/blob/79ea10830dfc97b6c0a7e29d217c7ff04c081095/examples/jsm/shaders/BokehShader.js#L66
    float getViewZ(const in float depth) {
        #if PERSPECTIVE_CAMERA == 1
        return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
        #else
        return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
        #endif
    }

    // source:
    // https://github.com/mrdoob/three.js/blob/dev/examples/js/shaders/SSAOShader.js
    vec3 getViewPosition(float viewZ) {
        float clipW = projectionMatrix[2][3] * viewZ + projectionMatrix[3][3];
        vec4 clipPosition = vec4((vec3(vUv, viewZ) - 0.5) * 2.0, 1.0);
        clipPosition *= clipW;
        vec3 p = (projectionMatrixInverse * clipPosition).xyz;
        p.z = viewZ;
        return p;
    }

    float nn(vec2 n) {
        const vec2 d = vec2(0.0, 1.0);
        vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
        return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
    }

    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        vec4 velocityTexel = textureLod(velocityTexture, uv, 0.0);

        float depth = velocityTexel.a;

        if(depth == 0. || depth == 1.) {
            outputColor = inputColor;
            return;
        }

        vec3 normal = unpackNormal(velocityTexel.b);
        vec3 viewNormal = normalize((viewMatrix * vec4(normal, 0.)).xyz);

        // get the world position from the depth texture
        float viewZ = getViewZ(depth);
        // view-space position of the current texel
        vec3 viewPos = getViewPosition(viewZ);
        vec3 viewDir = normalize(viewPos);
        vec3 worldPos = (cameraMatrixWorld * vec4(viewPos, 1.)).xyz;

        if(worldPos.y < 0.01){
            outputColor = inputColor;
            return;
        }

        vec3 cameraPos = (cameraMatrixWorld * vec4(0., 0., 0., 1.)).xyz;

        float dist = length(worldPos - cameraPos);
        float distFactor = exp(-dist * 0.005);

        // using world normal and world position, determine how much the surface is facing the camera
        float facing = max(dot(-viewDir, viewNormal), 0.);
        facing = pow(facing, 4.);
        
        // facing = mix(facing, bn, 0.1);

        vec2 offset = normalize(worldPos).xz * 1000. + normal.xz * 500.;

        float noise = nn(offset);
        noise = pow(noise, 500. * spread);

        float lum = luminance(inputColor.rgb);
        lum = smoothstep(0.15, 1., lum);

        float sparkleFactor = noise * lum * facing * distFactor * 5000. * intensity;

        vec3 color = inputColor.rgb + pow(inputColor.rgb, vec3(4.)) * sparkleFactor;
        outputColor = vec4(color, 1.);
    }
`;
class SparkleEffect extends Effect {
  constructor(camera, velocityDepthNormalPass) {
    super("SparkleEffect", fragmentShader$1, {
      uniforms: new Map([["projectionMatrix", {
        value: camera.projectionMatrix.clone()
      }], ["projectionMatrixInverse", {
        value: camera.projectionMatrixInverse.clone()
      }], ["cameraMatrixWorld", {
        value: camera.matrixWorld
      }], ["viewMatrix", {
        value: camera.matrixWorldInverse
      }], ["velocityTexture", {
        value: velocityDepthNormalPass.texture
      }], ["spread", {
        value: 1
      }], ["intensity", {
        value: 1
      }]])
    });
    this._camera = camera;
  }

  update() {
    const {
      view
    } = this._camera;
    view && this._camera.clearViewOffset();
    this.uniforms.get("projectionMatrix").value.copy(this._camera.projectionMatrix);
    this.uniforms.get("projectionMatrixInverse").value.copy(this._camera.projectionMatrixInverse);
    view && this._camera.setViewOffset(view.fullWidth, view.fullHeight, view.offsetX, view.offsetY, view.width, view.height);
  }

  setSpread(spread) {
    this.uniforms.get("spread").value = spread;
  }

  setIntensity(intensity) {
    this.uniforms.get("intensity").value = intensity;
  }

}

const fragmentShader =
/* glsl */
`
    uniform sampler2D inputTexture;
    // uniform sampler2D chessboardTexture;
    uniform vec2 resolution;

    uniform float alphax;
    uniform float alphay;
    uniform float aberration;

    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        // source: https://marcodiiga.github.io/radial-lens-undistortion-filtering
        float x = (2.0 * vUv.x - 1.0) / 1.0;
        float y = (2.0 * vUv.y - 1.0) / 1.0;
        
        // Calculate l2 norm
        float r = x*x + y*y;
        
        // Calculate the deflated or inflated new coordinate (reverse transform)
        float x3 = x / (1.0 - alphax * r);
        float y3 = y / (1.0 - alphay * r); 
        float x2 = x / (1.0 - alphax * (x3 * x3 + y3 * y3));
        float y2 = y / (1.0 - alphay * (x3 * x3 + y3 * y3));

        // De-normalize to the original range
        float i2 = (x2 + 1.0) * 1.0 / 2.0;
        float j2 = (y2 + 1.0) * 1.0 / 2.0;

        vec2 duv = vec2(i2, j2);

        // source: https://stackoverflow.com/questions/9841863/reflection-refraction-with-chromatic-aberration-eye-correction
        vec2 rOffset = vec2(1.0 / resolution.x, 0.0);
        vec2 gOffset = vec2(0.0, 1.0 / resolution.y);
        vec2 bOffset = vec2(1.0 / resolution.x, 1.0 / resolution.y);

        vec4 rValue = texture2D(inputTexture, duv - aberration * rOffset);  
        vec4 gValue = texture2D(inputTexture, duv - aberration * gOffset);
        vec4 bValue = texture2D(inputTexture, duv - aberration * bOffset); 

        outputColor = vec4(rValue.r, gValue.g, bValue.b, 1.0);
    }
`;
class LensDistortionEffect extends Effect {
  constructor({
    alphax = -0.05,
    alphay = -0.05,
    aberration = 1
  } = {}) {
    // const chessboardTexture = new TextureLoader().load(chessboard)
    // chessboardTexture.wrapS = chessboardTexture.wrapT = RepeatWrapping
    super("LensDistortionEffect", fragmentShader, {
      uniforms: new Map([["inputTexture", {
        value: null
      }], // ["chessboardTexture", { value: chessboardTexture }],
      ["resolution", {
        value: new Vector2()
      }], ["alphax", {
        value: alphax
      }], ["alphay", {
        value: alphay
      }], ["aberration", {
        value: aberration
      }]])
    });
  }

  update(renderer, inputBuffer) {
    this.uniforms.get("inputTexture").value = inputBuffer.texture;
    this.uniforms.get("resolution").value.set(inputBuffer.width, inputBuffer.height);
  }

  setAlphaX(value) {
    this.uniforms.get("alphax").value = value;
  }

  setAlphaY(value) {
    this.uniforms.get("alphay").value = value;
  }

}

export { GradualBackgroundEffect, HBAOEffect, LensDistortionEffect, MotionBlurEffect, PoissonDenoisePass, SSGIEffect, SSREffect, SharpnessEffect, SparkleEffect, TAAPass, TRAAEffect, TemporalReprojectPass, VelocityDepthNormalPass, VelocityPass };

import { Pass, Effect, RenderPass, Selection, NormalPass } from 'postprocessing'
import { DataTexture, RGBAFormat, FloatType, ShaderChunk, ShaderLib, UniformsUtils, WebGLMultipleRenderTargets, ShaderMaterial, GLSL3, NoBlending, Uniform, Vector2, Matrix4, Vector3, Clock, Quaternion, LinearFilter, HalfFloatType, FramebufferTexture, TextureLoader, NearestFilter, RepeatWrapping, NoColorSpace, WebGLRenderTarget, ClampToEdgeWrapping, LinearMipMapLinearFilter, EquirectangularReflectionMapping, Color, Matrix3, TangentSpaceNormalMap, RedFormat, Source, Texture, NoToneMapping, PerspectiveCamera, SRGBColorSpace, DepthTexture } from 'three'
import _classPrivateFieldLooseBase from '@babel/runtime/helpers/esm/classPrivateFieldLooseBase'
import _classPrivateFieldLooseKey from '@babel/runtime/helpers/esm/classPrivateFieldLooseKey'

const getVisibleChildren = (object) => {
  const queue = [object]
  const objects = []

  while (queue.length !== 0) {
    const mesh = queue.shift()
    if (mesh.material) objects.push(mesh)

    for (const c of mesh.children) {
      if (c.visible) queue.push(c)
    }
  }

  return objects
}
const keepMaterialMapUpdated = (mrtMaterial, originalMaterial, prop, define, useKey) => {
  if (useKey) {
    if (originalMaterial[prop] !== mrtMaterial[prop]) {
      mrtMaterial[prop] = originalMaterial[prop]
      mrtMaterial.uniforms[prop].value = originalMaterial[prop]

      if (originalMaterial[prop]) {
        mrtMaterial.defines[define] = ''
      } else {
        delete mrtMaterial.defines[define]
      }

      mrtMaterial.needsUpdate = true
    }
  } else if (mrtMaterial[prop] !== undefined) {
    mrtMaterial[prop] = undefined
    mrtMaterial.uniforms[prop].value = undefined
    delete mrtMaterial.defines[define]
    mrtMaterial.needsUpdate = true
  }
}
const getMaxMipLevel = (texture) => {
  const { width, height } = texture.image
  return Math.floor(Math.log2(Math.max(width, height))) + 1
}
const saveBoneTexture = (object) => {
  let boneTexture = object.material.uniforms.prevBoneTexture.value

  if (boneTexture && boneTexture.image.width === object.skeleton.boneTexture.width) {
    boneTexture = object.material.uniforms.prevBoneTexture.value
    boneTexture.image.data.set(object.skeleton.boneTexture.image.data)
  } else {
    var _boneTexture

    ;(_boneTexture = boneTexture) == null ? void 0 : _boneTexture.dispose()
    const boneMatrices = object.skeleton.boneTexture.image.data.slice()
    const size = object.skeleton.boneTexture.image.width
    boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType)
    object.material.uniforms.prevBoneTexture.value = boneTexture
    boneTexture.needsUpdate = true
  }
}
const updateVelocityDepthNormalMaterialBeforeRender = (c, camera) => {
  var _c$skeleton

  if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) {
    c.material.uniforms.boneTexture.value = c.skeleton.boneTexture

    if (!('USE_SKINNING' in c.material.defines)) {
      c.material.defines.USE_SKINNING = ''
      c.material.defines.BONE_TEXTURE = ''
      c.material.needsUpdate = true
    }
  }

  c.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, c.matrixWorld)
  c.material.uniforms.velocityMatrix.value.multiplyMatrices(camera.projectionMatrix, c.modelViewMatrix)
}
const updateVelocityDepthNormalMaterialAfterRender = (c, camera) => {
  var _c$skeleton2

  c.material.uniforms.prevVelocityMatrix.value.multiplyMatrices(camera.projectionMatrix, c.modelViewMatrix)
  if ((_c$skeleton2 = c.skeleton) != null && _c$skeleton2.boneTexture) saveBoneTexture(c)
}
const createGlobalDisableIblRadianceUniform = () => {
  if (!ShaderChunk.envmap_physical_pars_fragment.includes('iblRadianceDisabled')) {
    ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(
      'vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {',
      /* glsl */
      `
		uniform bool iblRadianceDisabled;
	
		vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		 if(iblRadianceDisabled) return vec3(0.);
		`
    )
  }

  if ('iblRadianceDisabled' in ShaderLib.physical.uniforms) return ShaderLib.physical.uniforms['iblRadianceDisabled']
  const globalIblRadianceDisabledUniform = {
    value: false
  }
  ShaderLib.physical.uniforms.iblRadianceDisabled = globalIblRadianceDisabledUniform
  const { clone } = UniformsUtils

  UniformsUtils.clone = (uniforms) => {
    const result = clone(uniforms)

    if ('iblRadianceDisabled' in uniforms) {
      result.iblRadianceDisabled = globalIblRadianceDisabledUniform
    }

    return result
  }

  return globalIblRadianceDisabledUniform
}
const createGlobalDisableIblIradianceUniform = () => {
  if (!ShaderChunk.envmap_physical_pars_fragment.includes('iblIrradianceDisabled')) {
    ShaderChunk.envmap_physical_pars_fragment = ShaderChunk.envmap_physical_pars_fragment.replace(
      'vec3 getIBLIrradiance( const in vec3 normal ) {',
      /* glsl */
      `
			uniform bool iblIrradianceDisabled;
		
			vec3 getIBLIrradiance( const in vec3 normal ) {
			 if(iblIrradianceDisabled) return vec3(0.);
			`
    )
  }

  if ('iblIrradianceDisabled' in ShaderLib.physical.uniforms) {
    return ShaderLib.physical.uniforms['iblIrradianceDisabled']
  }

  const globalIblIrradianceDisabledUniform = {
    value: false
  }
  ShaderLib.physical.uniforms.iblIrradianceDisabled = globalIblIrradianceDisabledUniform
  const { clone } = UniformsUtils

  UniformsUtils.clone = (uniforms) => {
    const result = clone(uniforms)

    if ('iblIrradianceDisabled' in uniforms) {
      result.iblIrradianceDisabled = globalIblIrradianceDisabledUniform
    }

    return result
  }

  return globalIblIrradianceDisabledUniform
} // source: https://github.com/mrdoob/three.js/blob/b9bc47ab1978022ab0947a9bce1b1209769b8d91/src/renderers/webgl/WebGLProgram.js#L228
// Unroll Loops

const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer)
}

function loopReplacer(match, start, end, snippet) {
  let string = ''

  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i)
  }

  return string
} //
const isGroundProjectedEnv = (c) => {
  var _c$material$fragmentS

  return (_c$material$fragmentS = c.material.fragmentShader) == null ? void 0 : _c$material$fragmentS.includes('float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );')
}
const isChildMaterialRenderable = (c, material = c.material) => {
  return material.visible && material.depthWrite && material.depthTest && (!material.transparent || material.opacity > 0) && !isGroundProjectedEnv(c)
}
const materialProps = ['vertexTangent', 'vertexColors', 'vertexAlphas', 'vertexUvs', 'uvsVertexOnly', 'supportsVertexTextures', 'instancing', 'instancingColor', 'side', 'flatShading', 'skinning', 'doubleSided', 'flipSided']
const copyNecessaryProps = (originalMaterial, newMaterial) => {
  for (const props of materialProps) newMaterial[props] = originalMaterial[props]
}

var vertexShader = '#define GLSLIFY 1\nvarying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}' // eslint-disable-line

class CopyPass extends Pass {
  constructor(textureCount = 1) {
    super('CopyPass')
    this.needsSwap = false
    this.renderTarget = new WebGLMultipleRenderTargets(1, 1, 1, {
      depthBuffer: false
    })
    this.setTextureCount(textureCount)
  }

  setTextureCount(textureCount) {
    var _this$fullscreenMater

    let definitions = ''
    let body = ''

    for (let i = 0; i < textureCount; i++) {
      definitions +=
        /* glsl */
        `
				uniform sampler2D inputTexture${i};
				layout(location = ${i}) out vec4 gOutput${i};
			`
      body +=
        /* glsl */
        `gOutput${i} = textureLod(inputTexture${i}, vUv, 0.);`
    }

    ;(_this$fullscreenMater = this.fullscreenMaterial) == null ? void 0 : _this$fullscreenMater.dispose()
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader:
        /* glsl */
        `
            varying vec2 vUv;
			
			${definitions}

            void main() {
				${body}
            }
            `,
      vertexShader: vertexShader,
      glslVersion: GLSL3,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    })

    for (let i = 0; i < textureCount; i++) {
      this.fullscreenMaterial.uniforms['inputTexture' + i] = new Uniform(null)

      if (i >= this.renderTarget.texture.length) {
        const texture = this.renderTarget.texture[0].clone()
        texture.isRenderTargetTexture = true
        this.renderTarget.texture.push(texture)
      }
    }
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height)
  }

  render(renderer) {
    renderer.setRenderTarget(this.renderTarget)
    renderer.render(this.scene, this.camera)
  }
}

var fragmentShader$4 =
  '#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D velocityTexture;uniform sampler2D depthTexture;uniform sampler2D lastVelocityTexture;uniform float blend;uniform float neighborhoodClampIntensity;uniform bool constantBlend;uniform bool fullAccumulate;uniform vec2 invTexSize;uniform float cameraNear;uniform float cameraFar;uniform mat4 projectionMatrix;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;uniform vec3 cameraPos;uniform vec3 prevCameraPos;uniform mat4 prevViewMatrix;uniform mat4 prevCameraMatrixWorld;uniform mat4 prevProjectionMatrix;uniform mat4 prevProjectionMatrixInverse;uniform bool reset;uniform float delta;\n#define EPSILON 0.00001\n#include <packing>\n#include <reproject>\nvoid main(){vec2 dilatedUv=vUv;getVelocityNormalDepth(dilatedUv,velocity,worldNormal,depth);if(textureCount>1&&depth==1.0){discard;return;}vec4 inputTexel[textureCount];vec4 accumulatedTexel[textureCount];bool textureSampledThisFrame[textureCount];int cnt=0;\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){inputTexel[i]=textureLod(inputTexture[i],vUv,0.0);textureSampledThisFrame[i]=inputTexel[i].r>=0.;if(textureSampledThisFrame[i]){transformColor(inputTexel[i].rgb);}else{inputTexel[i].rgb=vec3(0.0);}if(cnt++==0)roughness=max(0.,inputTexel[i].a);texIndex++;}\n#pragma unroll_loop_end\ntexIndex=0;bool didMove=dot(velocity,velocity)>0.000000001;vec3 worldPos=screenSpaceToWorldSpace(dilatedUv,depth,cameraMatrixWorld,projectionMatrixInverse);flatness=getFlatness(worldPos,worldNormal);vec3 viewPos=(viewMatrix*vec4(worldPos,1.0)).xyz;vec3 viewDir=normalize(viewPos);vec3 viewNormal=(viewMatrix*vec4(worldNormal,0.0)).xyz;viewAngle=dot(-viewDir,viewNormal);vec2 reprojectedUvDiffuse=vec2(-10.0);vec2 reprojectedUvSpecular[textureCount];bool didReproject;bool reprojectHitPoint;float rayLength;\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){rayLength=inputTexel[i].a;reprojectHitPoint=reprojectSpecular[i]&&rayLength>0.0;if(reprojectHitPoint){reprojectedUvSpecular[i]=getReprojectedUV(depth,worldPos,worldNormal,rayLength);}else{reprojectedUvSpecular[i]=vec2(-1.0);}reprojectedUvDiffuse=getReprojectedUV(depth,worldPos,worldNormal,0.0);didReproject=reprojectedUvSpecular[i].x>=0.0||reprojectedUvDiffuse.x>=0.0;if(!didReproject){accumulatedTexel[i]=vec4(inputTexel[i].rgb,0.0);\n#ifdef VISUALIZE_DISOCCLUSIONS\naccumulatedTexel[i]=vec4(vec3(0.,1.,0.),0.0);inputTexel[i].rgb=accumulatedTexel[i].rgb;\n#endif\n}else{if(reprojectHitPoint&&reprojectedUvSpecular[i].x>=0.0){accumulatedTexel[i]=sampleReprojectedTexture(accumulatedTexture[i],reprojectedUvSpecular[i]);}else{accumulatedTexel[i]=sampleReprojectedTexture(accumulatedTexture[i],reprojectedUvDiffuse);}\n#ifdef VISUALIZE_DISOCCLUSIONS\naccumulatedTexel[i].rgb=vec3(0.);inputTexel[i].rgb=vec3(0.);\n#endif\ntransformColor(accumulatedTexel[i].rgb);if(textureSampledThisFrame[i]){accumulatedTexel[i].a++;if(neighborhoodClamp[i]&&didMove){vec3 clampedColor=accumulatedTexel[i].rgb;clampNeighborhood(inputTexture[i],clampedColor,inputTexel[i].rgb,neighborhoodClampRadius);accumulatedTexel[i].rgb=mix(accumulatedTexel[i].rgb,clampedColor,neighborhoodClampIntensity);}}else{inputTexel[i].rgb=accumulatedTexel[i].rgb;}}texIndex++;}\n#pragma unroll_loop_end\ntexIndex=0;float maxValue=(fullAccumulate&&!didMove)? 1.0 : blend;vec3 outputColor;float temporalReprojectMix;\n#pragma unroll_loop_start\nfor(int i=0;i<textureCount;i++){if(constantBlend){temporalReprojectMix=accumulatedTexel[i].a==0.0 ? 0.0 : blend;}else{temporalReprojectMix=blend;if(accumulatedTexel[i].a>5.)accumulatedTexel[i].a=mix(accumulatedTexel[i].a,5.,angleMix);if(reset)accumulatedTexel[i].a=0.0;temporalReprojectMix=min(1.-1./(accumulatedTexel[i].a+1.0),maxValue);}outputColor=mix(inputTexel[i].rgb,accumulatedTexel[i].rgb,temporalReprojectMix);accumulatedTexel[i].a=1./(1.-temporalReprojectMix)-1.;undoColorTransform(outputColor);gOutput[i]=vec4(outputColor,accumulatedTexel[i].a);texIndex++;}\n#pragma unroll_loop_end\n#ifdef useTemporalReprojectCustomComposeShader\ntemporalReprojectCustomComposeShader\n#endif\n}' // eslint-disable-line

var reproject =
  '#define GLSLIFY 1\nvec2 dilatedUv;int texIndex;vec2 velocity;vec3 worldNormal;float depth;float flatness;vec3 debugVec3;float viewAngle;float angleMix;float roughness=0.0;\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nfloat getViewZ(const float depth){return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);}vec3 screenSpaceToWorldSpace(const vec2 uv,const float depth,mat4 curMatrixWorld,const mat4 projMatrixInverse){vec4 ndc=vec4((uv.x-0.5)*2.0,(uv.y-0.5)*2.0,(depth-0.5)*2.0,1.0);vec4 clip=projMatrixInverse*ndc;vec4 view=curMatrixWorld*(clip/clip.w);return view.xyz;}vec2 viewSpaceToScreenSpace(const vec3 position,const mat4 projMatrix){vec4 projectedCoord=projMatrix*vec4(position,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;return projectedCoord.xy;}vec2 OctWrap(vec2 v){vec2 w=1.0-abs(v.yx);if(v.x<0.0)w.x=-w.x;if(v.y<0.0)w.y=-w.y;return w;}vec3 decodeOctWrap(vec2 f){f=f*2.0-1.0;vec3 n=vec3(f.x,f.y,1.0-abs(f.x)-abs(f.y));float t=max(-n.z,0.0);n.x+=n.x>=0.0 ?-t : t;n.y+=n.y>=0.0 ?-t : t;return normalize(n);}vec3 unpackNormal(float packedNormal){return decodeOctWrap(unpackHalf2x16(floatBitsToUint(packedNormal)));}\n#ifdef logTransform\nvoid transformColor(inout vec3 color){color=log(color+1.);}void undoColorTransform(inout vec3 color){color=exp(color)-1.;}\n#else\n#define transformColor\n#define undoColorTransform\n#endif\nvoid getNeighborhoodAABB(const sampler2D tex,const int clampRadius,inout vec3 minNeighborColor,inout vec3 maxNeighborColor){for(int x=-clampRadius;x<=clampRadius;x++){for(int y=-clampRadius;y<=clampRadius;y++){if(x!=0||y!=0){vec2 offset=vec2(x,y)*invTexSize;vec2 neighborUv=vUv+offset;vec4 neighborTexel=textureLod(tex,neighborUv,0.0);transformColor(neighborTexel.rgb);minNeighborColor=min(neighborTexel.rgb,minNeighborColor);maxNeighborColor=max(neighborTexel.rgb,maxNeighborColor);}}}}void clampNeighborhood(const sampler2D tex,inout vec3 color,const vec3 inputColor,const int clampRadius){vec3 minNeighborColor=inputColor;vec3 maxNeighborColor=inputColor;getNeighborhoodAABB(tex,clampRadius,minNeighborColor,maxNeighborColor);color=clamp(color,minNeighborColor,maxNeighborColor);}void getVelocityNormalDepth(inout vec2 dilatedUv,out vec2 vel,out vec3 normal,out float depth){vec2 centerUv=dilatedUv;\n#ifdef dilation\nfloat closestDepth=0.0;vec4 closestVelocityTexel=vec4(0.0);for(int x=-1;x<=1;x++){for(int y=-1;y<=1;y++){vec2 offset=vec2(x,y)*invTexSize;vec2 neighborUv=centerUv+offset;vec4 velocityTexel=textureLod(velocityTexture,neighborUv,0.0);float neighborDepth=velocityTexel.a;if(x==0&&y==0){vel=velocityTexel.rg;}if(neighborDepth>closestDepth){closestDepth=neighborDepth;closestVelocityTexel=velocityTexel;dilatedUv=neighborUv;}}}normal=unpackNormal(closestVelocityTexel.b);depth=closestDepth;\n#else\nvec4 velocityTexel=textureLod(velocityTexture,centerUv,0.0);vel=velocityTexel.rg;normal=unpackNormal(velocityTexel.b);depth=velocityTexel.a;\n#endif\n}\n#define PLANE_DISTANCE 1.0\n#define NORMAL_DISTANCE 0.1\n#define VELOCITY_DISTANCE 0.005\nbool planeDistanceDisocclusionCheck(const vec3 worldPos,const vec3 lastWorldPos,const vec3 worldNormal,const float distFactor){if(abs(dot(worldNormal,worldPos))==0.0)return false;vec3 toCurrent=worldPos-lastWorldPos;float distToPlane=abs(dot(toCurrent,worldNormal));return distToPlane>PLANE_DISTANCE*distFactor;}bool normalDisocclusionCheck(vec3 worldNormal,vec3 lastWorldNormal,const float distFactor){return pow(abs(dot(worldNormal,lastWorldNormal)),2.)<NORMAL_DISTANCE*distFactor;}bool velocityDisocclusionCheck(const vec2 velocity,const vec2 lastVelocity,const float distFactor){return length(velocity-lastVelocity)>VELOCITY_DISTANCE*distFactor;}bool validateReprojectedUV(const vec2 reprojectedUv,const vec3 worldPos,const vec3 worldNormal,const bool isHitPoint){if(reprojectedUv.x>1.0||reprojectedUv.x<0.0||reprojectedUv.y>1.0||reprojectedUv.y<0.0)return false;vec2 dilatedReprojectedUv=reprojectedUv;vec2 lastVelocity=vec2(0.0);vec3 lastWorldNormal=vec3(0.0);float lastDepth=0.0;getVelocityNormalDepth(dilatedReprojectedUv,lastVelocity,lastWorldNormal,lastDepth);vec3 lastWorldPos=screenSpaceToWorldSpace(dilatedReprojectedUv,lastDepth,prevCameraMatrixWorld,prevProjectionMatrixInverse);vec3 lastViewPos=(viewMatrix*vec4(lastWorldPos,1.0)).xyz;vec3 lastViewDir=normalize(lastViewPos);vec3 lastViewNormal=(viewMatrix*vec4(lastWorldNormal,0.0)).xyz;float lastViewAngle=dot(-lastViewDir,lastViewNormal);float angleDiff=max(0.,abs(lastViewAngle-viewAngle));angleMix=min(1.,2.*angleDiff);float viewZ=abs(getViewZ(depth));float distFactor=1.+1./(viewZ+1.0);if(velocityDisocclusionCheck(velocity,lastVelocity,distFactor))return false;if(planeDistanceDisocclusionCheck(worldPos,lastWorldPos,worldNormal,distFactor))return false;return true;}vec2 reprojectHitPoint(const vec3 rayOrig,const float rayLength){if(roughness>0.4||rayLength>10.0e3){return vUv-velocity;}vec3 cameraRay=rayOrig-cameraPos;cameraRay=normalize(cameraRay);vec3 parallaxHitPoint=cameraPos+cameraRay*rayLength;vec4 reprojectedHitPoint=prevProjectionMatrix*prevViewMatrix*vec4(parallaxHitPoint,1.0);reprojectedHitPoint.xyz/=reprojectedHitPoint.w;reprojectedHitPoint.xy=reprojectedHitPoint.xy*0.5+0.5;return reprojectedHitPoint.xy;}vec2 getReprojectedUV(const float depth,const vec3 worldPos,const vec3 worldNormal,const float rayLength){if(rayLength!=0.0){vec2 reprojectedUv=reprojectHitPoint(worldPos,rayLength);if(validateReprojectedUV(reprojectedUv,worldPos,worldNormal,true)){return reprojectedUv;}return vec2(-1.);}vec2 reprojectedUv=vUv-velocity;if(validateReprojectedUV(reprojectedUv,worldPos,worldNormal,false)){return reprojectedUv;}return vec2(-1.);}vec4 SampleTextureCatmullRom(const sampler2D tex,const vec2 uv,const vec2 texSize){vec2 samplePos=uv*texSize;vec2 texPos1=floor(samplePos-0.5f)+0.5f;vec2 f=samplePos-texPos1;vec2 w0=f*(-0.5f+f*(1.0f-0.5f*f));vec2 w1=1.0f+f*f*(-2.5f+1.5f*f);vec2 w2=f*(0.5f+f*(2.0f-1.5f*f));vec2 w3=f*f*(-0.5f+0.5f*f);vec2 w12=w1+w2;vec2 offset12=w2/(w1+w2);vec2 texPos0=texPos1-1.;vec2 texPos3=texPos1+2.;vec2 texPos12=texPos1+offset12;texPos0/=texSize;texPos3/=texSize;texPos12/=texSize;vec4 result=vec4(0.0);result+=textureLod(tex,vec2(texPos0.x,texPos0.y),0.0f)*w0.x*w0.y;result+=textureLod(tex,vec2(texPos12.x,texPos0.y),0.0f)*w12.x*w0.y;result+=textureLod(tex,vec2(texPos3.x,texPos0.y),0.0f)*w3.x*w0.y;result+=textureLod(tex,vec2(texPos0.x,texPos12.y),0.0f)*w0.x*w12.y;result+=textureLod(tex,vec2(texPos12.x,texPos12.y),0.0f)*w12.x*w12.y;result+=textureLod(tex,vec2(texPos3.x,texPos12.y),0.0f)*w3.x*w12.y;result+=textureLod(tex,vec2(texPos0.x,texPos3.y),0.0f)*w0.x*w3.y;result+=textureLod(tex,vec2(texPos12.x,texPos3.y),0.0f)*w12.x*w3.y;result+=textureLod(tex,vec2(texPos3.x,texPos3.y),0.0f)*w3.x*w3.y;result=max(result,vec4(0.));return result;}float getFlatness(vec3 g,vec3 rp){vec3 gw=fwidth(g);vec3 pw=fwidth(rp);float wfcurvature=length(gw)/length(pw);wfcurvature=smoothstep(0.0,30.,wfcurvature);return clamp(wfcurvature,0.,1.);}vec2 sampleBlocky(vec2 p){p/=invTexSize;vec2 seam=floor(p+0.5);p=seam+clamp((p-seam)/fwidth(p),-0.5,0.5);return p*invTexSize;}vec4 sampleReprojectedTexture(const sampler2D tex,const vec2 reprojectedUv){vec4 blocky=SampleTextureCatmullRom(tex,(reprojectedUv),1./invTexSize);return blocky;}' // eslint-disable-line

class TemporalReprojectMaterial extends ShaderMaterial {
  constructor(textureCount = 1, temporalReprojectCustomComposeShader = '') {
    let finalFragmentShader = fragmentShader$4.replace('#include <reproject>', reproject)

    if (typeof temporalReprojectCustomComposeShader === 'string') {
      finalFragmentShader = finalFragmentShader.replace('temporalReprojectCustomComposeShader', temporalReprojectCustomComposeShader)
    }

    let definitions = ''

    for (let i = 0; i < textureCount; i++) {
      definitions +=
        /* glsl */
        `
				uniform sampler2D inputTexture${i};
				uniform sampler2D accumulatedTexture${i};

				layout(location = ${i}) out vec4 gOutput${i};
			`
    }

    finalFragmentShader = definitions + finalFragmentShader.replaceAll('textureCount', textureCount)
    finalFragmentShader = unrollLoops(finalFragmentShader)
    const matches = finalFragmentShader.matchAll(/inputTexture\[\s*[0-9]+\s*]/g)

    for (const [key] of matches) {
      const number = key.replace(/[^0-9]/g, '')
      finalFragmentShader = finalFragmentShader.replace(key, 'inputTexture' + number)
    }

    const matches2 = finalFragmentShader.matchAll(/accumulatedTexture\[\s*[0-9]+\s*]/g)

    for (const [key] of matches2) {
      const number = key.replace(/[^0-9]/g, '')
      finalFragmentShader = finalFragmentShader.replace(key, 'accumulatedTexture' + number)
    }

    const matches3 = finalFragmentShader.matchAll(/gOutput\[\s*[0-9]+\s*]/g)

    for (const [key] of matches3) {
      const number = key.replace(/[^0-9]/g, '')
      finalFragmentShader = finalFragmentShader.replace(key, 'gOutput' + number)
    }

    super({
      type: 'TemporalReprojectMaterial',
      uniforms: {
        velocityTexture: new Uniform(null),
        depthTexture: new Uniform(null),
        lastVelocityTexture: new Uniform(null),
        blend: new Uniform(0),
        neighborhoodClampIntensity: new Uniform(0),
        constantBlend: new Uniform(false),
        fullAccumulate: new Uniform(false),
        reset: new Uniform(false),
        delta: new Uniform(0),
        invTexSize: new Uniform(new Vector2()),
        projectionMatrix: new Uniform(new Matrix4()),
        projectionMatrixInverse: new Uniform(new Matrix4()),
        cameraMatrixWorld: new Uniform(new Matrix4()),
        viewMatrix: new Uniform(new Matrix4()),
        prevViewMatrix: new Uniform(new Matrix4()),
        prevCameraMatrixWorld: new Uniform(new Matrix4()),
        prevProjectionMatrix: new Uniform(new Matrix4()),
        prevProjectionMatrixInverse: new Uniform(new Matrix4()),
        cameraPos: new Uniform(new Vector3()),
        prevCameraPos: new Uniform(new Vector3()),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(0)
      },
      vertexShader,
      fragmentShader: finalFragmentShader,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false,
      glslVersion: GLSL3
    })

    for (let i = 0; i < textureCount; i++) {
      this.uniforms['inputTexture' + i] = new Uniform(null)
      this.uniforms['accumulatedTexture' + i] = new Uniform(null)
    }

    if (typeof temporalReprojectCustomComposeShader === 'string') {
      this.defines.useTemporalReprojectCustomComposeShader = ''
    }
  }
}

// from: https://news.ycombinator.com/item?id=17876741

const g = 1.32471795724474602596090885447809 // Plastic number

const a1 = 1.0 / g
const a2 = 1.0 / (g * g)
const base = 1.1127756842787055 // harmoniousNumber(7), yields better coverage compared to using 0.5

const generateR2 = (count) => {
  const points = []

  for (let n = 0; n < count; n++) {
    points.push([(base + a1 * n) % 1, (base + a2 * n) % 1])
  }

  return points
}

const defaultTemporalReprojectPassOptions = {
  blend: 0.9,
  dilation: false,
  constantBlend: false,
  fullAccumulate: false,
  neighborhoodClamp: false,
  neighborhoodClampRadius: 1,
  neighborhoodClampIntensity: 1,
  logTransform: false,
  depthDistance: 2,
  worldDistance: 4,
  reprojectSpecular: false,
  temporalReprojectCustomComposeShader: null,
  renderTarget: null
}
const tmpProjectionMatrix$1 = new Matrix4()
const tmpProjectionMatrixInverse$1 = new Matrix4()
const tmpVec2 = new Vector2()
class TemporalReprojectPass extends Pass {
  constructor(scene, camera, velocityDepthNormalPass, textureCount = 1, options = defaultTemporalReprojectPassOptions) {
    super('TemporalReprojectPass')
    this.needsSwap = false
    this.overrideAccumulatedTextures = []
    this.clock = new Clock()
    this.r2Sequence = []
    this.pointsIndex = 0
    this.lastCameraTransform = {
      position: new Vector3(),
      quaternion: new Quaternion()
    }
    this._scene = scene
    this._camera = camera
    this.textureCount = textureCount
    options = { ...defaultTemporalReprojectPassOptions, ...options }
    this.renderTarget = new WebGLMultipleRenderTargets(1, 1, textureCount, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType,
      depthBuffer: false
    })
    this.renderTarget.texture.forEach((texture, index) => (texture.name = 'TemporalReprojectPass.accumulatedTexture' + index))
    this.fullscreenMaterial = new TemporalReprojectMaterial(textureCount, options.temporalReprojectCustomComposeShader)
    this.fullscreenMaterial.defines.textureCount = textureCount
    if (options.dilation) this.fullscreenMaterial.defines.dilation = ''
    if (options.neighborhoodClamp) this.fullscreenMaterial.defines.neighborhoodClamp = ''
    if (options.logTransform) this.fullscreenMaterial.defines.logTransform = ''
    this.fullscreenMaterial.defines.neighborhoodClampRadius = parseInt(options.neighborhoodClampRadius)
    this.fullscreenMaterial.defines.depthDistance = options.depthDistance.toPrecision(5)
    this.fullscreenMaterial.defines.worldDistance = options.worldDistance.toPrecision(5)
    this.fullscreenMaterial.uniforms.blend.value = options.blend
    this.fullscreenMaterial.uniforms.constantBlend.value = options.constantBlend
    this.fullscreenMaterial.uniforms.fullAccumulate.value = options.fullAccumulate
    this.fullscreenMaterial.uniforms.neighborhoodClampIntensity.value = options.neighborhoodClampIntensity
    this.fullscreenMaterial.uniforms.projectionMatrix.value = camera.projectionMatrix.clone()
    this.fullscreenMaterial.uniforms.projectionMatrixInverse.value = camera.projectionMatrixInverse.clone()
    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = camera.matrixWorld
    this.fullscreenMaterial.uniforms.viewMatrix.value = camera.matrixWorldInverse
    this.fullscreenMaterial.uniforms.cameraPos.value = camera.position
    this.fullscreenMaterial.uniforms.prevViewMatrix.value = camera.matrixWorldInverse.clone()
    this.fullscreenMaterial.uniforms.prevCameraMatrixWorld.value = camera.matrixWorld.clone()
    this.fullscreenMaterial.uniforms.prevProjectionMatrix.value = camera.projectionMatrix.clone()
    this.fullscreenMaterial.uniforms.prevProjectionMatrixInverse.value = camera.projectionMatrixInverse.clone() // init copy pass to save the accumulated textures and the textures from the last frame

    this.copyPass = new CopyPass(textureCount)

    for (let i = 0; i < textureCount; i++) {
      const accumulatedTexture = this.copyPass.renderTarget.texture[i]
      accumulatedTexture.type = HalfFloatType
      accumulatedTexture.minFilter = LinearFilter
      accumulatedTexture.magFilter = LinearFilter
      accumulatedTexture.needsUpdate = true
    }

    this.fullscreenMaterial.uniforms.velocityTexture.value = velocityDepthNormalPass.renderTarget.texture
    this.fullscreenMaterial.uniforms.depthTexture.value = velocityDepthNormalPass.depthTexture

    for (const opt of ['reprojectSpecular', 'neighborhoodClamp']) {
      let value = options[opt]
      if (typeof value !== 'array') value = Array(textureCount).fill(value)
      this.fullscreenMaterial.defines[opt] =
        /* glsl */
        `bool[](${value.join(', ')})`
    }

    this.options = options
    this.velocityDepthNormalPass = velocityDepthNormalPass
  }

  setTextures(textures) {
    if (!Array.isArray(textures)) textures = [textures]

    for (let i = 0; i < textures.length; i++) {
      const texture = textures[i]
      this.fullscreenMaterial.uniforms['inputTexture' + i] = new Uniform(texture)
    }
  }

  dispose() {
    super.dispose()
    this.renderTarget.dispose()
    this.copyPass.dispose()
    this.fullscreenMaterial.dispose()
  }

  setSize(width, height) {
    var _this$framebufferText

    this.renderTarget.setSize(width, height)
    this.copyPass.setSize(width, height)
    this.fullscreenMaterial.uniforms.invTexSize.value.set(1 / width, 1 / height)
    ;(_this$framebufferText = this.framebufferTexture) == null ? void 0 : _this$framebufferText.dispose()
    this.framebufferTexture = new FramebufferTexture(width, height, RGBAFormat)
    this.framebufferTexture.type = HalfFloatType
    this.framebufferTexture.minFilter = LinearFilter
    this.framebufferTexture.magFilter = LinearFilter
    this.framebufferTexture.needsUpdate = true
  }

  get texture() {
    return this.renderTarget.texture[0]
  }

  reset() {
    this.fullscreenMaterial.uniforms.reset.value = true
  }

  render(renderer) {
    const delta = Math.min(1 / 10, this.clock.getDelta())
    this.fullscreenMaterial.uniforms.delta.value = delta
    tmpProjectionMatrix$1.copy(this._camera.projectionMatrix)
    tmpProjectionMatrixInverse$1.copy(this._camera.projectionMatrixInverse)
    if (this._camera.view) this._camera.view.enabled = false

    this._camera.updateProjectionMatrix()

    this.fullscreenMaterial.uniforms.projectionMatrix.value.copy(this._camera.projectionMatrix)
    this.fullscreenMaterial.uniforms.projectionMatrixInverse.value.copy(this._camera.projectionMatrixInverse)
    this.fullscreenMaterial.uniforms.lastVelocityTexture.value = this.velocityDepthNormalPass.lastVelocityTexture
    if (this._camera.view) this._camera.view.enabled = true

    this._camera.projectionMatrix.copy(tmpProjectionMatrix$1)

    this._camera.projectionMatrixInverse.copy(tmpProjectionMatrixInverse$1)

    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far
    renderer.setRenderTarget(this.renderTarget)
    renderer.render(this.scene, this.camera)
    this.fullscreenMaterial.uniforms.reset.value = false

    for (let i = 0; i < this.textureCount; i++) {
      this.copyPass.fullscreenMaterial.uniforms['inputTexture' + i].value = this.renderTarget.texture[i]
      const copyAccumulatedTexture = this.renderTarget.texture.length > 1 ? this.copyPass.renderTarget.texture[i] : this.framebufferTexture
      const accumulatedTexture = this.overrideAccumulatedTextures.length === 0 ? copyAccumulatedTexture : this.overrideAccumulatedTextures[i]
      this.fullscreenMaterial.uniforms['accumulatedTexture' + i].value = accumulatedTexture
    }

    if (this.renderTarget.texture.length > 1) {
      this.copyPass.render(renderer)
    } else {
      renderer.copyFramebufferToTexture(tmpVec2, this.framebufferTexture)
    } // save last transformations

    this.fullscreenMaterial.uniforms.prevCameraMatrixWorld.value.copy(this._camera.matrixWorld)
    this.fullscreenMaterial.uniforms.prevViewMatrix.value.copy(this._camera.matrixWorldInverse)
    this.fullscreenMaterial.uniforms.prevProjectionMatrix.value.copy(this.fullscreenMaterial.uniforms.projectionMatrix.value)
    this.fullscreenMaterial.uniforms.prevProjectionMatrixInverse.value.copy(this.fullscreenMaterial.uniforms.projectionMatrixInverse.value)
    this.fullscreenMaterial.uniforms.prevCameraPos.value.copy(this._camera.position)
  }

  jitter(jitterScale = 1) {
    this.unjitter()
    if (this.r2Sequence.length === 0) this.r2Sequence = generateR2(256).map(([a, b]) => [a - 0.5, b - 0.5])
    this.pointsIndex = (this.pointsIndex + 1) % this.r2Sequence.length
    const [x, y] = this.r2Sequence[this.pointsIndex]
    const { width, height } = this.renderTarget

    if (this._camera.setViewOffset) {
      this._camera.setViewOffset(width, height, x * jitterScale, y * jitterScale, width, height)
    }
  }

  unjitter() {
    if (this._camera.clearViewOffset) this._camera.clearViewOffset()
  }
}

var traa_compose = '#define GLSLIFY 1\nuniform sampler2D inputTexture;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 accumulatedTexel=textureLod(inputTexture,vUv,0.);outputColor=vec4(accumulatedTexel.rgb,1.);}' // eslint-disable-line

const defaultTRAAOptions = {
  blend: 0.8,
  dilation: true,
  logTransform: true,
  neighborhoodClampRadius: 2,
  neighborhoodClamp: true
}
class TRAAEffect extends Effect {
  constructor(scene, camera, velocityDepthNormalPass, options = defaultTRAAOptions) {
    super('TRAAEffect', traa_compose, {
      type: 'FinalTRAAEffectMaterial',
      uniforms: new Map([['inputTexture', new Uniform(null)]])
    })
    this._scene = scene
    this._camera = camera
    options = { ...defaultTRAAOptions, ...options }
    this.temporalReprojectPass = new TemporalReprojectPass(scene, camera, velocityDepthNormalPass, 1, options)
    this.uniforms.get('inputTexture').value = this.temporalReprojectPass.texture
    this.setSize(options.width, options.height)
  }

  setSize(width, height) {
    this.temporalReprojectPass.setSize(width, height)
  }

  dispose() {
    super.dispose()
    this.temporalReprojectPass.dispose()
  }

  update(renderer, inputBuffer) {
    this.temporalReprojectPass.unjitter()
    this.unjitteredProjectionMatrix = this._camera.projectionMatrix.clone()

    this._camera.projectionMatrix.copy(this.unjitteredProjectionMatrix)

    const noJitterMeshes = getVisibleChildren(this._scene).filter((c) => isGroundProjectedEnv(c))

    for (const mesh of noJitterMeshes) {
      const renderData = renderer.properties.get(mesh.material)
      if (!(renderData != null && renderData.programs)) continue
      const uniforms = Array.from(renderData.programs.values())[0].getUniforms()

      if (!uniforms._patchedProjectionMatrix) {
        const oldSetValue = uniforms.setValue.bind(uniforms)
        uniforms._oldSetValue = oldSetValue

        uniforms.setValue = (gl, name, value, ...args) => {
          if (name === 'projectionMatrix') {
            value = this.unjitteredProjectionMatrix
          }

          oldSetValue(gl, name, value, ...args)
        }

        uniforms._patchedProjectionMatrix = true
      }

      cancelAnimationFrame(uniforms._destroyPatchRAF)
      cancelAnimationFrame(uniforms._destroyPatchRAF2)
      uniforms._destroyPatchRAF = requestAnimationFrame(() => {
        uniforms._destroyPatchRAF2 = requestAnimationFrame(() => {
          uniforms.setValue = uniforms._oldSetValue
          delete uniforms._oldSetValue
          delete uniforms._patchedProjectionMatrix
        })
      })
    }

    this.temporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = inputBuffer.texture
    this.temporalReprojectPass.jitter()
    this.temporalReprojectPass.render(renderer)
  }
}
TRAAEffect.DefaultOptions = defaultTRAAOptions

var gbuffer_packing =
  '#define GLSLIFY 1\nuniform sampler2D gBuffersTexture;float color2float(in vec3 c){c*=255.;c=floor(c);return c.r*256.*256.+c.g*256.+c.b-8388608.;}vec3 float2color(in float val){val+=8388608.;if(val<0.){return vec3(0.);}if(val>16777216.){return vec3(1.);}vec3 c=vec3(0.);c.b=mod(val,256.);val=floor(val/256.);c.g=mod(val,256.);val=floor(val/256.);c.r=mod(val,256.);return c/255.;}vec2 OctWrap(vec2 v){vec2 w=1.0-abs(v.yx);if(v.x<0.0)w.x=-w.x;if(v.y<0.0)w.y=-w.y;return w;}vec2 encodeOctWrap(vec3 n){n/=(abs(n.x)+abs(n.y)+abs(n.z));n.xy=n.z>0.0 ? n.xy : OctWrap(n.xy);n.xy=n.xy*0.5+0.5;return n.xy;}vec3 decodeOctWrap(vec2 f){f=f*2.0-1.0;vec3 n=vec3(f.x,f.y,1.0-abs(f.x)-abs(f.y));float t=max(-n.z,0.0);n.x+=n.x>=0.0 ?-t : t;n.y+=n.y>=0.0 ?-t : t;return normalize(n);}float packNormal(vec3 normal){return uintBitsToFloat(packHalf2x16(encodeOctWrap(normal)));}vec3 unpackNormal(float packedNormal){return decodeOctWrap(unpackHalf2x16(floatBitsToUint(packedNormal)));}float packVec2(vec2 value){return uintBitsToFloat(packHalf2x16(value));}vec2 unpackVec2(float packedValue){return unpackHalf2x16(floatBitsToUint(packedValue));}vec4 encodeRGBE8(vec3 rgb){vec4 vEncoded;float maxComponent=max(max(rgb.r,rgb.g),rgb.b);float fExp=ceil(log2(maxComponent));vEncoded.rgb=rgb/exp2(fExp);vEncoded.a=(fExp+128.0)/255.0;return vEncoded;}vec3 decodeRGBE8(vec4 rgbe){vec3 vDecoded;float fExp=rgbe.a*255.0-128.0;vDecoded=rgbe.rgb*exp2(fExp);return vDecoded;}float vec4tofloat(vec4 vec){uvec4 v=uvec4(vec*255.0);uint value=(v.a<<24u)|(v.b<<16u)|(v.g<<8u)|(v.r);return uintBitsToFloat(value);}vec4 floattovec4(float f){uint value=floatBitsToUint(f);vec4 v;v.r=float(value&0xFFu)/255.0;v.g=float((value>>8u)&0xFFu)/255.0;v.b=float((value>>16u)&0xFFu)/255.0;v.a=float((value>>24u)&0xFFu)/255.0;return v;}void getGDataAndGBuffer(sampler2D gBufferTexture,vec2 uv,out vec3 diffuse,out vec3 normal,out float roughness,out float metalness,out vec4 gBuffer){gBuffer=textureLod(gBufferTexture,uv,0.);diffuse=float2color(gBuffer.r);normal=unpackNormal(gBuffer.g);vec2 roughnessMetalness=unpackVec2(gBuffer.b);roughness=roughnessMetalness.r;metalness=roughnessMetalness.g;}void getGData(sampler2D gBufferTexture,vec2 uv,out vec3 diffuse,out vec3 normal,out float roughness,out float metalness,out vec3 emissive){vec4 gBuffer;getGDataAndGBuffer(gBufferTexture,uv,diffuse,normal,roughness,metalness,gBuffer);emissive=decodeRGBE8(floattovec4(gBuffer.a));}void getGData(sampler2D gBufferTexture,vec2 uv,out vec3 diffuse,out vec3 normal,out float roughness,out float metalness){vec4 gBuffer;getGDataAndGBuffer(gBufferTexture,uv,diffuse,normal,roughness,metalness,gBuffer);}vec4 packGBuffer(vec3 diffuse,vec3 normal,float roughness,float metalness,vec3 emissive){vec4 gBuffer;gBuffer.r=color2float(diffuse);gBuffer.g=packNormal(normal);gBuffer.b=packVec2(vec2(roughness,metalness));gBuffer.a=vec4tofloat(encodeRGBE8(emissive));return gBuffer;}' // eslint-disable-line

var img =
  'data:image/png;base64,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'
var blueNoiseImage = img

var sampleBlueNoise = '#define GLSLIFY 1\nconst float g=1.6180339887498948482;const float a1=1.0/g;float r1(float n){return fract(1.1127756842787055+a1*n);}const vec4 hn=vec4(0.618033988749895,0.3247179572447458,0.2207440846057596,0.1673039782614187);vec4 sampleBlueNoise(sampler2D tex,int seed,vec2 repeat,vec2 texSize){vec2 size=vUv*texSize;vec2 blueNoiseSize=texSize/repeat;float blueNoiseIndex=floor(floor(size.y/blueNoiseSize.y)*repeat.x)+floor(size.x/blueNoiseSize.x);vec2 blueNoiseUv=vUv*repeat;vec4 blueNoise=textureLod(tex,blueNoiseUv,0.);if(seed!=0){blueNoise=fract(blueNoise+hn*float(seed));blueNoise.r=(blueNoise.r>0.5 ? 1.0-blueNoise.r : blueNoise.r)*2.0;blueNoise.g=(blueNoise.g>0.5 ? 1.0-blueNoise.g : blueNoise.g)*2.0;blueNoise.b=(blueNoise.b>0.5 ? 1.0-blueNoise.b : blueNoise.b)*2.0;blueNoise.a=(blueNoise.a>0.5 ? 1.0-blueNoise.a : blueNoise.a)*2.0;}return blueNoise;}' // eslint-disable-line

var fragmentShader$3 =
  '#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D inputTexture;uniform sampler2D inputTexture2;uniform sampler2D depthTexture;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;uniform float radius;uniform float phi;uniform float lumaPhi;uniform float depthPhi;uniform float normalPhi;uniform float roughnessPhi;uniform float diffusePhi;uniform sampler2D blueNoiseTexture;uniform vec2 blueNoiseRepeat;uniform int index;uniform vec2 resolution;layout(location=0)out vec4 gOutput0;layout(location=1)out vec4 gOutput1;\n#include <common>\n#include <gbuffer_packing>\n#include <sampleBlueNoise>\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nvec3 getWorldPos(float depth,vec2 coord){float z=depth*2.0-1.0;vec4 clipSpacePosition=vec4(coord*2.0-1.0,z,1.0);vec4 viewSpacePosition=projectionMatrixInverse*clipSpacePosition;vec4 worldSpacePosition=cameraMatrixWorld*viewSpacePosition;worldSpacePosition.xyz/=worldSpacePosition.w;return worldSpacePosition.xyz;}float getCurvature(vec3 n,float depth){vec3 dx=dFdx(n);vec3 dy=dFdy(n);vec3 xneg=n-dx;vec3 xpos=n+dx;vec3 yneg=n-dy;vec3 ypos=n+dy;float curvature=(cross(xneg,xpos).y-cross(yneg,ypos).x)*4.0/depth;return curvature;}float distToPlane(const vec3 worldPos,const vec3 neighborWorldPos,const vec3 worldNormal){vec3 toCurrent=worldPos-neighborWorldPos;float distToPlane=abs(dot(toCurrent,worldNormal));return distToPlane;}void toDenoiseSpace(inout vec3 color){color=log(color+1.);}void toLinearSpace(inout vec3 color){color=exp(color)-1.;}float getLuminanceWeight(float luminance,float a){return mix(1./(luminance+0.01),1.,1./pow(a+1.,4.));}void evaluateNeighbor(const vec4 neighborTexel,const float neighborLuminance,inout vec3 denoised,inout float totalWeight,const float basicWeight){float w=basicWeight;w*=getLuminanceWeight(neighborLuminance,neighborTexel.a);denoised+=w*neighborTexel.rgb;totalWeight+=w;}const vec2 poissonDisk[samples]=POISSON_DISK_SAMPLES;void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.);if(depthTexel.r==1.0){discard;return;}vec4 texel=textureLod(inputTexture,vUv,0.0);vec4 texel2=textureLod(inputTexture2,vUv,0.0);float lum=luminance(texel.rgb);float lum2=luminance(texel2.rgb);float totalWeight=getLuminanceWeight(lum,texel.a);float totalWeight2=getLuminanceWeight(lum2,texel2.a);toDenoiseSpace(texel.rgb);toDenoiseSpace(texel2.rgb);vec3 denoised=texel.rgb*totalWeight;vec3 denoised2=texel2.rgb*totalWeight2;vec3 diffuse,normal,emissive;float roughness,metalness;getGData(gBuffersTexture,vUv,diffuse,normal,roughness,metalness,emissive);float depth=depthTexel.x;vec3 worldPos=getWorldPos(depth,vUv);vec4 random=sampleBlueNoise(blueNoiseTexture,index,blueNoiseRepeat,resolution);float angle=random.r*2.*PI;float s=sin(angle),c=cos(angle);mat2 rotationMatrix=mat2(c,-s,s,c);float specularWeight=roughness*roughness>0.15 ? 1. : roughness*roughness/0.15;specularWeight=pow(specularWeight*specularWeight,4.);specularWeight=1.;float a=texel.a;float a2=texel2.a;float w=smoothstep(0.,1.,1./pow(a+1.,1./2.5));float w2=smoothstep(0.,1.,1./pow(a2+1.,1./2.5));float curvature=getCurvature(normal,depth);float r=mix(radius,4.,min(1.,curvature*curvature));for(int i=0;i<samples;i++){vec2 offset=r*rotationMatrix*poissonDisk[i];vec2 neighborUv=vUv+offset;vec4 neighborTexel=textureLod(inputTexture,neighborUv,0.);vec4 neighborTexel2=textureLod(inputTexture2,neighborUv,0.);float neighborLuminance=luminance(neighborTexel.rgb);float neighborLuminance2=luminance(neighborTexel2.rgb);toDenoiseSpace(neighborTexel.rgb);toDenoiseSpace(neighborTexel2.rgb);vec3 neighborNormal,neighborDiffuse;float neighborRoughness,neighborMetalness;getGData(gBuffersTexture,neighborUv,neighborDiffuse,neighborNormal,neighborRoughness,neighborMetalness);float neighborDepth=textureLod(depthTexture,neighborUv,0.0).x;vec3 neighborWorldPos=getWorldPos(neighborDepth,neighborUv);float normalDiff=1.-max(dot(normal,neighborNormal),0.);float depthDiff=10.*distToPlane(worldPos,neighborWorldPos,normal);float roughnessDiff=abs(roughness-neighborRoughness);float diffuseDiff=length(neighborDiffuse-diffuse);float lumaDiff=mix(abs(lum-neighborLuminance),0.,w);float lumaDiff2=mix(abs(lum2-neighborLuminance2),0.,w2);float basicWeight=float(neighborDepth!=1.0)*exp(-normalDiff*normalPhi-depthDiff*depthPhi-roughnessDiff*roughnessPhi-diffuseDiff*diffusePhi);float similarity=w*pow(basicWeight,phi/w)*exp(-lumaDiff*lumaPhi);float similarity2=w2*pow(basicWeight,phi/w2)*specularWeight*exp(-lumaDiff2*lumaPhi);evaluateNeighbor(neighborTexel,neighborLuminance,denoised,totalWeight,similarity);evaluateNeighbor(neighborTexel2,neighborLuminance2,denoised2,totalWeight2,similarity2);}denoised=totalWeight>0. ? denoised/totalWeight : texel.rgb;denoised2=totalWeight2>0. ? denoised2/totalWeight2 : texel2.rgb;toLinearSpace(denoised);toLinearSpace(denoised2);\n#define FINAL_OUTPUT\ngOutput0=vec4(denoised,texel.a);gOutput1=vec4(denoised2,texel2.a);}' // eslint-disable-line

function generateDenoiseSamples(numSamples, numRings, r, texelSize) {
  r = 1
  const angleStep = (2 * Math.PI * numRings) / numSamples
  const samples = []
  let angle = 0

  for (let i = 0; i < numSamples; i++) {
    const v = new Vector2(Math.cos(angle), Math.sin(angle)).multiply(texelSize).multiplyScalar(r)
    samples.push(v)
    angle += angleStep
  }

  return samples
}
function generatePoissonDiskConstant(poissonDisk) {
  const samples = poissonDisk.length
  let glslCode = 'vec2[' + samples + ']('

  for (let i = 0; i < samples; i++) {
    const sample = poissonDisk[i]
    glslCode += `vec2(${sample.x}, ${sample.y})`

    if (i < samples - 1) {
      glslCode += ','
    }
  }

  glslCode += ')'
  return glslCode
}

const finalFragmentShader$1 = fragmentShader$3.replace('#include <sampleBlueNoise>', sampleBlueNoise).replace('#include <gbuffer_packing>', gbuffer_packing)
const defaultPoissonBlurOptions = {
  iterations: 1,
  radius: 3,
  rings: 3,
  phi: 0.5,
  lumaPhi: 5,
  depthPhi: 2,
  normalPhi: 3.25,
  samples: 8
}

var _updatePoissionDiskSamples = /*#__PURE__*/ _classPrivateFieldLooseKey('updatePoissionDiskSamples')

class PoissionDenoisePass extends Pass {
  constructor(camera, inputTexture, depthTexture, options = defaultPoissonBlurOptions) {
    super('PoissionBlurPass')
    Object.defineProperty(this, _updatePoissionDiskSamples, {
      value: _updatePoissionDiskSamples2
    })
    this.iterations = defaultPoissonBlurOptions.iterations
    this.index = 0
    options = { ...defaultPoissonBlurOptions, ...options }
    this.inputTexture = inputTexture
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader: finalFragmentShader$1,
      vertexShader,
      uniforms: {
        depthTexture: {
          value: null
        },
        inputTexture: {
          value: null
        },
        inputTexture2: {
          value: null
        },
        gBuffersTexture: {
          value: null
        },
        projectionMatrixInverse: {
          value: new Matrix4()
        },
        cameraMatrixWorld: {
          value: new Matrix4()
        },
        viewMatrix: {
          value: new Matrix4()
        },
        radius: {
          value: defaultPoissonBlurOptions.radius
        },
        phi: {
          value: defaultPoissonBlurOptions.lumaPhi
        },
        lumaPhi: {
          value: defaultPoissonBlurOptions.lumaPhi
        },
        depthPhi: {
          value: defaultPoissonBlurOptions.depthPhi
        },
        normalPhi: {
          value: defaultPoissonBlurOptions.normalPhi
        },
        roughnessPhi: {
          value: defaultPoissonBlurOptions.roughnessPhi
        },
        diffusePhi: {
          value: defaultPoissonBlurOptions.diffusePhi
        },
        resolution: {
          value: new Vector2()
        },
        blueNoiseTexture: {
          value: null
        },
        index: {
          value: 0
        },
        blueNoiseRepeat: {
          value: new Vector2()
        }
      },
      glslVersion: GLSL3
    })
    const renderTargetOptions = {
      type: HalfFloatType,
      depthBuffer: false
    }
    this.renderTargetA = new WebGLMultipleRenderTargets(1, 1, 2, renderTargetOptions)
    this.renderTargetB = new WebGLMultipleRenderTargets(1, 1, 2, renderTargetOptions)
    const { uniforms } = this.fullscreenMaterial
    uniforms['inputTexture'].value = this.inputTexture
    uniforms['depthTexture'].value = depthTexture
    uniforms['projectionMatrixInverse'].value = camera.projectionMatrixInverse
    uniforms['cameraMatrixWorld'].value = camera.matrixWorld
    uniforms['viewMatrix'].value = camera.matrixWorldInverse
    uniforms['depthPhi'].value = options.depthPhi
    uniforms['normalPhi'].value = options.normalPhi // these properties need the shader to be recompiled

    for (const prop of ['radius', 'rings', 'samples']) {
      Object.defineProperty(this, prop, {
        get: () => options[prop],
        set: (value) => {
          options[prop] = value
          this.setSize(this.renderTargetA.width, this.renderTargetA.height)
        }
      })
    }

    new TextureLoader().load(blueNoiseImage, (blueNoiseTexture) => {
      blueNoiseTexture.minFilter = NearestFilter
      blueNoiseTexture.magFilter = NearestFilter
      blueNoiseTexture.wrapS = RepeatWrapping
      blueNoiseTexture.wrapT = RepeatWrapping
      blueNoiseTexture.colorSpace = NoColorSpace
      this.fullscreenMaterial.uniforms.blueNoiseTexture.value = blueNoiseTexture
    })
  }

  setSize(width, height) {
    this.renderTargetA.setSize(width, height)
    this.renderTargetB.setSize(width, height)
    this.fullscreenMaterial.uniforms.resolution.value.set(width, height)

    _classPrivateFieldLooseBase(this, _updatePoissionDiskSamples)[_updatePoissionDiskSamples](width, height)
  }

  get texture() {
    return this.renderTargetB.texture
  }

  setGBuffersTexture(texture) {
    this.fullscreenMaterial.uniforms.gBuffersTexture.value = texture
  }

  render(renderer) {
    const noiseTexture = this.fullscreenMaterial.uniforms.blueNoiseTexture.value

    if (noiseTexture) {
      const { width, height } = noiseTexture.source.data
      this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTargetA.width / width, this.renderTargetA.height / height)
    }

    for (let i = 0; i < 2 * this.iterations; i++) {
      const horizontal = i % 2 === 0
      const inputRenderTarget = horizontal ? this.renderTargetB : this.renderTargetA
      this.fullscreenMaterial.uniforms['inputTexture'].value = i === 0 ? this.inputTexture : inputRenderTarget.texture[0]
      this.fullscreenMaterial.uniforms['inputTexture2'].value = i === 0 ? this.inputTexture2 : inputRenderTarget.texture[1]
      const renderTarget = horizontal ? this.renderTargetA : this.renderTargetB
      renderer.setRenderTarget(renderTarget)
      renderer.render(this.scene, this.camera)
      this.fullscreenMaterial.uniforms.index.value++
      this.fullscreenMaterial.uniforms.index.value %= 65536
    }
  }
}

function _updatePoissionDiskSamples2(width, height) {
  const poissonDisk = generateDenoiseSamples(this.samples, this.rings, this.radius, new Vector2(1 / width, 1 / height))
  this.fullscreenMaterial.defines.samples = this.samples
  const poissonDiskConstant = generatePoissonDiskConstant(poissonDisk)
  this.fullscreenMaterial.defines.POISSON_DISK_SAMPLES = poissonDiskConstant
  this.fullscreenMaterial.needsUpdate = true
}

PoissionDenoisePass.DefaultOptions = defaultPoissonBlurOptions

class SVGF {
  constructor(scene, camera, velocityDepthNormalPass, textureCount = 1, options = {}) {
    this.svgfTemporalReprojectPass = new TemporalReprojectPass(scene, camera, velocityDepthNormalPass, textureCount, { ...options, fullAccumulate: true, logTransform: true })
    const textures = this.svgfTemporalReprojectPass.renderTarget.texture.slice(0, textureCount) // this.denoisePass = new DenoisePass(camera, textures, options)
    // this.denoisePass.setMomentTexture(this.svgfTemporalReprojectPass.momentTexture)

    this.denoisePass = new PoissionDenoisePass(camera, textures[0], window.depthTexture, options)
    this.denoisePass.inputTexture2 = textures[1]
    this.svgfTemporalReprojectPass.overrideAccumulatedTextures = this.denoisePass.renderTargetB.texture
    this.setNonJitteredDepthTexture(velocityDepthNormalPass.depthTexture)
  } // the denoised texture

  get texture() {
    return this.denoisePass.texture
  }

  setGBuffers(depthTexture, normalTexture) {
    this.setJitteredGBuffers(depthTexture, normalTexture)
    this.setNonJitteredGBuffers(depthTexture, normalTexture)
  }

  setJitteredGBuffers(depthTexture, normalTexture, { useRoughnessInAlphaChannel = false } = {}) {
    // this.denoisePass.setDepthTexture(depthTexture)
    // this.denoisePass.setNormalTexture(normalTexture, { useRoughnessInAlphaChannel })
  }

  setNonJitteredDepthTexture(depthTexture) {
    this.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.depthTexture.value = depthTexture
  }

  setVelocityTexture(texture) {
    this.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.velocityTexture.value = texture
  }

  setSize(width, height) {
    this.denoisePass.setSize(width, height)
    this.svgfTemporalReprojectPass.setSize(width, height)
  }

  dispose() {
    this.denoisePass.dispose()
    this.svgfTemporalReprojectPass.dispose()
  }

  render(renderer) {
    this.svgfTemporalReprojectPass.render(renderer)
    this.denoisePass.render(renderer)
  }
}

class CubeToEquirectEnvPass extends Pass {
  constructor() {
    super('CubeToEquirectEnvPass')
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      depthBuffer: false,
      type: FloatType
    })
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader:
        /* glsl */
        `
            varying vec2 vUv;
			uniform samplerCube cubeMap;

			#define M_PI 3.1415926535897932384626433832795
			
			// source: https://github.com/spite/CubemapToEquirectangular/blob/master/src/CubemapToEquirectangular.js
            void main() {
				float longitude = vUv.x * 2. * M_PI - M_PI + M_PI / 2.;
				float latitude = vUv.y * M_PI;

				vec3 dir = vec3(
					- sin( longitude ) * sin( latitude ),
					cos( latitude ),
					- cos( longitude ) * sin( latitude )
				);

				dir.y = -dir.y;

				gl_FragColor = textureCube( cubeMap, dir );
            }
            `,
      vertexShader: vertexShader,
      uniforms: {
        cubeMap: {
          value: null
        }
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    })
  }

  dispose() {
    this.renderTarget.dispose()
  }

  generateEquirectEnvMap(renderer, cubeMap, width = null, height = null, maxWidth = 4096) {
    if (width === null && height === null) {
      const w = cubeMap.source.data[0].width
      const widthEquirect = 2 ** Math.ceil(Math.log2(2 * w * 3 ** 0.5))
      const heightEquirect = 2 ** Math.ceil(Math.log2(w * 3 ** 0.5))
      width = widthEquirect
      height = heightEquirect
    }

    if (width > maxWidth) {
      width = maxWidth
      height = maxWidth / 2
    }

    this.renderTarget.setSize(width, height)
    this.fullscreenMaterial.uniforms.cubeMap.value = cubeMap
    const { renderTarget } = this
    renderer.setRenderTarget(renderTarget)
    renderer.render(this.scene, this.camera) // Create a new Float32Array to store the pixel data

    const pixelBuffer = new Float32Array(width * height * 4)
    renderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, pixelBuffer) // Create a new data texture

    const equirectEnvMap = new DataTexture(pixelBuffer, width, height, RGBAFormat, FloatType) // Set texture options

    equirectEnvMap.wrapS = ClampToEdgeWrapping
    equirectEnvMap.wrapT = ClampToEdgeWrapping
    equirectEnvMap.minFilter = LinearMipMapLinearFilter
    equirectEnvMap.magFilter = LinearMipMapLinearFilter
    equirectEnvMap.needsUpdate = true
    equirectEnvMap.mapping = EquirectangularReflectionMapping
    return equirectEnvMap
  }
}

// and velocity to "gVelocity" buffer

class MRTMaterial extends ShaderMaterial {
  constructor() {
    super({
      type: 'MRTMaterial',
      defines: {
        USE_UV: '',
        TEMPORAL_RESOLVE: ''
      },
      uniforms: {
        color: new Uniform(new Color()),
        emissive: new Uniform(new Color()),
        map: new Uniform(null),
        roughnessMap: new Uniform(null),
        metalnessMap: new Uniform(null),
        emissiveMap: new Uniform(null),
        alphaMap: new Uniform(null),
        normalMap: new Uniform(null),
        normalScale: new Uniform(new Vector2(1, 1)),
        roughness: new Uniform(0),
        metalness: new Uniform(0),
        emissiveIntensity: new Uniform(0),
        uvTransform: new Uniform(new Matrix3()),
        boneTexture: new Uniform(null),
        blueNoiseTexture: new Uniform(null),
        blueNoiseRepeat: new Uniform(new Vector2(1, 1)),
        texSize: new Uniform(new Vector2(1, 1)),
        frame: new Uniform(0),
        lightMap: new Uniform(null),
        lightMapIntensity: new Uniform(1)
      },
      vertexShader:
        /* glsl */
        `
                varying vec2 vHighPrecisionZW;

                #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                
                #include <common>
                #include <uv_pars_vertex>
                #include <displacementmap_pars_vertex>
                #include <normal_pars_vertex>
                #include <morphtarget_pars_vertex>
                #include <logdepthbuf_pars_vertex>
                #include <clipping_planes_pars_vertex>
                #include <skinning_pars_vertex>
                #include <color_pars_vertex>

                varying vec2 screenUv;

                void main() {
                    #include <uv_vertex>
                    
                    #include <skinbase_vertex>
                    #include <beginnormal_vertex>
                    #include <skinnormal_vertex>
                    #include <defaultnormal_vertex>

                    #include <morphnormal_vertex>
                    #include <normal_vertex>
                    #include <begin_vertex>
                    #include <morphtarget_vertex>

                    #include <skinning_vertex>

                    #include <displacementmap_vertex>
                    #include <project_vertex>
                    #include <logdepthbuf_vertex>
                    #include <clipping_planes_vertex>

                    #include <color_vertex>
                    
                    #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                        vViewPosition = - mvPosition.xyz;
                    #endif

                    screenUv = gl_Position.xy * 0.5 + 0.5;

                    vHighPrecisionZW = gl_Position.zw;
                }
            `,
      fragmentShader:
        /* glsl */
        `
                #define NORMAL
                #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
                    varying vec3 vViewPosition;
                #endif
                #include <packing>
                #include <uv_pars_fragment>
                #include <normal_pars_fragment>
                #include <bumpmap_pars_fragment>
                #include <normalmap_pars_fragment>
                #include <logdepthbuf_pars_fragment>
                #include <clipping_planes_pars_fragment>
                #include <color_pars_fragment>
                #include <alphamap_pars_fragment>
                #include <lightmap_pars_fragment>

                #include <map_pars_fragment>
                uniform vec3 color;

                varying vec2 vHighPrecisionZW;

                #include <metalnessmap_pars_fragment>
                uniform float metalness;

                #include <roughnessmap_pars_fragment>
                uniform float roughness;

                #include <emissivemap_pars_fragment>
                uniform vec3 emissive;
                uniform float emissiveIntensity;

            #ifdef USE_ALPHAMAP
                uniform sampler2D blueNoiseTexture;
                uniform vec2 blueNoiseRepeat;
                uniform vec2 texSize;
                uniform int frame;

                varying vec2 screenUv;

                const float g = 1.6180339887498948482;
                const float a1 = 1.0 / g;

                // reference: https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
                float r1(float n) {
                    // 7th harmonious number
                    return fract(1.1127756842787055 + a1 * n);
                }

                const vec4 hn = vec4(0.618033988749895, 0.3247179572447458, 0.2207440846057596, 0.1673039782614187);

                vec4 sampleBlueNoise(vec2 uv, int seed) {
                    vec2 size = uv * texSize;
                    vec2 blueNoiseSize = texSize / blueNoiseRepeat;
                    float blueNoiseIndex = floor(floor(size.y / blueNoiseSize.y) * blueNoiseRepeat.x) + floor(size.x / blueNoiseSize.x);

                    // get the offset of this pixel's blue noise tile
                    int blueNoiseTileOffset = int(r1(blueNoiseIndex + 1.0) * 65536.);

                    vec2 blueNoiseUv = uv * blueNoiseRepeat;

                    // fetch blue noise for this pixel
                    vec4 blueNoise = textureLod(blueNoiseTexture, blueNoiseUv, 0.);

                    // animate blue noise
                    blueNoise = fract(blueNoise + hn * float(seed + blueNoiseTileOffset));

                    blueNoise.r = (blueNoise.r > 0.5 ? 1.0 - blueNoise.r : blueNoise.r) * 2.0;
                    blueNoise.g = (blueNoise.g > 0.5 ? 1.0 - blueNoise.g : blueNoise.g) * 2.0;
                    blueNoise.b = (blueNoise.b > 0.5 ? 1.0 - blueNoise.b : blueNoise.b) * 2.0;
                    blueNoise.a = (blueNoise.a > 0.5 ? 1.0 - blueNoise.a : blueNoise.a) * 2.0;

                    return blueNoise;
                }
            #endif

                #include <gbuffer_packing>

                struct ReflectedLight {
                    vec3 indirectDiffuse;
                };

                void main() {
                    // !todo: properly implement alpha hashing
                    // #ifdef USE_ALPHAMAP
                    // float alpha = textureLod( alphaMap, vUv, 0. ).g;

                    // float alphaThreshold = sampleBlueNoise(screenUv, frame).a;
                    // if(alpha < alphaThreshold){
                    //     discard;
                    //     return;
                    // }
                    // #endif

                    //! todo: find better solution
                    //! todo: also fix texture repeat issue (not being repeated)
                    #define vMapUv vUv
                    #define vMetalnessMapUv vUv
                    #define vRoughnessMapUv vUv
                    #define vNormalMapUv vUv
                    #define vEmissiveMapUv vUv
                    #define vLightMapUv vUv
                    #define vEmissiveMapUv vUv

                    #include <clipping_planes_fragment>
                    #include <logdepthbuf_fragment>
                    #include <normal_fragment_begin>
                    #include <normal_fragment_maps>

                    float roughnessFactor = roughness;
                    bool isDeselected = roughness > 10.0e9;

                    #ifdef USE_ROUGHNESSMAP
                        vec4 texelRoughness = textureLod( roughnessMap, vUv, 0. );
                        // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
                        roughnessFactor *= texelRoughness.g;
                    #endif

                    // roughness of 1.0 is reserved for deselected meshes
                    roughnessFactor = min(0.99, roughnessFactor);

                    vec3 worldNormal = normalize((vec4(normal, 1.) * viewMatrix).xyz);

                    if(isDeselected){
                        discard;
                        return;
                    }

                    #include <metalnessmap_fragment>

                    vec4 diffuseColor = vec4(color, metalnessFactor);

                    #include <map_fragment>
                    #include <color_fragment>

                    vec3 totalEmissiveRadiance = vec3( emissive * emissiveIntensity );
                    #include <emissivemap_fragment>

                    ReflectedLight reflectedLight;

                    #include <lightmap_fragment>

                    #ifdef USE_LIGHTMAP
                        diffuseColor.rgb *= reflectedLight.indirectDiffuse;
                    #endif

                    gl_FragColor = packGBuffer(diffuseColor.rgb, worldNormal, roughnessFactor, metalnessFactor, totalEmissiveRadiance);
                }
            `.replace('#include <gbuffer_packing>', gbuffer_packing),
      toneMapped: false,
      alphaTest: false,
      fog: false,
      lights: false
    })
    this.normalMapType = TangentSpaceNormalMap
    this.normalScale = new Vector2(1, 1)
  }
}

var fragmentShader$2 =
  '#define GLSLIFY 1\n#if !defined(diffuseOnly) && !defined(specularOnly)\nlayout(location=0)out vec4 gDiffuse;layout(location=1)out vec4 gSpecular;\n#else\n#ifdef diffuseOnly\nlayout(location=0)out vec4 gDiffuse;\n#else\nlayout(location=0)out vec4 gSpecular;\n#endif\n#endif\nvarying vec2 vUv;uniform sampler2D accumulatedTexture;uniform sampler2D depthTexture;uniform sampler2D blueNoiseTexture;uniform sampler2D velocityTexture;uniform mat4 projectionMatrix;uniform mat4 inverseProjectionMatrix;uniform mat4 cameraMatrixWorld;uniform float cameraNear;uniform float cameraFar;uniform float maxEnvMapMipLevel;uniform float rayDistance;uniform float maxRoughness;uniform float thickness;uniform float envBlur;uniform int frame;uniform vec2 texSize;uniform vec2 blueNoiseRepeat;struct EquirectHdrInfo{sampler2D marginalWeights;sampler2D conditionalWeights;sampler2D map;vec2 size;float totalSumWhole;float totalSumDecimal;};uniform EquirectHdrInfo envMapInfo;\n#define INVALID_RAY_COORDS vec2(-1.0);\n#define EPSILON 0.00001\n#define ONE_MINUS_EPSILON 1.0 - EPSILON\nfloat nearMinusFar;float nearMulFar;float farMinusNear;vec2 invTexSize;\n#include <packing>\n#include <gbuffer_packing>\n#include <sampleBlueNoise>\n#include <ssgi_utils>\nvec2 RayMarch(inout vec3 dir,inout vec3 hitPos);vec2 BinarySearch(inout vec3 dir,inout vec3 hitPos);float fastGetViewZ(const float depth);vec3 doSample(const vec3 viewPos,const vec3 viewDir,const vec3 viewNormal,const vec3 worldPosition,const float metalness,const float roughness,const bool isDiffuseSample,const bool isEnvMisSample,const float NoV,const float NoL,const float NoH,const float LoH,const float VoH,const vec2 random,inout vec3 l,inout vec3 hitPos,out bool isMissedRay,out vec3 brdf,out float pdf);void main(){vec4 depthTexel=textureLod(depthTexture,vUv,0.0);if(depthTexel.r==1.0){discard;return;}vec3 diffuse,normal,emissive;float roughness,metalness;getGData(gBuffersTexture,vUv,diffuse,normal,roughness,metalness,emissive);if(roughness==1.0||roughness>maxRoughness){discard;return;}invTexSize=1./texSize;roughness=clamp(roughness*roughness,0.0001,1.0);nearMinusFar=cameraNear-cameraFar;nearMulFar=cameraNear*cameraFar;farMinusNear=cameraFar-cameraNear;float unpackedDepth=depthTexel.r;float depth=fastGetViewZ(unpackedDepth);vec3 viewPos=getViewPosition(depth);vec3 viewDir=normalize(viewPos);vec3 worldNormal=normal;vec3 viewNormal=normalize((vec4(worldNormal,0.)*cameraMatrixWorld).xyz);vec3 worldPos=vec4(vec4(viewPos,1.)*viewMatrix).xyz;vec3 n=viewNormal;vec3 v=-viewDir;float NoV=max(EPSILON,dot(n,v));vec3 V=(vec4(v,0.)*viewMatrix).xyz;vec3 N=worldNormal;vec4 blueNoise;vec3 H,l,h,F,T,B,envMisDir,gi;vec3 diffuseGI,specularGI,brdf,hitPos,specularHitPos;Onb(N,T,B);V=ToLocal(T,B,N,V);vec3 f0=mix(vec3(0.04),diffuse,metalness);float NoL,NoH,LoH,VoH,diffW,specW,invW,pdf,envPdf,diffuseSamples,specularSamples,envMisProbability,envMisMultiplier;bool isDiffuseSample,isEnvMisSample,isMissedRay;int sampleCounter=0;\n#pragma unroll_loop_start\nfor(int i=0;i<spp;i++){blueNoise=sampleBlueNoise(blueNoiseTexture,frame+sampleCounter++,blueNoiseRepeat,texSize);H=SampleGGXVNDF(V,roughness,roughness,blueNoise.r,blueNoise.g);if(H.z<0.0)H=-H;l=normalize(reflect(-V,H));l=ToWorld(T,B,N,l);l=(vec4(l,0.)*cameraMatrixWorld).xyz;l=normalize(l);h=normalize(v+l);NoL=clamp(dot(n,l),EPSILON,ONE_MINUS_EPSILON);NoH=clamp(dot(n,h),EPSILON,ONE_MINUS_EPSILON);LoH=clamp(dot(l,h),EPSILON,ONE_MINUS_EPSILON);VoH=clamp(dot(v,h),EPSILON,ONE_MINUS_EPSILON);\n#if !defined(diffuseOnly) && !defined(specularOnly)\nF=F_Schlick(f0,VoH);diffW=(1.-metalness)*luminance(diffuse);specW=luminance(F);diffW=max(diffW,EPSILON);specW=max(specW,EPSILON);invW=1./(diffW+specW);diffW*=invW;specW*=invW;isDiffuseSample=blueNoise.b<diffW;\n#else\n#ifdef diffuseOnly\nisDiffuseSample=true;\n#else\nisDiffuseSample=false;\n#endif\n#endif\nenvMisDir=vec3(0.0);\n#ifdef importanceSampling\nenvPdf=sampleEquirectProbability(envMapInfo,blueNoise.rg,envMisDir);envMisDir=normalize((vec4(envMisDir,0.)*cameraMatrixWorld).xyz);envMisProbability=0.25+dot(envMisDir,viewNormal)*0.5;isEnvMisSample=blueNoise.a<envMisProbability;envMisMultiplier=1./(1.-envMisProbability);if(isEnvMisSample){envPdf/=1.-envMisProbability;}else{envPdf=0.0001;}\n#else\nenvPdf=0.0;envMisMultiplier=1.;\n#endif\nenvPdf=clamp(envPdf,0.01,4.0);if(isDiffuseSample){if(isEnvMisSample){l=envMisDir;}else{l=cosineSampleHemisphere(viewNormal,blueNoise.rg);}h=normalize(v+l);NoL=clamp(dot(n,l),EPSILON,ONE_MINUS_EPSILON);NoH=clamp(dot(n,h),EPSILON,ONE_MINUS_EPSILON);LoH=clamp(dot(l,h),EPSILON,ONE_MINUS_EPSILON);VoH=clamp(dot(v,h),EPSILON,ONE_MINUS_EPSILON);gi=doSample(viewPos,viewDir,viewNormal,worldPos,metalness,roughness,isDiffuseSample,isEnvMisSample,NoV,NoL,NoH,LoH,VoH,blueNoise.rg,l,hitPos,isMissedRay,brdf,pdf);gi*=brdf;if(isEnvMisSample){gi*=misHeuristic(envPdf,pdf);gi/=envPdf;}else{gi/=pdf;gi*=envMisMultiplier;}diffuseSamples++;diffuseGI=mix(diffuseGI,gi,1./diffuseSamples);}else{isEnvMisSample=isEnvMisSample&&roughness>=0.025;if(isEnvMisSample){l=envMisDir;h=normalize(v+l);NoL=clamp(dot(n,l),EPSILON,ONE_MINUS_EPSILON);NoH=clamp(dot(n,h),EPSILON,ONE_MINUS_EPSILON);LoH=clamp(dot(l,h),EPSILON,ONE_MINUS_EPSILON);VoH=clamp(dot(v,h),EPSILON,ONE_MINUS_EPSILON);}gi=doSample(viewPos,viewDir,viewNormal,worldPos,metalness,roughness,isDiffuseSample,isEnvMisSample,NoV,NoL,NoH,LoH,VoH,blueNoise.rg,l,hitPos,isMissedRay,brdf,pdf);gi*=brdf;if(isEnvMisSample){gi*=misHeuristic(envPdf,pdf);gi/=envPdf;}else{gi/=pdf;gi*=envMisMultiplier;}specularHitPos=hitPos;specularSamples++;specularGI=mix(specularGI,gi,1./specularSamples);}}\n#pragma unroll_loop_end\nroughness=sqrt(roughness);\n#ifndef specularOnly\nif(diffuseSamples==0.0)diffuseGI=vec3(-1.0);gDiffuse=vec4(diffuseGI,roughness);\n#endif\n#ifndef diffuseOnly\nfloat rayLength=0.0;vec4 hitPosWS;if(!isMissedRay){hitPosWS=cameraMatrixWorld*vec4(specularHitPos,1.0);vec3 cameraPosWS=cameraMatrixWorld[3].xyz;rayLength=distance(cameraPosWS,hitPosWS.xyz);}if(specularSamples==0.0)specularGI=vec3(-1.0);gSpecular=vec4(specularGI,rayLength);\n#endif\n}vec3 doSample(const vec3 viewPos,const vec3 viewDir,const vec3 viewNormal,const vec3 worldPosition,const float metalness,const float roughness,const bool isDiffuseSample,const bool isEnvMisSample,const float NoV,const float NoL,const float NoH,const float LoH,const float VoH,const vec2 random,inout vec3 l,inout vec3 hitPos,out bool isMissedRay,out vec3 brdf,out float pdf){float cosTheta=max(0.0,dot(viewNormal,l));if(isDiffuseSample){vec3 diffuseBrdf=vec3(evalDisneyDiffuse(NoL,NoV,LoH,roughness,metalness));pdf=NoL/M_PI;pdf=max(EPSILON,pdf);brdf=diffuseBrdf;}else{vec3 specularBrdf=evalDisneySpecular(roughness,NoH,NoV,NoL);pdf=GGXVNDFPdf(NoH,NoV,roughness);pdf=max(EPSILON,pdf);brdf=specularBrdf;}brdf*=cosTheta;hitPos=viewPos;\n#if steps == 0\nhitPos+=l;vec2 coords=viewSpaceToScreenSpace(hitPos);\n#else\nvec2 coords=RayMarch(l,hitPos);\n#endif\nbool allowMissedRays=false;\n#ifdef missedRays\nallowMissedRays=true;\n#endif\nisMissedRay=coords.x==-1.0;vec3 envMapSample=vec3(0.);if(isMissedRay||allowMissedRays){\n#ifdef USE_ENVMAP\nvec3 reflectedWS=normalize((vec4(l,0.)*viewMatrix).xyz);\n#ifdef BOX_PROJECTED_ENV_MAP\nreflectedWS=parallaxCorrectNormal(reflectedWS.xyz,envMapSize,envMapPosition,worldPosition);reflectedWS=normalize(reflectedWS.xyz);\n#endif\nfloat mip=envBlur*maxEnvMapMipLevel;if(!isDiffuseSample&&roughness<0.15)mip*=roughness/0.15;envMapSample=sampleEquirectEnvMapColor(reflectedWS,envMapInfo.map,mip);float maxEnvLum=isEnvMisSample ? 50.0 : 10.0;if(maxEnvLum!=0.0){float envLum=luminance(envMapSample);if(envLum>maxEnvLum){envMapSample*=maxEnvLum/envLum;}}return envMapSample;\n#else\nreturn vec3(0.0);\n#endif\n}vec4 velocity=textureLod(velocityTexture,coords.xy,0.0);vec2 reprojectedUv=coords.xy-velocity.xy;vec3 SSGI;if(reprojectedUv.x>=0.0&&reprojectedUv.x<=1.0&&reprojectedUv.y>=0.0&&reprojectedUv.y<=1.0){vec3 reprojectedGI=getTexel(accumulatedTexture,reprojectedUv,0.).rgb;SSGI=reprojectedGI;}if(allowMissedRays){float ssgiLum=luminance(SSGI);float envLum=luminance(envMapSample);if(envLum>ssgiLum)SSGI=envMapSample;}return SSGI;}vec2 RayMarch(inout vec3 dir,inout vec3 hitPos){float rayHitDepthDifference;dir*=rayDistance/float(steps);vec2 uv;for(int i=1;i<steps;i++){float m=exp(pow(float(i)/4.0,0.05))-2.0;hitPos+=dir*min(m,1.);if(hitPos.z>0.0)return INVALID_RAY_COORDS;uv=viewSpaceToScreenSpace(hitPos);\n#ifndef missedRays\nif(uv.x<0.||uv.y<0.||uv.x>1.||uv.y>1.)return INVALID_RAY_COORDS;\n#endif\nfloat unpackedDepth=textureLod(depthTexture,uv,0.0).r;float depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;if(rayHitDepthDifference>=0.0&&rayHitDepthDifference<thickness){\n#if refineSteps == 0\nreturn uv;\n#else\nreturn BinarySearch(dir,hitPos);\n#endif\n}}\n#ifndef missedRays\nreturn INVALID_RAY_COORDS;\n#endif\nreturn uv;}vec2 BinarySearch(inout vec3 dir,inout vec3 hitPos){float rayHitDepthDifference;vec2 uv;dir*=0.5;hitPos-=dir;for(int i=0;i<refineSteps;i++){uv=viewSpaceToScreenSpace(hitPos);float unpackedDepth=unpackRGBAToDepth(textureLod(depthTexture,uv,0.0));float depth=fastGetViewZ(unpackedDepth);rayHitDepthDifference=depth-hitPos.z;dir*=0.5;hitPos+=rayHitDepthDifference>0.0 ?-dir : dir;}uv=viewSpaceToScreenSpace(hitPos);return uv;}float fastGetViewZ(const float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn nearMulFar/(farMinusNear*depth-cameraFar);\n#else\nreturn depth*nearMinusFar-cameraNear;\n#endif\n}' // eslint-disable-line

var ssgi_utils =
  '#define GLSLIFY 1\n#define PI M_PI\n#define luminance(a) dot(vec3(0.2125, 0.7154, 0.0721), a)\nvec4 getTexel(const sampler2D tex,vec2 p,const float mip){p=p/invTexSize+0.5;vec2 i=floor(p);vec2 f=p-i;f=f*f*f*(f*(f*6.0-15.0)+10.0);p=i+f;p=(p-0.5)*invTexSize;return textureLod(tex,p,mip);}float getViewZ(const float depth){return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);}vec3 getViewPosition(const float depth){float clipW=projectionMatrix[2][3]*depth+projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}vec2 viewSpaceToScreenSpace(const vec3 position){vec4 projectedCoord=projectionMatrix*vec4(position,1.0);projectedCoord.xy/=projectedCoord.w;projectedCoord.xy=projectedCoord.xy*0.5+0.5;return projectedCoord.xy;}vec3 worldSpaceToViewSpace(vec3 worldPosition){vec4 viewPosition=viewMatrix*vec4(worldPosition,1.0);return viewPosition.xyz/viewPosition.w;}\n#ifdef BOX_PROJECTED_ENV_MAP\nuniform vec3 envMapSize;uniform vec3 envMapPosition;vec3 parallaxCorrectNormal(const vec3 v,const vec3 cubeSize,const vec3 cubePos,const vec3 worldPosition){vec3 nDir=normalize(v);vec3 rbmax=(.5*cubeSize+cubePos-worldPosition)/nDir;vec3 rbmin=(-.5*cubeSize+cubePos-worldPosition)/nDir;vec3 rbminmax;rbminmax.x=(nDir.x>0.)? rbmax.x : rbmin.x;rbminmax.y=(nDir.y>0.)? rbmax.y : rbmin.y;rbminmax.z=(nDir.z>0.)? rbmax.z : rbmin.z;float correction=min(min(rbminmax.x,rbminmax.y),rbminmax.z);vec3 boxIntersection=worldPosition+nDir*correction;return boxIntersection-cubePos;}\n#endif\n#define M_PI 3.1415926535897932384626433832795\nvec2 equirectDirectionToUv(const vec3 direction){vec2 uv=vec2(atan(direction.z,direction.x),acos(direction.y));uv/=vec2(2.0*M_PI,M_PI);uv.x+=0.5;uv.y=1.0-uv.y;return uv;}vec3 equirectUvToDirection(vec2 uv){uv.x-=0.5;uv.y=1.0-uv.y;float theta=uv.x*2.0*PI;float phi=uv.y*PI;float sinPhi=sin(phi);return vec3(sinPhi*cos(theta),cos(phi),sinPhi*sin(theta));}vec3 sampleEquirectEnvMapColor(const vec3 direction,const sampler2D map,const float lod){return getTexel(map,equirectDirectionToUv(direction),lod).rgb;}mat3 getBasisFromNormal(const vec3 normal){vec3 other;if(abs(normal.x)>0.5){other=vec3(0.0,1.0,0.0);}else{other=vec3(1.0,0.0,0.0);}vec3 ortho=normalize(cross(normal,other));vec3 ortho2=normalize(cross(normal,ortho));return mat3(ortho2,ortho,normal);}vec3 F_Schlick(const vec3 f0,const float theta){return f0+(1.-f0)*pow(1.0-theta,5.);}float F_Schlick(const float f0,const float f90,const float theta){return f0+(f90-f0)*pow(1.0-theta,5.0);}float D_GTR(const float roughness,const float NoH,const float k){float a2=pow(roughness,2.);return a2/(PI*pow((NoH*NoH)*(a2*a2-1.)+1.,k));}float SmithG(const float NDotV,const float alphaG){float a=alphaG*alphaG;float b=NDotV*NDotV;return(2.0*NDotV)/(NDotV+sqrt(a+b-a*b));}float GGXVNDFPdf(const float NoH,const float NoV,const float roughness){float D=D_GTR(roughness,NoH,2.);float G1=SmithG(NoV,roughness*roughness);return(D*G1)/max(0.00001,4.0f*NoV);}float GeometryTerm(const float NoL,const float NoV,const float roughness){float a2=roughness*roughness;float G1=SmithG(NoV,a2);float G2=SmithG(NoL,a2);return G1*G2;}float evalDisneyDiffuse(const float NoL,const float NoV,const float LoH,const float roughness,const float metalness){float FD90=0.5+2.*roughness*pow(LoH,2.);float a=F_Schlick(1.,FD90,NoL);float b=F_Schlick(1.,FD90,NoV);return(a*b/PI)*(1.-metalness);}vec3 evalDisneySpecular(const float roughness,const float NoH,const float NoV,const float NoL){float D=D_GTR(roughness,NoH,2.);float G=GeometryTerm(NoL,NoV,pow(0.5+roughness*.5,2.));vec3 spec=vec3(D*G/(4.*NoL*NoV));return spec;}vec3 SampleGGXVNDF(const vec3 V,const float ax,const float ay,const float r1,const float r2){vec3 Vh=normalize(vec3(ax*V.x,ay*V.y,V.z));float lensq=Vh.x*Vh.x+Vh.y*Vh.y;vec3 T1=lensq>0. ? vec3(-Vh.y,Vh.x,0.)*inversesqrt(lensq): vec3(1.,0.,0.);vec3 T2=cross(Vh,T1);float r=sqrt(r1);float phi=2.0*PI*r2;float t1=r*cos(phi);float t2=r*sin(phi);float s=0.5*(1.0+Vh.z);t2=(1.0-s)*sqrt(1.0-t1*t1)+s*t2;vec3 Nh=t1*T1+t2*T2+sqrt(max(0.0,1.0-t1*t1-t2*t2))*Vh;return normalize(vec3(ax*Nh.x,ay*Nh.y,max(0.0,Nh.z)));}void Onb(const vec3 N,inout vec3 T,inout vec3 B){vec3 up=abs(N.z)<0.9999999 ? vec3(0,0,1): vec3(1,0,0);T=normalize(cross(up,N));B=cross(N,T);}vec3 ToLocal(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return vec3(dot(V,X),dot(V,Y),dot(V,Z));}vec3 ToWorld(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return V.x*X+V.y*Y+V.z*Z;}vec3 cosineSampleHemisphere(const vec3 n,const vec2 u){float r=sqrt(u.x);float theta=2.0*PI*u.y;vec3 b=normalize(cross(n,vec3(0.0,1.0,1.0)));vec3 t=cross(b,n);return normalize(r*sin(theta)*b+sqrt(1.0-u.x)*n+r*cos(theta)*t);}float equirectDirectionPdf(vec3 direction){vec2 uv=equirectDirectionToUv(direction);float theta=uv.y*PI;float sinTheta=sin(theta);if(sinTheta==0.0){return 0.0;}return 1.0/(2.0*PI*PI*sinTheta);}float sampleEquirectProbability(EquirectHdrInfo info,vec2 r,out vec3 direction){float v=textureLod(info.marginalWeights,vec2(r.x,0.0),0.).x;float u=textureLod(info.conditionalWeights,vec2(r.y,v),0.).x;vec2 uv=vec2(u,v);vec3 derivedDirection=equirectUvToDirection(uv);direction=derivedDirection;vec3 color=texture(info.map,uv).rgb;float totalSum=info.totalSumWhole+info.totalSumDecimal;float lum=luminance(color);float pdf=lum/totalSum;return info.size.x*info.size.y*pdf;}float misHeuristic(float a,float b){float aa=a*a;float bb=b*b;return aa/(aa+bb);}vec3 alignToNormal(const vec3 normal,const vec3 direction){vec3 tangent;vec3 bitangent;Onb(normal,tangent,bitangent);vec3 localDir=ToLocal(tangent,bitangent,normal,direction);vec3 localDirAligned=vec3(localDir.x,localDir.y,abs(localDir.z));vec3 alignedDir=ToWorld(tangent,bitangent,normal,localDirAligned);return alignedDir;}float getFlatness(vec3 g,vec3 rp){vec3 gw=fwidth(g);vec3 pw=fwidth(rp);float wfcurvature=length(gw)/length(pw);wfcurvature=smoothstep(0.0,30.,wfcurvature);return clamp(wfcurvature,0.,1.);}' // eslint-disable-line

// source: https://github.com/gkjohnson/three-gpu-pathtracer/blob/main/src/uniforms/EquirectHdrInfoUniform.js

const workerOnMessage = ({ data: { width, height, isFloatType, flipY, data } }) => {
  // from: https://github.com/mrdoob/three.js/blob/dev/src/extras/DataUtils.js
  // importing modules doesn't seem to work for workers that were generated through createObjectURL() for some reason
  const _tables = /* @__PURE__*/ _generateTables()

  function _generateTables() {
    // float32 to float16 helpers
    const buffer = new ArrayBuffer(4)
    const floatView = new Float32Array(buffer)
    const uint32View = new Uint32Array(buffer)
    const baseTable = new Uint32Array(512)
    const shiftTable = new Uint32Array(512)

    for (let i = 0; i < 256; ++i) {
      const e = i - 127 // very small number (0, -0)

      if (e < -27) {
        baseTable[i] = 0x0000
        baseTable[i | 0x100] = 0x8000
        shiftTable[i] = 24
        shiftTable[i | 0x100] = 24 // small number (denorm)
      } else if (e < -14) {
        baseTable[i] = 0x0400 >> (-e - 14)
        baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000
        shiftTable[i] = -e - 1
        shiftTable[i | 0x100] = -e - 1 // normal number
      } else if (e <= 15) {
        baseTable[i] = (e + 15) << 10
        baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000
        shiftTable[i] = 13
        shiftTable[i | 0x100] = 13 // large number (Infinity, -Infinity)
      } else if (e < 128) {
        baseTable[i] = 0x7c00
        baseTable[i | 0x100] = 0xfc00
        shiftTable[i] = 24
        shiftTable[i | 0x100] = 24 // stay (NaN, Infinity, -Infinity)
      } else {
        baseTable[i] = 0x7c00
        baseTable[i | 0x100] = 0xfc00
        shiftTable[i] = 13
        shiftTable[i | 0x100] = 13
      }
    } // float16 to float32 helpers

    const mantissaTable = new Uint32Array(2048)
    const exponentTable = new Uint32Array(64)
    const offsetTable = new Uint32Array(64)

    for (let i = 1; i < 1024; ++i) {
      let m = i << 13 // zero pad mantissa bits

      let e = 0 // zero exponent
      // normalized

      while ((m & 0x00800000) === 0) {
        m <<= 1
        e -= 0x00800000 // decrement exponent
      }

      m &= ~0x00800000 // clear leading 1 bit

      e += 0x38800000 // adjust bias

      mantissaTable[i] = m | e
    }

    for (let i = 1024; i < 2048; ++i) {
      mantissaTable[i] = 0x38000000 + ((i - 1024) << 13)
    }

    for (let i = 1; i < 31; ++i) {
      exponentTable[i] = i << 23
    }

    exponentTable[31] = 0x47800000
    exponentTable[32] = 0x80000000

    for (let i = 33; i < 63; ++i) {
      exponentTable[i] = 0x80000000 + ((i - 32) << 23)
    }

    exponentTable[63] = 0xc7800000

    for (let i = 1; i < 64; ++i) {
      if (i !== 32) {
        offsetTable[i] = 1024
      }
    }

    return {
      floatView: floatView,
      uint32View: uint32View,
      baseTable: baseTable,
      shiftTable: shiftTable,
      mantissaTable: mantissaTable,
      exponentTable: exponentTable,
      offsetTable: offsetTable
    }
  }

  function fromHalfFloat(val) {
    const m = val >> 10
    _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m]
    return _tables.floatView[0]
  }

  function colorToLuminance(r, g, b) {
    // https://en.wikipedia.org/wiki/Relative_luminance
    return 0.2126 * r + 0.7152 * g + 0.0722 * b
  }

  const binarySearchFindClosestIndexOf = (array, targetValue, offset = 0, count = array.length) => {
    let lower = offset
    let upper = offset + count - 1

    while (lower < upper) {
      const mid = (lower + upper) >> 1 // check if the middle array value is above or below the target and shift
      // which half of the array we're looking at

      if (array[mid] < targetValue) {
        lower = mid + 1
      } else {
        upper = mid
      }
    }

    return lower - offset
  }

  const gatherData = (data, width, height, flipY, marginalDataArray, conditionalDataArray) => {
    // "conditional" = "pixel relative to row pixels sum"
    // "marginal" = "row relative to row sum"
    // remove any y flipping for cdf computation
    if (flipY) {
      for (let y = 0, h = height - 1; y <= h; y++) {
        for (let x = 0, w = width * 4; x < w; x += 4) {
          const newY = h - y
          const ogIndex = y * w + x
          const newIndex = newY * w + x
          data[newIndex] = data[ogIndex]
          data[newIndex + 1] = data[ogIndex + 1]
          data[newIndex + 2] = data[ogIndex + 2]
          data[newIndex + 3] = data[ogIndex + 3]
        }
      }
    } // track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image

    const pdfConditional = new Float32Array(width * height)
    const cdfConditional = new Float32Array(width * height)
    const pdfMarginal = new Float32Array(height)
    const cdfMarginal = new Float32Array(height)
    let totalSumValue = 0.0
    let cumulativeWeightMarginal = 0.0

    for (let y = 0; y < height; y++) {
      let cumulativeRowWeight = 0.0

      for (let x = 0; x < width; x++) {
        const i = y * width + x
        const r = data[4 * i + 0]
        const g = data[4 * i + 1]
        const b = data[4 * i + 2] // the probability of the pixel being selected in this row is the
        // scale of the luminance relative to the rest of the pixels.
        // TODO: this should also account for the solid angle of the pixel when sampling

        const weight = colorToLuminance(r, g, b)
        cumulativeRowWeight += weight
        totalSumValue += weight
        pdfConditional[i] = weight
        cdfConditional[i] = cumulativeRowWeight
      } // can happen if the row is all black

      if (cumulativeRowWeight !== 0) {
        // scale the pdf and cdf to [0.0, 1.0]
        for (let i = y * width, l = y * width + width; i < l; i++) {
          pdfConditional[i] /= cumulativeRowWeight
          cdfConditional[i] /= cumulativeRowWeight
        }
      }

      cumulativeWeightMarginal += cumulativeRowWeight // compute the marginal pdf and cdf along the height of the map.

      pdfMarginal[y] = cumulativeRowWeight
      cdfMarginal[y] = cumulativeWeightMarginal
    } // can happen if the texture is all black

    if (cumulativeWeightMarginal !== 0) {
      // scale the marginal pdf and cdf to [0.0, 1.0]
      for (let i = 0, l = pdfMarginal.length; i < l; i++) {
        pdfMarginal[i] /= cumulativeWeightMarginal
        cdfMarginal[i] /= cumulativeWeightMarginal
      }
    } // compute a sorted index of distributions and the probabilities along them for both
    // the marginal and conditional data. These will be used to sample with a random number
    // to retrieve a uv value to sample in the environment map.
    // These values continually increase so it's okay to interpolate between them.
    // we add a half texel offset so we're sampling the center of the pixel

    for (let i = 0; i < height; i++) {
      const dist = (i + 1) / height
      const row = binarySearchFindClosestIndexOf(cdfMarginal, dist)
      marginalDataArray[i] = (row + 0.5) / height
    }

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const i = y * width + x
        const dist = (x + 1) / width
        const col = binarySearchFindClosestIndexOf(cdfConditional, dist, y * width, width)
        conditionalDataArray[i] = (col + 0.5) / width
      }
    }

    return totalSumValue
  }

  if (!isFloatType) {
    const newData = new Float32Array(data.length) // eslint-disable-next-line guard-for-in

    for (const i in data) {
      newData[i] = fromHalfFloat(data[i])
    }

    data = newData
  }

  const marginalDataArray = new Float32Array(height)
  const conditionalDataArray = new Float32Array(width * height)
  const totalSumValue = gatherData(data, width, height, flipY, marginalDataArray, conditionalDataArray)

  if (isFloatType) {
    postMessage({
      totalSumValue,
      marginalDataArray,
      conditionalDataArray
    })
  } else {
    postMessage({
      data,
      totalSumValue,
      marginalDataArray,
      conditionalDataArray
    })
  }
}

const blob = new Blob(['onmessage = ' + workerOnMessage], {
  type: 'application/javascript'
})
const workerUrl = URL.createObjectURL(blob)
class EquirectHdrInfoUniform {
  constructor() {
    // Default to a white texture and associated weights so we don't
    // just render black initially.
    const whiteTex = new DataTexture(new Float32Array([1, 1, 1, 1]), 1, 1)
    whiteTex.type = FloatType
    whiteTex.format = RGBAFormat
    whiteTex.minFilter = LinearFilter
    whiteTex.magFilter = LinearFilter
    whiteTex.wrapS = RepeatWrapping
    whiteTex.wrapT = RepeatWrapping
    whiteTex.generateMipmaps = false
    whiteTex.needsUpdate = true // Stores a map of [0, 1] value -> cumulative importance row & pdf
    // used to sampling a random value to a relevant row to sample from

    const marginalWeights = new DataTexture(new Float32Array([0, 1]), 1, 2)
    marginalWeights.type = FloatType
    marginalWeights.format = RedFormat
    marginalWeights.minFilter = LinearFilter
    marginalWeights.magFilter = LinearFilter
    marginalWeights.generateMipmaps = false
    marginalWeights.needsUpdate = true // Stores a map of [0, 1] value -> cumulative importance column & pdf
    // used to sampling a random value to a relevant pixel to sample from

    const conditionalWeights = new DataTexture(new Float32Array([0, 0, 1, 1]), 2, 2)
    conditionalWeights.type = FloatType
    conditionalWeights.format = RedFormat
    conditionalWeights.minFilter = LinearFilter
    conditionalWeights.magFilter = LinearFilter
    conditionalWeights.generateMipmaps = false
    conditionalWeights.needsUpdate = true
    this.map = whiteTex
    this.marginalWeights = marginalWeights
    this.conditionalWeights = conditionalWeights // the total sum value is separated into two values to work around low precision
    // storage of floating values in structs

    this.totalSumWhole = 1
    this.totalSumDecimal = 0
    this.size = new Vector2()
  }

  dispose() {
    this.marginalWeights.dispose()
    this.conditionalWeights.dispose()
    this.map.dispose()
  }

  updateFrom(map) {
    map = map.clone()
    const { width, height, data } = map.image
    const { type } = map
    this.size.set(width, height)
    return new Promise((resolve) => {
      var _this$worker

      ;(_this$worker = this.worker) == null ? void 0 : _this$worker.terminate()
      this.worker = new Worker(workerUrl)
      this.worker.postMessage({
        width,
        height,
        isFloatType: type === FloatType,
        flipY: map.flipY,
        data
      })

      this.worker.onmessage = ({ data: { data, totalSumValue, marginalDataArray, conditionalDataArray } }) => {
        this.dispose()
        const { marginalWeights, conditionalWeights } = this
        marginalWeights.image = {
          width: height,
          height: 1,
          data: marginalDataArray
        }
        marginalWeights.needsUpdate = true
        conditionalWeights.image = {
          width,
          height,
          data: conditionalDataArray
        }
        conditionalWeights.needsUpdate = true
        const totalSumWhole = ~~totalSumValue
        const totalSumDecimal = totalSumValue - totalSumWhole
        this.totalSumWhole = totalSumWhole
        this.totalSumDecimal = totalSumDecimal

        if (data) {
          map.source = new Source({ ...map.image })
          map.image = {
            width,
            height,
            data
          }
          map.type = FloatType
        }

        this.map = map
        this.worker = null
        resolve(map)
      }
    })
  }
}

class SSGIMaterial extends ShaderMaterial {
  constructor() {
    super({
      type: 'SSGIMaterial',
      uniforms: {
        accumulatedTexture: new Uniform(null),
        gBuffersTexture: new Uniform(null),
        depthTexture: new Uniform(null),
        velocityTexture: new Uniform(null),
        blueNoiseTexture: new Uniform(null),
        projectionMatrix: new Uniform(new Matrix4()),
        inverseProjectionMatrix: new Uniform(new Matrix4()),
        cameraMatrixWorld: new Uniform(new Matrix4()),
        viewMatrix: new Uniform(new Matrix4()),
        cameraNear: new Uniform(0),
        cameraFar: new Uniform(0),
        rayDistance: new Uniform(0),
        thickness: new Uniform(0),
        frame: new Uniform(0),
        envBlur: new Uniform(0),
        maxRoughness: new Uniform(0),
        maxEnvMapMipLevel: new Uniform(0),
        envMapInfo: {
          value: new EquirectHdrInfoUniform()
        },
        envMapPosition: new Uniform(new Vector3()),
        envMapSize: new Uniform(new Vector3()),
        texSize: new Uniform(new Vector2()),
        blueNoiseRepeat: new Uniform(new Vector2())
      },
      defines: {
        steps: 20,
        refineSteps: 5,
        spp: 1,
        CUBEUV_TEXEL_WIDTH: 0,
        CUBEUV_TEXEL_HEIGHT: 0,
        CUBEUV_MAX_MIP: 0,
        vWorldPosition: 'worldPos'
      },
      fragmentShader: fragmentShader$2.replace('#include <ssgi_utils>', ssgi_utils).replace('#include <gbuffer_packing>', gbuffer_packing).replace('#include <sampleBlueNoise>', sampleBlueNoise),
      vertexShader,
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false,
      glslVersion: GLSL3
    })
  }
}

const backgroundColor$1 = new Color(0)
class SSGIPass extends Pass {
  constructor(ssgiEffect, options) {
    super('SSGIPass')
    this.needsSwap = false
    this.defaultFragmentShader = ''
    this.frame = 0
    this.cachedMaterials = new WeakMap()
    this.visibleMeshes = []
    this.ssgiEffect = ssgiEffect
    this._scene = ssgiEffect._scene
    this._camera = ssgiEffect._camera
    this.fullscreenMaterial = new SSGIMaterial()
    this.defaultFragmentShader = this.fullscreenMaterial.fragmentShader
    const bufferCount = !options.diffuseOnly && !options.specularOnly ? 2 : 1
    this.renderTarget = new WebGLMultipleRenderTargets(1, 1, bufferCount, {
      type: HalfFloatType,
      depthBuffer: false
    }) // set up basic uniforms that we don't have to update

    this.fullscreenMaterial.uniforms.cameraMatrixWorld.value = this._camera.matrixWorld
    this.fullscreenMaterial.uniforms.viewMatrix.value = this._camera.matrixWorldInverse
    this.fullscreenMaterial.uniforms.projectionMatrix.value = this._camera.projectionMatrix
    this.fullscreenMaterial.uniforms.inverseProjectionMatrix.value = this._camera.projectionMatrixInverse
    if (ssgiEffect._camera.isPerspectiveCamera) this.fullscreenMaterial.defines.PERSPECTIVE_CAMERA = ''
    if (options.diffuseOnly) this.fullscreenMaterial.defines.diffuseOnly = ''
    if (options.specularOnly) this.fullscreenMaterial.defines.specularOnly = ''
    this.initMRTRenderTarget()
  }

  initialize(renderer, ...args) {
    super.initialize(renderer, ...args)
    new TextureLoader().load(blueNoiseImage, (blueNoiseTexture) => {
      blueNoiseTexture.minFilter = NearestFilter
      blueNoiseTexture.magFilter = NearestFilter
      blueNoiseTexture.wrapS = RepeatWrapping
      blueNoiseTexture.wrapT = RepeatWrapping
      blueNoiseTexture.colorSpace = NoColorSpace
      blueNoiseTexture.needsUpdate = true
      this.fullscreenMaterial.uniforms.blueNoiseTexture.value = blueNoiseTexture
    })
  }

  get texture() {
    return this.renderTarget.texture[0]
  }

  get specularTexture() {
    const index = 'specularOnly' in this.fullscreenMaterial.defines ? 0 : 1
    return this.renderTarget.texture[index]
  }

  initMRTRenderTarget() {
    this.gBuffersRenderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      type: FloatType
    })
    this.depthTexture = this.ssgiEffect.composer.depthTexture
    this.fullscreenMaterial.uniforms.depthTexture.value = this.depthTexture
    this.gBuffersRenderTarget.depthTexture = this.depthTexture
    this.fullscreenMaterial.uniforms.gBuffersTexture.value = this.gBuffersRenderTarget.texture
  }

  setSize(width, height) {
    this.renderTarget.setSize(width * this.ssgiEffect.resolutionScale, height * this.ssgiEffect.resolutionScale)
    this.gBuffersRenderTarget.setSize(width, height)
    this.fullscreenMaterial.uniforms.texSize.value.set(this.renderTarget.width, this.renderTarget.height)
  }

  dispose() {
    super.dispose()
    this.renderTarget.dispose()
    this.gBuffersRenderTarget.dispose()
    this.fullscreenMaterial.dispose()
    this.normalTexture = null
    this.depthTexture = null
    this.diffuseTexture = null
    this.emissiveTexture = null
  }

  setMRTMaterialInScene() {
    this.visibleMeshes = getVisibleChildren(this._scene)

    for (const c of this.visibleMeshes) {
      var _originalMaterial$rou, _c$material$metalness, _c$material$emissiveI

      const originalMaterial = c.material
      let [cachedOriginalMaterial, mrtMaterial] = this.cachedMaterials.get(c) || []

      if (originalMaterial !== cachedOriginalMaterial) {
        var _c$skeleton

        if (mrtMaterial) mrtMaterial.dispose()
        mrtMaterial = new MRTMaterial()
        copyNecessaryProps(originalMaterial, mrtMaterial)
        mrtMaterial.uniforms.normalScale.value = originalMaterial.normalScale

        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) {
          mrtMaterial.defines.USE_SKINNING = ''
          mrtMaterial.defines.BONE_TEXTURE = ''
          mrtMaterial.uniforms.boneTexture.value = c.skeleton.boneTexture
          mrtMaterial.needsUpdate = true
        }

        const textureKey = Object.keys(originalMaterial).find((key) => {
          const value = originalMaterial[key]
          return value instanceof Texture && value.matrix
        })
        if (textureKey) mrtMaterial.uniforms.uvTransform.value = originalMaterial[textureKey].matrix
        this.cachedMaterials.set(c, [originalMaterial, mrtMaterial])
      }

      if (originalMaterial.emissive) mrtMaterial.uniforms.emissive.value = originalMaterial.emissive
      if (originalMaterial.color) mrtMaterial.uniforms.color.value = originalMaterial.color // update the child's MRT material

      keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'normalMap', 'USE_NORMALMAP_TANGENTSPACE', true) // todo: object space normals support

      keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'roughnessMap', 'USE_ROUGHNESSMAP', true)
      keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'metalnessMap', 'USE_	METALNESSMAP', true)
      keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'map', 'USE_MAP', true)
      keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'emissiveMap', 'USE_EMISSIVEMAP', true)
      keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'alphaMap', 'USE_ALPHAMAP', true)
      keepMaterialMapUpdated(mrtMaterial, originalMaterial, 'lightMap', 'USE_LIGHTMAP', true)
      const noiseTexture = this.fullscreenMaterial.uniforms.blueNoiseTexture.value

      if (noiseTexture) {
        const { width, height } = noiseTexture.source.data
        mrtMaterial.uniforms.blueNoiseTexture.value = noiseTexture
        mrtMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / width, this.renderTarget.height / height)
      }

      mrtMaterial.uniforms.texSize.value.set(this.renderTarget.width, this.renderTarget.height)
      mrtMaterial.uniforms.frame.value = this.frame
      c.visible = isChildMaterialRenderable(c, originalMaterial)
      const origRoughness = (_originalMaterial$rou = originalMaterial.roughness) !== null && _originalMaterial$rou !== void 0 ? _originalMaterial$rou : 1
      mrtMaterial.uniforms.roughness.value = this.ssgiEffect.selection.size === 0 || this.ssgiEffect.selection.has(c) ? origRoughness : 10e10
      mrtMaterial.uniforms.metalness.value = (_c$material$metalness = c.material.metalness) !== null && _c$material$metalness !== void 0 ? _c$material$metalness : 0
      mrtMaterial.uniforms.emissiveIntensity.value = (_c$material$emissiveI = c.material.emissiveIntensity) !== null && _c$material$emissiveI !== void 0 ? _c$material$emissiveI : 0
      c.material = mrtMaterial
    }
  }

  unsetMRTMaterialInScene() {
    for (const c of this.visibleMeshes) {
      c.visible = true // set material back to the original one

      const [originalMaterial] = this.cachedMaterials.get(c)
      c.material = originalMaterial
    }
  }

  render(renderer) {
    this.frame = (this.frame + this.ssgiEffect.spp) % 65536
    const { background } = this._scene
    this._scene.background = backgroundColor$1
    this.setMRTMaterialInScene()
    renderer.setRenderTarget(this.gBuffersRenderTarget)
    renderer.render(this._scene, this._camera)
    this.unsetMRTMaterialInScene() // update uniforms

    this.fullscreenMaterial.uniforms.frame.value = this.frame
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far
    this.fullscreenMaterial.uniforms.viewMatrix.value.copy(this._camera.matrixWorldInverse)
    this.fullscreenMaterial.uniforms.accumulatedTexture.value = this.ssgiEffect.ssgiComposePass.renderTarget.texture
    const noiseTexture = this.fullscreenMaterial.uniforms.blueNoiseTexture.value

    if (noiseTexture) {
      const { width, height } = noiseTexture.source.data
      this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / width, this.renderTarget.height / height)
    }

    renderer.setRenderTarget(this.renderTarget)
    renderer.render(this.scene, this.camera)
    this._scene.background = background
  }
}

/**
 * Options of the SSGI effect
 * @typedef {Object} SSGIOptions
 * @property {Number} [distance] maximum distance a SSGI ray can travel to find what it reflects
 * @property {Number} [thickness] maximum depth difference between a ray and the particular depth at its screen position before refining with binary search; higher values will result in better performance
 * @property {Number} [maxRoughness] maximum roughness a texel can have to have SSGI calculated for it
 * @property {Number} [blend] a value between 0 and 1 to set how much the last frame's SSGI should be blended in; higher values will result in less noisy SSGI when moving the camera but a more smeary look
 * @property {Number} [denoiseIterations] how many times the denoise filter runs, more iterations will denoise the frame better but need more performance
 * @property {Number} [denoiseKernel] the kernel (~ number of neighboring pixels) to take into account when denoising a pixel
 * @property {Number} [denoiseDiffuse] diffuse luminance factor of the denoiser, higher values will denoise areas with varying luminance more aggressively
 * @property {Number} [denoiseSpecular] specular luminance factor of the denoiser, higher values will denoise areas with varying luminance more aggressively
 * @property {Number} [depthPhi] depth factor of the denoiser, higher values will use neighboring areas with different depth values more resulting in less noise but loss of details
 * @property {Number} [depthPhi] normals factor of the denoiser, higher values will use neighboring areas with different normals more resulting in less noise but loss of details and sharpness
 * @property {Number} [roughnessPhi] roughness factor of the denoiser setting how much the denoiser should only apply the blur to rougher surfaces, a value of 0 means the denoiser will blur mirror-like surfaces the same as rough surfaces
 * @property {Number} [envBlur] higher values will result in lower mipmaps being sampled which will cause less noise but also less detail regarding environment lighting
 * @property {Number} [importanceSampling] whether to use importance sampling for the environment map
 * @property {Number} [steps] number of steps a SSGI ray can maximally do to find an object it intersected (and thus reflects)
 * @property {Number} [refineSteps] once we had our ray intersect something, we need to find the exact point in space it intersected and thus it reflects; this can be done through binary search with the given number of maximum steps
 * @property {Number} [spp] number of samples per pixel
 * @property {boolean} [missedRays] if there should still be SSGI for rays for which a reflecting point couldn't be found; enabling this will result in stretched looking SSGI which can look good or bad depending on the angle
 * @property {Number} [resolutionScale] resolution of the SSGI effect, a resolution of 0.5 means the effect will be rendered at half resolution
 */

/**
 * The options of the SSGI effect
 * @type {SSGIOptions}
 */
const defaultSSGIOptions = {
  distance: 10,
  thickness: 10,
  maxRoughness: 1,
  blend: 0.9,
  denoiseIterations: 1,
  denoiseKernel: 2,
  denoiseDiffuse: 10,
  denoiseSpecular: 10,
  rings: 5.625,
  samples: 8,
  radius: 3,
  phi: 0.5,
  lumaPhi: 5,
  depthPhi: 2,
  normalPhi: 50,
  roughnessPhi: 50,
  diffusePhi: 0,
  envBlur: 0.5,
  importanceSampling: true,
  steps: 20,
  refineSteps: 5,
  spp: 1,
  resolutionScale: 1,
  missedRays: false
}

var ssgi_poisson_compose_functions =
  '#define GLSLIFY 1\nvec3 getViewPosition(const float depth){float clipW=projectionMatrix[2][3]*depth+projectionMatrix[3][3];vec4 clipPosition=vec4((vec3(vUv,depth)-0.5)*2.0,1.0);clipPosition*=clipW;return(projectionMatrixInverse*clipPosition).xyz;}vec3 F_Schlick(const vec3 f0,const float theta){return f0+(1.-f0)*pow(1.0-theta,5.);}vec3 SampleGGXVNDF(const vec3 V,const float ax,const float ay,const float r1,const float r2){vec3 Vh=normalize(vec3(ax*V.x,ay*V.y,V.z));float lensq=Vh.x*Vh.x+Vh.y*Vh.y;vec3 T1=lensq>0. ? vec3(-Vh.y,Vh.x,0.)*inversesqrt(lensq): vec3(1.,0.,0.);vec3 T2=cross(Vh,T1);float r=sqrt(r1);float phi=2.0*PI*r2;float t1=r*cos(phi);float t2=r*sin(phi);float s=0.5*(1.0+Vh.z);t2=(1.0-s)*sqrt(1.0-t1*t1)+s*t2;vec3 Nh=t1*T1+t2*T2+sqrt(max(0.0,1.0-t1*t1-t2*t2))*Vh;return normalize(vec3(ax*Nh.x,ay*Nh.y,max(0.0,Nh.z)));}void Onb(const vec3 N,inout vec3 T,inout vec3 B){vec3 up=abs(N.z)<0.9999999 ? vec3(0,0,1): vec3(1,0,0);T=normalize(cross(up,N));B=cross(N,T);}vec3 ToLocal(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return vec3(dot(V,X),dot(V,Y),dot(V,Z));}vec3 ToWorld(const vec3 X,const vec3 Y,const vec3 Z,const vec3 V){return V.x*X+V.y*Y+V.z*Z;}vec3 constructGlobalIllumination(vec3 diffuseGi,vec3 specularGi,vec3 viewDir,vec3 viewNormal,vec3 diffuse,vec3 emissive,float roughness,float metalness){roughness*=roughness;vec3 normal=(vec4(viewNormal,0.)*viewMatrix).xyz;vec3 T,B;vec3 v=viewDir;vec3 V=(vec4(v,0.)*viewMatrix).xyz;vec3 N=normal;Onb(N,T,B);V=ToLocal(T,B,N,V);vec3 H=SampleGGXVNDF(V,roughness,roughness,0.25,0.25);if(H.z<0.0)H=-H;vec3 l=normalize(reflect(-V,H));l=ToWorld(T,B,N,l);l=(vec4(l,1.)*cameraMatrixWorld).xyz;l=normalize(l);if(dot(viewNormal,l)<0.)l=-l;vec3 h=normalize(v+l);float VoH=max(EPSILON,dot(v,h));vec3 diffuseColor=diffuseGi;vec3 specularColor=specularGi;vec3 f0=mix(vec3(0.04),diffuse,metalness);vec3 F=F_Schlick(f0,VoH);vec3 diffuseLightingColor=diffuseColor;vec3 diffuseComponent=diffuse*(1.-metalness)*(1.-F)*diffuseLightingColor;vec3 specularLightingColor=specularColor;vec3 specularComponent=specularLightingColor*F;vec3 globalIllumination=diffuseComponent+specularComponent+emissive;return globalIllumination;}' // eslint-disable-line

/* eslint-disable camelcase */
class SSGIComposePass extends Pass {
  constructor(camera) {
    super('SSGIComposePass')
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      depthBuffer: false,
      type: HalfFloatType
    })
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader:
        /* glsl */
        `
            varying vec2 vUv;
            uniform sampler2D depthTexture;
            uniform sampler2D diffuseGiTexture;
            uniform sampler2D specularGiTexture;
            uniform sampler2D directLightTexture;
            uniform mat4 cameraMatrixWorld;
            uniform mat4 projectionMatrix;
            uniform mat4 projectionMatrixInverse;

            #include <common>
            

            ${gbuffer_packing}
            ${ssgi_poisson_compose_functions}

            void main() {
                vec3 diffuse, normal, emissive;
                float roughness, metalness;

                getGData(gBuffersTexture, vUv, diffuse, normal, roughness, metalness, emissive);

                float depth = textureLod(depthTexture, vUv, 0.).r;

                vec3 viewNormal = (vec4(normal, 0.) * cameraMatrixWorld).xyz;

                // view-space position of the current texel
                vec3 viewPos = getViewPosition(depth);
                vec3 viewDir = normalize(viewPos);

                vec3 diffuseGi = textureLod(diffuseGiTexture, vUv, 0.).rgb;
                vec3 specularGi = textureLod(specularGiTexture, vUv, 0.).rgb;

                vec3 gi = constructGlobalIllumination(diffuseGi, specularGi, viewDir, viewNormal, diffuse, emissive, roughness, metalness);

				// gi = diffuseGi;

				#ifdef useDirectLight
				gi += textureLod(directLightTexture, vUv, 0.).rgb;
				#endif

				gl_FragColor = vec4(gi, 1.);
            }
            `,
      vertexShader: vertexShader,
      uniforms: {
        viewMatrix: {
          value: camera.matrixWorldInverse
        },
        cameraMatrixWorld: {
          value: camera.matrixWorld
        },
        projectionMatrix: {
          value: camera.projectionMatrix
        },
        projectionMatrixInverse: {
          value: camera.projectionMatrixInverse
        },
        gBuffersTexture: {
          value: null
        },
        depthTexture: {
          value: null
        },
        diffuseGiTexture: {
          value: null
        },
        specularGiTexture: {
          value: null
        },
        directLightTexture: {
          value: null
        }
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    })
  }

  dispose() {
    this.renderTarget.dispose()
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height)
  }

  render(renderer) {
    renderer.setRenderTarget(this.renderTarget)
    renderer.render(this.scene, this.camera)
  }
}

var ssgi_compose = '#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D sceneTexture;uniform sampler2D depthTexture;uniform int toneMapping;\n#include <tonemapping_pars_fragment>\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 depthTexel=textureLod(depthTexture,uv,0.);vec3 ssgiClr;if(depthTexel.r==1.0){ssgiClr=textureLod(sceneTexture,uv,0.).rgb;}else{ssgiClr=textureLod(inputTexture,uv,0.).rgb;switch(toneMapping){case 1:ssgiClr=LinearToneMapping(ssgiClr);break;case 2:ssgiClr=ReinhardToneMapping(ssgiClr);break;case 3:ssgiClr=OptimizedCineonToneMapping(ssgiClr);break;case 4:ssgiClr=ACESFilmicToneMapping(ssgiClr);break;case 5:ssgiClr=CustomToneMapping(ssgiClr);break;}ssgiClr*=toneMappingExposure;}outputColor=vec4(ssgiClr,1.0);}' // eslint-disable-line

const { render } = RenderPass.prototype
const globalIblIrradianceDisabledUniform = createGlobalDisableIblIradianceUniform()
const globalIblRadianceDisabledUniform = createGlobalDisableIblRadianceUniform()
class SSGIEffect extends Effect {
  constructor(composer, scene, camera, velocityDepthNormalPass, options) {
    options = { ...defaultSSGIOptions, ...options }
    super('SSGIEffect', ssgi_compose, {
      type: 'FinalSSGIMaterial',
      uniforms: new Map([
        ['inputTexture', new Uniform(null)],
        ['sceneTexture', new Uniform(null)],
        ['depthTexture', new Uniform(null)],
        ['toneMapping', new Uniform(NoToneMapping)]
      ])
    })
    this.selection = new Selection()
    this.isUsingRenderPass = true

    if (!(camera instanceof PerspectiveCamera)) {
      throw new Error(this.constructor.name + " doesn't support cameras of type '" + camera.constructor.name + "' yet. Only cameras of type 'PerspectiveCamera' are supported.")
    }

    this._scene = scene
    this._camera = camera
    this.composer = composer
    if (!composer.depthTexture) composer.createDepthTexture()
    window.depthTexture = composer.depthTexture
    let definesName

    if (options.diffuseOnly) {
      definesName = 'ssdgi'
      options.reprojectSpecular = false
      options.roughnessDependent = false
      options.neighborhoodClamp = false
    } else if (options.specularOnly) {
      definesName = 'ssr'
      options.reprojectSpecular = true
      options.roughnessDependent = true
      options.neighborhoodClamp = true
    } else {
      definesName = 'ssgi'
      options.reprojectSpecular = [false, true]
      options.neighborhoodClamp = [true, true]
      options.roughnessDependent = [false, true]
    }

    options.neighborhoodClampRadius = 2
    options.neighborhoodClampIntensity = 0.75
    const textureCount = options.diffuseOnly || options.specularOnly ? 1 : 2 // options = {
    // 	...options,
    // 	...{
    // 		denoiseCustomComposeShader: denoise_compose,
    // 		denoiseCustomComposeShaderFunctions: denoise_compose_functions
    // 	}
    // }

    this.svgf = new SVGF(scene, camera, velocityDepthNormalPass, textureCount, options) // if (definesName === "ssgi") {
    // 	this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader =
    // 		this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader.replace(
    // 			"accumulatedTexel[ 1 ].rgb = clampedColor;",
    // 			`
    // 				float roughness = inputTexel[ 0 ].a;
    // 				accumulatedTexel[ 1 ].rgb = mix(accumulatedTexel[ 1 ].rgb, clampedColor, 1. - sqrt(roughness));
    // 				`
    // 		)
    // } else if (definesName === "ssr") {
    // 	this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader =
    // 		this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.fragmentShader.replace(
    // 			"accumulatedTexel[ 0 ].rgb = clampedColor;",
    // 			`
    // 			accumulatedTexel[ 0 ].rgb = mix(accumulatedTexel[ 0 ].rgb, clampedColor, 0.5);
    // 			`
    // 		)
    // }

    this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.needsUpdate = true // ssgi pass

    this.ssgiPass = new SSGIPass(this, options)

    if (options.diffuseOnly) {
      this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = this.ssgiPass.texture
    } else if (options.specularOnly) {
      this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = this.ssgiPass.specularTexture
    } else {
      this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture0.value = this.ssgiPass.texture
      this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms.inputTexture1.value = this.ssgiPass.specularTexture
    }

    this.svgf.setJitteredGBuffers(this.ssgiPass.depthTexture, this.ssgiPass.normalTexture, {
      useRoughnessInAlphaChannel: true
    })
    this.svgf.denoisePass.setGBuffersTexture(this.ssgiPass.gBuffersRenderTarget.texture) // patch the denoise pass

    this.svgf.denoisePass.fullscreenMaterial.uniforms = {
      ...this.svgf.denoisePass.fullscreenMaterial.uniforms,
      ...{
        diffuseTexture: new Uniform(null)
      }
    }
    this.svgf.denoisePass.fullscreenMaterial.defines[definesName] = ''
    this.svgf.denoisePass.fullscreenMaterial.uniforms.diffuseTexture.value = this.ssgiPass.diffuseTexture
    this.lastSize = {
      width: options.width,
      height: options.height,
      resolutionScale: options.resolutionScale
    }
    this.sceneRenderTarget = new WebGLRenderTarget(1, 1, {
      colorSpace: SRGBColorSpace
    })
    this.renderPass = new RenderPass(this._scene, this._camera)
    this.renderPass.renderToScreen = false
    this.setSize(options.width, options.height)
    const th = this
    const ssgiRenderPass = this.renderPass // eslint-disable-next-line space-before-function-paren

    RenderPass.prototype.render = function (...args) {
      if (this !== ssgiRenderPass) {
        const wasUsingRenderPass = th.isUsingRenderPass
        th.isUsingRenderPass = true
        if (wasUsingRenderPass != th.isUsingRenderPass) th.updateUsingRenderPass()
      }

      render.call(this, ...args)
    }

    this.ssgiComposePass = new SSGIComposePass(camera)
    this.makeOptionsReactive(options)
  }

  updateUsingRenderPass() {
    if (this.isUsingRenderPass) {
      this.ssgiComposePass.fullscreenMaterial.defines.useDirectLight = ''
    } else {
      delete this.ssgiComposePass.fullscreenMaterial.defines.useDirectLight
    }

    this.ssgiComposePass.fullscreenMaterial.needsUpdate = true
  }

  makeOptionsReactive(options) {
    let needsUpdate = false
    const ssgiPassFullscreenMaterialUniforms = this.ssgiPass.fullscreenMaterial.uniforms
    const ssgiPassFullscreenMaterialUniformsKeys = Object.keys(ssgiPassFullscreenMaterialUniforms)
    const temporalReprojectPass = this.svgf.svgfTemporalReprojectPass

    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key]
        },

        set(value) {
          if (options[key] === value && needsUpdate) return
          options[key] = value

          switch (key) {
            // denoiser
            case 'denoiseIterations':
              this.svgf.denoisePass.iterations = value
              break

            case 'radius':
            case 'phi':
            case 'lumaPhi':
            case 'depthPhi':
            case 'normalPhi':
            case 'roughnessPhi':
            case 'diffusePhi':
              if (this.svgf.denoisePass.fullscreenMaterial.uniforms[key]) {
                this.svgf.denoisePass.fullscreenMaterial.uniforms[key].value = value
                temporalReprojectPass.reset()
              }

              break

            case 'iterations':
            case 'radius':
            case 'rings':
            case 'samples':
              this.svgf.denoisePass[key] = value
              break
            // SSGI

            case 'resolutionScale':
              this.setSize(this.lastSize.width, this.lastSize.height)
              temporalReprojectPass.reset()
              break
            // defines

            case 'spp':
              this.ssgiPass.fullscreenMaterial.fragmentShader = this.ssgiPass.defaultFragmentShader.replaceAll('spp', value)

              if (value !== 1) {
                this.ssgiPass.fullscreenMaterial.fragmentShader = unrollLoops(this.ssgiPass.fullscreenMaterial.fragmentShader.replace('#pragma unroll_loop_start', '').replace('#pragma unroll_loop_end', ''))
              }

              this.ssgiPass.fullscreenMaterial.needsUpdate = needsUpdate
              temporalReprojectPass.reset()
              break

            case 'steps':
            case 'refineSteps':
              this.ssgiPass.fullscreenMaterial.defines[key] = parseInt(value)
              this.ssgiPass.fullscreenMaterial.needsUpdate = needsUpdate
              temporalReprojectPass.reset()
              break

            case 'importanceSampling':
            case 'missedRays':
              if (value) {
                this.ssgiPass.fullscreenMaterial.defines[key] = ''
              } else {
                delete this.ssgiPass.fullscreenMaterial.defines[key]
              }

              this.ssgiPass.fullscreenMaterial.needsUpdate = needsUpdate
              temporalReprojectPass.reset()
              break

            case 'blend':
              this.svgf.svgfTemporalReprojectPass.fullscreenMaterial.uniforms[key].value = value
              temporalReprojectPass.reset()
              break

            case 'distance':
              ssgiPassFullscreenMaterialUniforms.rayDistance.value = value
              temporalReprojectPass.reset()
              break
            // must be a uniform

            default:
              if (ssgiPassFullscreenMaterialUniformsKeys.includes(key)) {
                ssgiPassFullscreenMaterialUniforms[key].value = value
                temporalReprojectPass.reset()
              }
          }
        }
      }) // apply all uniforms and defines

      this[key] = options[key]
    }

    needsUpdate = true
  }

  initialize(renderer, ...args) {
    super.initialize(renderer, ...args)
    this.ssgiPass.initialize(renderer, ...args)
  }

  setSize(width, height, force = false) {
    var _this$cubeToEquirectE

    if (width === undefined && height === undefined) return

    if (!force && width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale) {
      return
    }

    this.ssgiPass.setSize(width, height)
    this.svgf.setSize(width, height)
    this.ssgiComposePass.setSize(width, height)
    this.sceneRenderTarget.setSize(width, height)
    ;(_this$cubeToEquirectE = this.cubeToEquirectEnvPass) == null ? void 0 : _this$cubeToEquirectE.setSize(width, height)
    this.lastSize = {
      width,
      height,
      resolutionScale: this.resolutionScale
    }
  }

  dispose() {
    var _this$cubeToEquirectE2

    super.dispose()
    this.ssgiPass.dispose()
    this.svgf.dispose()
    ;(_this$cubeToEquirectE2 = this.cubeToEquirectEnvPass) == null ? void 0 : _this$cubeToEquirectE2.dispose()
    RenderPass.prototype.render = render
  }

  keepEnvMapUpdated(renderer) {
    const ssgiMaterial = this.ssgiPass.fullscreenMaterial
    let environment = this._scene.environment

    if (environment) {
      if (ssgiMaterial.uniforms.envMapInfo.value.mapUuid !== environment.uuid) {
        // if the environment is a cube texture, convert it to an equirectangular texture so we can sample it in the SSGI pass and use MIS
        if (environment.isCubeTexture) {
          if (!this.cubeToEquirectEnvPass) this.cubeToEquirectEnvPass = new CubeToEquirectEnvPass()
          environment = this.cubeToEquirectEnvPass.generateEquirectEnvMap(renderer, environment)
          environment.uuid = this._scene.environment.uuid
        }

        if (!environment.generateMipmaps) {
          environment.generateMipmaps = true
          environment.minFilter = LinearMipMapLinearFilter
          environment.magFilter = LinearFilter
          environment.needsUpdate = true
        }

        ssgiMaterial.uniforms.envMapInfo.value.mapUuid = environment.uuid
        const maxEnvMapMipLevel = getMaxMipLevel(environment)
        ssgiMaterial.uniforms.maxEnvMapMipLevel.value = maxEnvMapMipLevel
        ssgiMaterial.uniforms.envMapInfo.value.map = environment
        ssgiMaterial.defines.USE_ENVMAP = ''
        delete ssgiMaterial.defines.importanceSampling

        if (this.importanceSampling) {
          ssgiMaterial.uniforms.envMapInfo.value.updateFrom(environment, renderer).then(() => {
            ssgiMaterial.defines.importanceSampling = ''
            ssgiMaterial.needsUpdate = true
          })
        } else {
          ssgiMaterial.uniforms.envMapInfo.value.map = environment
        }

        this.svgf.svgfTemporalReprojectPass.reset()
        ssgiMaterial.needsUpdate = true
      }
    } else if ('USE_ENVMAP' in ssgiMaterial.defines) {
      delete ssgiMaterial.defines.USE_ENVMAP
      delete ssgiMaterial.defines.importanceSampling
      ssgiMaterial.needsUpdate = true
    }
  }

  update(renderer, inputBuffer) {
    this.keepEnvMapUpdated(renderer)
    const sceneBuffer = this.isUsingRenderPass ? inputBuffer : this.sceneRenderTarget
    const hideMeshes = []

    if (!this.isUsingRenderPass) {
      const children = []

      for (const c of getVisibleChildren(this._scene)) {
        if (c.isScene) return
        c.visible = !isChildMaterialRenderable(c)
        c.visible ? hideMeshes.push(c) : children.push(c)
      }

      this.renderPass.render(renderer, this.sceneRenderTarget)

      for (const c of children) c.visible = true

      for (const c of hideMeshes) c.visible = false
    }

    this.ssgiComposePass.fullscreenMaterial.uniforms.directLightTexture.value = sceneBuffer.texture
    const ssgiComposePassUniforms = this.ssgiComposePass.fullscreenMaterial.uniforms
    ssgiComposePassUniforms.gBuffersTexture.value = this.ssgiPass.gBuffersRenderTarget.texture
    ssgiComposePassUniforms.depthTexture.value = this.ssgiPass.depthTexture
    ssgiComposePassUniforms.diffuseGiTexture.value = this.svgf.denoisePass.texture[0]
    ssgiComposePassUniforms.specularGiTexture.value = this.svgf.denoisePass.texture[1]
    this.ssgiPass.render(renderer)
    this.svgf.render(renderer)
    this.ssgiComposePass.render(renderer)
    this.uniforms.get('inputTexture').value = this.ssgiComposePass.renderTarget.texture
    this.uniforms.get('sceneTexture').value = sceneBuffer.texture
    this.uniforms.get('depthTexture').value = this.ssgiPass.depthTexture
    this.uniforms.get('toneMapping').value = renderer.toneMapping

    for (const c of hideMeshes) c.visible = true

    const fullGi = !this.diffuseOnly && !this.specularOnly
    globalIblIrradianceDisabledUniform.value = fullGi || this.diffuseOnly === true
    globalIblRadianceDisabledUniform.value = fullGi || this.specularOnly == true
    cancelAnimationFrame(this.rAF2)
    cancelAnimationFrame(this.rAF)
    cancelAnimationFrame(this.usingRenderPassRAF)
    this.rAF = requestAnimationFrame(() => {
      this.rAF2 = requestAnimationFrame(() => {
        globalIblIrradianceDisabledUniform.value = false
        globalIblRadianceDisabledUniform.value = false
      })
    })
    this.usingRenderPassRAF = requestAnimationFrame(() => {
      const wasUsingRenderPass = this.isUsingRenderPass
      this.isUsingRenderPass = false
      if (wasUsingRenderPass != this.isUsingRenderPass) this.updateUsingRenderPass()
    })
  }
}
SSGIEffect.DefaultOptions = defaultSSGIOptions

class SSREffect extends SSGIEffect {
  constructor(composer, scene, camera, velocityDepthNormalPass, options) {
    options = { ...defaultSSGIOptions, ...options }
    options.specularOnly = true
    super(composer, scene, camera, velocityDepthNormalPass, options)
  }
}

class SSDGIEffect extends SSGIEffect {
  constructor(composer, scene, camera, velocityDepthNormalPass, options) {
    options = { ...defaultSSGIOptions, ...options }
    options.diffuseOnly = true
    super(composer, scene, camera, velocityDepthNormalPass, options)
  }
}

var motion_blur =
  '#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D velocityTexture;uniform sampler2D blueNoiseTexture;uniform ivec2 blueNoiseSize;uniform vec2 texSize;uniform float intensity;uniform float jitter;uniform float deltaTime;uniform int frame;uvec4 s0,s1;ivec2 pixel;void rng_initialize(vec2 p,int frame){pixel=ivec2(p);s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y));s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585);}void pcg4d(inout uvec4 v){v=v*1664525u+1013904223u;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z;v=v ^(v>>16u);v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z;}ivec2 shift2(){pcg4d(s1);return(pixel+ivec2(s1.xy % 0x0fffffffu))% blueNoiseSize;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 velocity=textureLod(velocityTexture,vUv,0.0);if(dot(velocity.xyz,velocity.xyz)==0.0){outputColor=inputColor;return;}velocity.xy*=intensity;rng_initialize(vUv*texSize,frame);vec2 blueNoise=texelFetch(blueNoiseTexture,shift2(),0).rg-0.5;vec2 jitterOffset=jitter*velocity.xy*blueNoise;float frameSpeed=(1./100.)/deltaTime;vec2 startUv=vUv+(jitterOffset-velocity.xy*0.5)*frameSpeed;vec2 endUv=vUv+(jitterOffset+velocity.xy*0.5)*frameSpeed;startUv=max(vec2(0.),startUv);endUv=min(vec2(1.),endUv);vec3 motionBlurredColor;for(float i=0.0;i<=samplesFloat;i++){vec2 reprojectedUv=mix(startUv,endUv,i/samplesFloat);vec3 neighborColor=textureLod(inputTexture,reprojectedUv,0.0).rgb;motionBlurredColor+=neighborColor;}motionBlurredColor/=samplesFloat;outputColor=vec4(motionBlurredColor,inputColor.a);}' // eslint-disable-line

/* eslint-disable camelcase */
// http://john-chapman-graphics.blogspot.com/2013/01/per-object-motion-blur.html
// reference code: https://github.com/gkjohnson/threejs-sandbox/blob/master/motionBlurPass/src/CompositeShader.js

const defaultOptions = {
  intensity: 1,
  jitter: 1,
  samples: 16
}
class MotionBlurEffect extends Effect {
  constructor(velocityPass, options = defaultOptions) {
    options = { ...defaultOptions, ...options }
    super('MotionBlurEffect', motion_blur, {
      type: 'MotionBlurMaterial',
      uniforms: new Map([
        ['inputTexture', new Uniform(null)],
        ['velocityTexture', new Uniform(velocityPass.texture)],
        ['blueNoiseTexture', new Uniform(null)],
        ['blueNoiseSize', new Uniform(new Vector2())],
        ['texSize', new Uniform(new Vector2())],
        ['intensity', new Uniform(1)],
        ['jitter', new Uniform(1)],
        ['frame', new Uniform(0)],
        ['deltaTime', new Uniform(0)]
      ]),
      defines: new Map([
        ['samples', options.samples.toFixed(0)],
        ['samplesFloat', options.samples.toFixed(0) + '.0']
      ])
    })
    this.pointsIndex = 0
    this.makeOptionsReactive(options)
  }

  makeOptionsReactive(options) {
    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key]
        },

        set(value) {
          options[key] = value

          switch (key) {
            case 'intensity':
            case 'jitter':
              this.uniforms.get(key).value = value
              break
          }
        }
      })
      this[key] = options[key]
    }
  }

  initialize(renderer, ...args) {
    super.initialize(renderer, ...args)
    new TextureLoader().load(blueNoiseImage, (blueNoiseTexture) => {
      blueNoiseTexture.minFilter = NearestFilter
      blueNoiseTexture.magFilter = NearestFilter
      blueNoiseTexture.wrapS = RepeatWrapping
      blueNoiseTexture.wrapT = RepeatWrapping
      blueNoiseTexture.colorSpace = NoColorSpace
      this.uniforms.get('blueNoiseTexture').value = blueNoiseTexture
    })
  }

  update(renderer, inputBuffer, deltaTime) {
    this.uniforms.get('inputTexture').value = inputBuffer.texture
    this.uniforms.get('deltaTime').value = Math.max(1 / 1000, deltaTime)
    const frame = renderer.info.render.frame % 65536
    this.uniforms.get('frame').value = frame
    this.uniforms.get('texSize').value.set(window.innerWidth, window.innerHeight)
    const noiseTexture = this.uniforms.get('blueNoiseTexture').value

    if (noiseTexture) {
      const { width, height } = noiseTexture.source.data
      this.uniforms.get('blueNoiseSize').value.set(width, height)
    }
  }
}

// this shader is from: https://github.com/gkjohnson/threejs-sandbox
// a second set of bone information from the previous frame

const prev_skinning_pars_vertex =
  /* glsl */
  `
		#ifdef USE_SKINNING
		#ifdef BONE_TEXTURE
			uniform sampler2D prevBoneTexture;
			mat4 getPrevBoneMatrix( const in float i ) {
				float j = i * 4.0;
				float x = mod( j, float( boneTextureSize ) );
				float y = floor( j / float( boneTextureSize ) );
				float dx = 1.0 / float( boneTextureSize );
				float dy = 1.0 / float( boneTextureSize );
				y = dy * ( y + 0.5 );
				vec4 v1 = textureLod( prevBoneTexture, vec2( dx * ( x + 0.5 ), y ), 0. );
				vec4 v2 = textureLod( prevBoneTexture, vec2( dx * ( x + 1.5 ), y ), 0. );
				vec4 v3 = textureLod( prevBoneTexture, vec2( dx * ( x + 2.5 ), y ), 0. );
				vec4 v4 = textureLod( prevBoneTexture, vec2( dx * ( x + 3.5 ), y ), 0. );
				mat4 bone = mat4( v1, v2, v3, v4 );
				return bone;
			}
		#else
			uniform mat4 prevBoneMatrices[ MAX_BONES ];
			mat4 getPrevBoneMatrix( const in float i ) {
				mat4 bone = prevBoneMatrices[ int(i) ];
				return bone;
			}
		#endif
		#endif
`
const velocity_vertex_pars =
  /* glsl */
  `
#define MAX_BONES 64
                    
${ShaderChunk.skinning_pars_vertex}
${prev_skinning_pars_vertex}

uniform mat4 velocityMatrix;
uniform mat4 prevVelocityMatrix;
varying vec4 prevPosition;
varying vec4 newPosition;

#ifdef renderDepth
varying vec2 vHighPrecisionZW;
#endif
` // Returns the body of the vertex shader for the velocity buffer

const velocity_vertex_main =
  /* glsl */
  `
// Get the current vertex position
transformed = vec3( position );
${ShaderChunk.skinning_vertex}
newPosition = velocityMatrix * vec4( transformed, 1.0 );

// Get the previous vertex position
transformed = vec3( position );
${ShaderChunk.skinbase_vertex.replace(/mat4 /g, '').replace(/getBoneMatrix/g, 'getPrevBoneMatrix')}
${ShaderChunk.skinning_vertex.replace(/vec4 /g, '')}
prevPosition = prevVelocityMatrix * vec4( transformed, 1.0 );

gl_Position = newPosition;

#ifdef renderDepth
vHighPrecisionZW = gl_Position.zw;
#endif
`
const velocity_fragment_pars =
  /* glsl */
  `
varying vec4 prevPosition;
varying vec4 newPosition;

#ifdef renderDepth
varying vec2 vHighPrecisionZW;
#endif
`
const velocity_fragment_main =
  /* glsl */
  `
vec2 pos0 = (prevPosition.xy / prevPosition.w) * 0.5 + 0.5;
vec2 pos1 = (newPosition.xy / newPosition.w) * 0.5 + 0.5;

vec2 vel = pos1 - pos0;

#ifdef renderDepth
float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
#endif

gl_FragColor = vec4(vel.x, vel.y, 0., 0.);
`
const velocity_uniforms = {
  prevVelocityMatrix: {
    value: new Matrix4()
  },
  velocityMatrix: {
    value: new Matrix4()
  },
  prevBoneTexture: {
    value: null
  },
  boneTexture: {
    value: null
  },
  normalMap: {
    value: null
  },
  normalScale: {
    value: new Vector2(1, 1)
  },
  uvTransform: {
    value: new Matrix3()
  }
}
class VelocityDepthNormalMaterial extends ShaderMaterial {
  constructor() {
    super({
      uniforms: UniformsUtils.clone(velocity_uniforms),
      vertexShader:
        /* glsl */
        `
					#include <common>
					#include <uv_pars_vertex>
					#include <displacementmap_pars_vertex>
					#include <normal_pars_vertex>
					#include <morphtarget_pars_vertex>
					#include <logdepthbuf_pars_vertex>
					#include <clipping_planes_pars_vertex>

					varying vec2 vUv;

					#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
						varying vec3 vViewPosition;
					#endif
					
                    ${velocity_vertex_pars}
        
                    void main() {
						vec3 transformed;

						#include <uv_vertex>

						#include <skinbase_vertex>
						#include <beginnormal_vertex>
						#include <skinnormal_vertex>
						#include <defaultnormal_vertex>

						#include <morphnormal_vertex>
						#include <normal_vertex>
						#include <morphtarget_vertex>
						#include <displacementmap_vertex>
						#include <project_vertex>
						#include <logdepthbuf_vertex>
						#include <clipping_planes_vertex>

						${velocity_vertex_main}

						#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
							vViewPosition = - mvPosition.xyz;
						#endif

						vUv = uv;

                    }`,
      fragmentShader:
        /* glsl */
        `
					#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
						varying vec3 vViewPosition;
					#endif

					${velocity_fragment_pars}
					#include <packing>

					#include <uv_pars_fragment>
					#include <normal_pars_fragment>
					#include <normalmap_pars_fragment>

					varying vec2 vUv;

					// source: https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/
					vec2 OctWrap( vec2 v ) {
						vec2 w = 1.0 - abs( v.yx );
						if (v.x < 0.0) w.x = -w.x;
						if (v.y < 0.0) w.y = -w.y;
						return w;
					}

					vec2 encodeOctWrap(vec3 n) {
						n /= (abs(n.x) + abs(n.y) + abs(n.z));
						n.xy = n.z > 0.0 ? n.xy : OctWrap(n.xy);
						n.xy = n.xy * 0.5 + 0.5;
						return n.xy;
					}

					float packNormal(vec3 normal) {
						return uintBitsToFloat(packHalf2x16(encodeOctWrap(normal)));
					}

                    void main() {
						#define vNormalMapUv vUv

						#include <normal_fragment_begin>
                    	#include <normal_fragment_maps>

						${velocity_fragment_main}
						vec3 worldNormal = normalize((vec4(normal, 0.) * viewMatrix).xyz);
						gl_FragColor.b = packNormal(worldNormal);
						gl_FragColor.a = fragCoordZ;
                    }`
    })
    this.isVelocityMaterial = true
  }
}

const backgroundColor = new Color(0)
const zeroVec2 = new Vector2()
const tmpProjectionMatrix = new Matrix4()
const tmpProjectionMatrixInverse = new Matrix4()
class VelocityDepthNormalPass extends Pass {
  constructor(scene, camera, renderDepth = true) {
    super('velocityDepthNormalPass')
    this.cachedMaterials = new WeakMap()
    this.visibleMeshes = []
    this.needsSwap = false

    if (!(camera instanceof PerspectiveCamera)) {
      throw new Error(this.constructor.name + " doesn't support cameras of type '" + camera.constructor.name + "' yet. Only cameras of type 'PerspectiveCamera' are supported.")
    }

    this._scene = scene
    this._camera = camera
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: FloatType,
      minFilter: NearestFilter,
      magFilter: NearestFilter
    })
    this.renderTarget.depthTexture = new DepthTexture(1, 1)
    this.renderTarget.depthTexture.type = FloatType
    this.renderDepth = renderDepth
  }

  setVelocityDepthNormalMaterialInScene() {
    this.visibleMeshes = getVisibleChildren(this._scene)

    for (const c of this.visibleMeshes) {
      const originalMaterial = c.material
      let [cachedOriginalMaterial, velocityDepthNormalMaterial] = this.cachedMaterials.get(c) || []

      if (originalMaterial !== cachedOriginalMaterial) {
        var _c$skeleton

        velocityDepthNormalMaterial = new VelocityDepthNormalMaterial()
        copyNecessaryProps(originalMaterial, velocityDepthNormalMaterial)
        c.material = velocityDepthNormalMaterial
        if ((_c$skeleton = c.skeleton) != null && _c$skeleton.boneTexture) saveBoneTexture(c)
        this.cachedMaterials.set(c, [originalMaterial, velocityDepthNormalMaterial])
      }

      c.material = velocityDepthNormalMaterial
      c.visible = isChildMaterialRenderable(c, originalMaterial)
      if (this.renderDepth) velocityDepthNormalMaterial.defines.renderDepth = ''
      keepMaterialMapUpdated(velocityDepthNormalMaterial, originalMaterial, 'normalMap', 'USE_NORMALMAP_TANGENTSPACE', true)
      velocityDepthNormalMaterial.uniforms.normalMap.value = originalMaterial.normalMap
      const map = originalMaterial.map || originalMaterial.normalMap || originalMaterial.roughnessMap || originalMaterial.metalnessMap
      if (map) velocityDepthNormalMaterial.uniforms.uvTransform.value = map.matrix
      updateVelocityDepthNormalMaterialBeforeRender(c, this._camera)
    }
  }

  unsetVelocityDepthNormalMaterialInScene() {
    for (const c of this.visibleMeshes) {
      c.visible = true
      updateVelocityDepthNormalMaterialAfterRender(c, this._camera)
      c.material = this.cachedMaterials.get(c)[0]
    }
  }

  setSize(width, height) {
    var _this$lastVelocityTex

    this.renderTarget.setSize(width, height)
    ;(_this$lastVelocityTex = this.lastVelocityTexture) == null ? void 0 : _this$lastVelocityTex.dispose()
    this.lastVelocityTexture = new FramebufferTexture(width, height, RGBAFormat)
    this.lastVelocityTexture.type = FloatType
    this.lastVelocityTexture.minFilter = NearestFilter
    this.lastVelocityTexture.magFilter = NearestFilter
  }

  dispose() {
    super.dispose()
    this.renderTarget.dispose()
  }

  render(renderer) {
    tmpProjectionMatrix.copy(this._camera.projectionMatrix)
    tmpProjectionMatrixInverse.copy(this._camera.projectionMatrixInverse)
    if (this._camera.view) this._camera.view.enabled = false

    this._camera.updateProjectionMatrix() // in case a RenderPass is not being used, so we need to update the camera's world matrix manually

    this._camera.updateMatrixWorld()

    this.setVelocityDepthNormalMaterialInScene()
    const { background } = this._scene
    this._scene.background = backgroundColor
    renderer.setRenderTarget(this.renderTarget)
    renderer.copyFramebufferToTexture(zeroVec2, this.lastVelocityTexture)
    renderer.render(this._scene, this._camera)
    this._scene.background = background
    this.unsetVelocityDepthNormalMaterialInScene()
    if (this._camera.view) this._camera.view.enabled = true

    this._camera.projectionMatrix.copy(tmpProjectionMatrix)

    this._camera.projectionMatrixInverse.copy(tmpProjectionMatrixInverse)
  }
}

class VelocityPass extends VelocityDepthNormalPass {
  constructor(scene, camera) {
    super(scene, camera, false)
  }
}

class AOPass extends Pass {
  constructor(camera, scene, fragmentShader) {
    super()
    this._camera = camera
    this._scene = scene
    this.renderTarget = new WebGLRenderTarget(1, 1, {
      type: HalfFloatType,
      depthBuffer: false
    })
    const finalFragmentShader = fragmentShader.replace('#include <sampleBlueNoise>', sampleBlueNoise)
    this.fullscreenMaterial = new ShaderMaterial({
      fragmentShader: finalFragmentShader,
      vertexShader,
      uniforms: {
        depthTexture: {
          value: null
        },
        normalTexture: {
          value: null
        },
        cameraNear: {
          value: 0
        },
        cameraFar: {
          value: 0
        },
        viewMatrix: {
          value: this._camera.matrixWorldInverse
        },
        projectionViewMatrix: {
          value: new Matrix4()
        },
        projectionMatrixInverse: {
          value: this._camera.projectionMatrixInverse
        },
        cameraMatrixWorld: {
          value: this._camera.matrixWorld
        },
        texSize: {
          value: new Vector2()
        },
        blueNoiseTexture: {
          value: null
        },
        blueNoiseRepeat: {
          value: new Vector2()
        },
        aoDistance: {
          value: 0
        },
        distancePower: {
          value: 0
        },
        bias: {
          value: 0
        },
        thickness: {
          value: 0
        },
        power: {
          value: 0
        },
        frame: {
          value: 0
        }
      },
      blending: NoBlending,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    })
    new TextureLoader().load(blueNoiseImage, (blueNoiseTexture) => {
      blueNoiseTexture.minFilter = NearestFilter
      blueNoiseTexture.magFilter = NearestFilter
      blueNoiseTexture.wrapS = RepeatWrapping
      blueNoiseTexture.wrapT = RepeatWrapping
      blueNoiseTexture.colorSpace = NoColorSpace
      this.fullscreenMaterial.uniforms.blueNoiseTexture.value = blueNoiseTexture
    })
  }

  get texture() {
    return this.renderTarget.texture
  }

  setSize(width, height) {
    this.renderTarget.setSize(width, height)
    this.fullscreenMaterial.uniforms.texSize.value.set(this.renderTarget.width, this.renderTarget.height)
  }

  render(renderer) {
    const spp = +this.fullscreenMaterial.defines.spp
    this.fullscreenMaterial.uniforms.frame.value = (this.fullscreenMaterial.uniforms.frame.value + spp) % 65536
    this.fullscreenMaterial.uniforms.cameraNear.value = this._camera.near
    this.fullscreenMaterial.uniforms.cameraFar.value = this._camera.far
    this.fullscreenMaterial.uniforms.projectionViewMatrix.value.multiplyMatrices(this._camera.projectionMatrix, this._camera.matrixWorldInverse)
    const noiseTexture = this.fullscreenMaterial.uniforms.blueNoiseTexture.value

    if (noiseTexture) {
      const { width, height } = noiseTexture.source.data
      this.fullscreenMaterial.uniforms.blueNoiseRepeat.value.set(this.renderTarget.width / width, this.renderTarget.height / height)
    }

    renderer.setRenderTarget(this.renderTarget)
    renderer.render(this.scene, this.camera)
  }
}

var hbao_utils =
  '#define GLSLIFY 1\n#include <sampleBlueNoise>\nuniform sampler2D normalTexture;uniform float cameraNear;uniform float cameraFar;uniform mat4 projectionMatrixInverse;uniform mat4 cameraMatrixWorld;float getViewZ(const float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 getWorldPos(const float depth,const vec2 coord){float z=depth*2.0-1.0;vec4 clipSpacePosition=vec4(coord*2.0-1.0,z,1.0);vec4 viewSpacePosition=projectionMatrixInverse*clipSpacePosition;vec4 worldSpacePosition=cameraMatrixWorld*viewSpacePosition;worldSpacePosition.xyz/=worldSpacePosition.w;return worldSpacePosition.xyz;}vec3 slerp(const vec3 a,const vec3 b,const float t){float cosAngle=dot(a,b);float angle=acos(cosAngle);if(abs(angle)<0.001){return mix(a,b,t);}float sinAngle=sin(angle);float t1=sin((1.0-t)*angle)/sinAngle;float t2=sin(t*angle)/sinAngle;return(a*t1)+(b*t2);}vec3 computeWorldNormal(){vec2 size=vec2(textureSize(depthTexture,0));ivec2 p=ivec2(vUv*size);float c0=texelFetch(depthTexture,p,0).x;float l2=texelFetch(depthTexture,p-ivec2(2,0),0).x;float l1=texelFetch(depthTexture,p-ivec2(1,0),0).x;float r1=texelFetch(depthTexture,p+ivec2(1,0),0).x;float r2=texelFetch(depthTexture,p+ivec2(2,0),0).x;float b2=texelFetch(depthTexture,p-ivec2(0,2),0).x;float b1=texelFetch(depthTexture,p-ivec2(0,1),0).x;float t1=texelFetch(depthTexture,p+ivec2(0,1),0).x;float t2=texelFetch(depthTexture,p+ivec2(0,2),0).x;float dl=abs((2.0*l1-l2)-c0);float dr=abs((2.0*r1-r2)-c0);float db=abs((2.0*b1-b2)-c0);float dt=abs((2.0*t1-t2)-c0);vec3 ce=getWorldPos(c0,vUv).xyz;vec3 dpdx=(dl<dr)? ce-getWorldPos(l1,(vUv-vec2(1.0/size.x,0.0))).xyz:-ce+getWorldPos(r1,(vUv+vec2(1.0/size.x,0.0))).xyz;vec3 dpdy=(db<dt)? ce-getWorldPos(b1,(vUv-vec2(0.0,1.0/size.y))).xyz:-ce+getWorldPos(t1,(vUv+vec2(0.0,1.0/size.y))).xyz;return normalize(cross(dpdx,dpdy));}vec3 getWorldNormal(const vec2 uv){\n#ifdef useNormalTexture\nvec3 worldNormal=unpackRGBToNormal(textureLod(normalTexture,uv,0.).rgb);worldNormal=(vec4(worldNormal,1.)*viewMatrix).xyz;return normalize(worldNormal);\n#else\nreturn computeWorldNormal();\n#endif\n}\n#define PI 3.14159265358979323846264338327950288\nvec3 cosineSampleHemisphere(const vec3 n,const vec2 u){float r=sqrt(u.x);float theta=2.0*PI*u.y;vec3 b=normalize(cross(n,vec3(0.0,1.0,1.0)));vec3 t=cross(b,n);return normalize(r*sin(theta)*b+sqrt(1.0-u.x)*n+r*cos(theta)*t);}' // eslint-disable-line

var fragmentShader$1 =
  '#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D depthTexture;uniform mat4 projectionViewMatrix;uniform int frame;uniform sampler2D blueNoiseTexture;uniform vec2 blueNoiseRepeat;uniform vec2 texSize;uniform float aoDistance;uniform float distancePower;uniform float bias;uniform float thickness;\n#include <packing>\n#include <hbao_utils>\nfloat getOcclusion(const vec3 cameraPosition,const vec3 worldPos,const vec3 worldNormal,const float depth,const int seed,inout float totalWeight){vec4 blueNoise=sampleBlueNoise(blueNoiseTexture,seed,blueNoiseRepeat,texSize);vec3 sampleWorldDir=cosineSampleHemisphere(worldNormal,blueNoise.rg);vec3 sampleWorldPos=worldPos+aoDistance*pow(blueNoise.b,distancePower+1.0)*sampleWorldDir;vec4 sampleUv=projectionViewMatrix*vec4(sampleWorldPos,1.);sampleUv.xy/=sampleUv.w;sampleUv.xy=sampleUv.xy*0.5+0.5;float sampleDepth=textureLod(depthTexture,sampleUv.xy,0.0).r;float deltaDepth=depth-sampleDepth;float d=distance(sampleWorldPos,cameraPosition);deltaDepth*=0.001*d*d;float th=thickness*0.01;float theta=dot(worldNormal,sampleWorldDir);totalWeight+=theta;if(deltaDepth<th){float horizon=sampleDepth+deltaDepth*bias*1000.;float occlusion=max(0.0,horizon-depth)*theta;float m=max(0.,1.-deltaDepth/th);occlusion=10.*occlusion*m/d;occlusion=sqrt(occlusion);return occlusion;}return 0.;}void main(){float depth=textureLod(depthTexture,vUv,0.0).r;if(depth==1.0){discard;return;}vec4 cameraPosition=cameraMatrixWorld*vec4(0.0,0.0,0.0,1.0);vec3 worldPos=getWorldPos(depth,vUv);vec3 worldNormal=getWorldNormal(vUv);float ao=0.0,totalWeight=0.0;for(int i=0;i<spp;i++){int seed=i;\n#ifdef animatedNoise\nseed+=frame;\n#endif\nfloat occlusion=getOcclusion(cameraPosition.xyz,worldPos,worldNormal,depth,seed,totalWeight);ao+=occlusion;}if(totalWeight>0.)ao/=totalWeight;ao=clamp(1.-ao,0.,1.);gl_FragColor=vec4(worldNormal,ao);}' // eslint-disable-line

const finalFragmentShader = fragmentShader$1.replace('#include <hbao_utils>', hbao_utils)

class HBAOPass extends AOPass {
  constructor(camera, scene) {
    super(camera, scene, finalFragmentShader)
  }
}

var ao_compose = '#define GLSLIFY 1\nuniform sampler2D inputTexture;uniform sampler2D depthTexture;uniform float power;uniform vec3 color;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float unpackedDepth=textureLod(depthTexture,uv,0.).r;float ao=unpackedDepth>0.9999 ? 1.0 : textureLod(inputTexture,uv,0.0).a;ao=pow(ao,power);vec3 aoColor=mix(color,vec3(1.),ao);aoColor*=inputColor.rgb;outputColor=vec4(aoColor,inputColor.a);}' // eslint-disable-line

const defaultAOOptions = {
  resolutionScale: 1,
  spp: 8,
  distance: 2,
  distancePower: 1,
  power: 2,
  bias: 40,
  thickness: 0.075,
  color: new Color('black'),
  useNormalPass: false,
  velocityDepthNormalPass: null,
  normalTexture: null,
  ...PoissionDenoisePass.DefaultOptions
}

class AOEffect extends Effect {
  constructor(composer, camera, scene, aoPass, options = defaultAOOptions) {
    super('AOEffect', ao_compose, {
      type: 'FinalAOMaterial',
      uniforms: new Map([
        ['inputTexture', new Uniform(null)],
        ['depthTexture', new Uniform(null)],
        ['power', new Uniform(0)],
        ['color', new Uniform(new Color('black'))]
      ])
    })
    this.lastSize = {
      width: 0,
      height: 0,
      resolutionScale: 0
    }
    this.composer = composer
    this.aoPass = aoPass
    options = { ...defaultAOOptions, ...options } // set up depth texture

    if (!composer.depthTexture) composer.createDepthTexture()
    this.aoPass.fullscreenMaterial.uniforms.depthTexture.value = composer.depthTexture
    this.uniforms.get('depthTexture').value = composer.depthTexture // set up optional normal texture

    if (options.useNormalPass || options.normalTexture) {
      var _options$normalTextur

      if (options.useNormalPass) this.normalPass = new NormalPass(scene, camera)
      const normalTexture = (_options$normalTextur = options.normalTexture) !== null && _options$normalTextur !== void 0 ? _options$normalTextur : this.normalPass.texture
      this.aoPass.fullscreenMaterial.uniforms.normalTexture.value = normalTexture
      this.aoPass.fullscreenMaterial.defines.useNormalTexture = ''
    }

    this.poissionDenoisePass = new PoissionDenoisePass(camera, this.aoPass.texture, composer.depthTexture, {
      normalInRgb: true
    })
    this.makeOptionsReactive(options)
  }

  makeOptionsReactive(options) {
    for (const key of Object.keys(options)) {
      Object.defineProperty(this, key, {
        get() {
          return options[key]
        },

        set(value) {
          if (value === null || value === undefined) return
          options[key] = value

          switch (key) {
            case 'spp':
              this.aoPass.fullscreenMaterial.defines.spp = value.toFixed(0)
              this.aoPass.fullscreenMaterial.needsUpdate = true
              break

            case 'distance':
              this.aoPass.fullscreenMaterial.uniforms.aoDistance.value = value
              break

            case 'resolutionScale':
              this.setSize(this.lastSize.width, this.lastSize.height)
              break

            case 'power':
              this.uniforms.get('power').value = value
              break

            case 'color':
              this.uniforms.get('color').value.copy(new Color(value))
              break
            // denoiser

            case 'iterations':
            case 'radius':
            case 'rings':
            case 'samples':
              this.poissionDenoisePass[key] = value
              break

            case 'lumaPhi':
            case 'depthPhi':
            case 'normalPhi':
              this.poissionDenoisePass.fullscreenMaterial.uniforms[key].value = Math.max(value, 0.0001)
              break

            default:
              if (key in this.aoPass.fullscreenMaterial.uniforms) {
                this.aoPass.fullscreenMaterial.uniforms[key].value = value
              }
          }
        },

        configurable: true
      }) // apply all uniforms and defines

      this[key] = options[key]
    }
  }

  setSize(width, height) {
    var _this$normalPass

    if (width === undefined || height === undefined) return

    if (width === this.lastSize.width && height === this.lastSize.height && this.resolutionScale === this.lastSize.resolutionScale) {
      return
    }

    ;(_this$normalPass = this.normalPass) == null ? void 0 : _this$normalPass.setSize(width, height)
    this.aoPass.setSize(width * this.resolutionScale, height * this.resolutionScale)
    this.poissionDenoisePass.setSize(width, height)
    this.lastSize = {
      width,
      height,
      resolutionScale: this.resolutionScale
    }
  }

  get texture() {
    if (this.iterations > 0) {
      return this.poissionDenoisePass.texture
    }

    return this.aoPass.texture
  }

  update(renderer) {
    var _this$normalPass2

    // check if TRAA is being used so we can animate the noise
    const hasTRAA = this.composer.passes.some((pass) => {
      var _pass$effects

      return pass.enabled && !pass.skipRendering && ((_pass$effects = pass.effects) == null ? void 0 : _pass$effects.some((effect) => effect instanceof TRAAEffect))
    }) // set animated noise depending on TRAA

    if (hasTRAA && !('animatedNoise' in this.aoPass.fullscreenMaterial.defines)) {
      this.aoPass.fullscreenMaterial.defines.animatedNoise = ''
      this.aoPass.fullscreenMaterial.needsUpdate = true
    } else if (!hasTRAA && 'animatedNoise' in this.aoPass.fullscreenMaterial.defines) {
      delete this.aoPass.fullscreenMaterial.defines.animatedNoise
      this.aoPass.fullscreenMaterial.needsUpdate = true
    }

    this.uniforms.get('inputTexture').value = this.texture
    ;(_this$normalPass2 = this.normalPass) == null ? void 0 : _this$normalPass2.render(renderer)
    this.aoPass.render(renderer)
    this.poissionDenoisePass.render(renderer)
  }
}

AOEffect.DefaultOptions = defaultAOOptions

class HBAOEffect extends AOEffect {
  constructor(composer, camera, scene, options = AOEffect.DefaultOptions) {
    const hbaoPass = new HBAOPass(camera, scene)
    options = { ...AOEffect.DefaultOptions, ...HBAOEffect.DefaultOptions, ...options }
    super(composer, camera, scene, hbaoPass, options)
    this.lastSize = {
      width: 0,
      height: 0,
      resolutionScale: 0
    }
    options = { ...AOEffect.DefaultOptions, ...options }
  }
}

var fragmentShader =
  '#define GLSLIFY 1\nvarying vec2 vUv;uniform sampler2D depthTexture;uniform sampler2D normalTexture;uniform mat4 projectionViewMatrix;uniform mat4 cameraMatrixWorld;uniform sampler2D blueNoiseTexture;uniform vec2 blueNoiseRepeat;uniform vec2 texSize;uniform mat4 projectionMatrixInverse;uniform float aoDistance;uniform float distancePower;uniform float cameraNear;uniform float cameraFar;uniform int frame;uniform vec3[spp]samples;uniform float[spp]samplesR;\n#include <common>\n#include <packing>\n#include <sampleBlueNoise>\nvec3 getWorldPos(const float depth,const vec2 coord){float z=depth*2.0-1.0;vec4 clipSpacePosition=vec4(coord*2.0-1.0,z,1.0);vec4 viewSpacePosition=projectionMatrixInverse*clipSpacePosition;vec4 worldSpacePosition=cameraMatrixWorld*viewSpacePosition;worldSpacePosition.xyz/=worldSpacePosition.w;return worldSpacePosition.xyz;}vec3 computeNormal(vec3 worldPos,vec2 vUv){vec2 size=vec2(textureSize(depthTexture,0));ivec2 p=ivec2(vUv*size);float c0=texelFetch(depthTexture,p,0).x;float l2=texelFetch(depthTexture,p-ivec2(2,0),0).x;float l1=texelFetch(depthTexture,p-ivec2(1,0),0).x;float r1=texelFetch(depthTexture,p+ivec2(1,0),0).x;float r2=texelFetch(depthTexture,p+ivec2(2,0),0).x;float b2=texelFetch(depthTexture,p-ivec2(0,2),0).x;float b1=texelFetch(depthTexture,p-ivec2(0,1),0).x;float t1=texelFetch(depthTexture,p+ivec2(0,1),0).x;float t2=texelFetch(depthTexture,p+ivec2(0,2),0).x;float dl=abs((2.0*l1-l2)-c0);float dr=abs((2.0*r1-r2)-c0);float db=abs((2.0*b1-b2)-c0);float dt=abs((2.0*t1-t2)-c0);vec3 ce=getWorldPos(c0,vUv).xyz;vec3 dpdx=(dl<dr)? ce-getWorldPos(l1,(vUv-vec2(1.0/size.x,0.0))).xyz:-ce+getWorldPos(r1,(vUv+vec2(1.0/size.x,0.0))).xyz;vec3 dpdy=(db<dt)? ce-getWorldPos(b1,(vUv-vec2(0.0,1.0/size.y))).xyz:-ce+getWorldPos(t1,(vUv+vec2(0.0,1.0/size.y))).xyz;return normalize(cross(dpdx,dpdy));}highp float linearize_depth(highp float d,highp float zNear,highp float zFar){highp float z_n=2.0*d-1.0;return 2.0*zNear*zFar/(zFar+zNear-z_n*(zFar-zNear));}void main(){float depth=textureLod(depthTexture,vUv,0.).x;if(depth==1.0){discard;return;}vec3 worldPos=getWorldPos(depth,vUv);vec3 normal=computeNormal(worldPos,vUv);\n#ifdef animatedNoise\nint seed=frame;\n#else\nint seed=0;\n#endif\nvec4 noise=sampleBlueNoise(blueNoiseTexture,seed,blueNoiseRepeat,texSize);vec3 randomVec=normalize(noise.rgb*2.0-1.0);vec3 tangent=normalize(randomVec-normal*dot(randomVec,normal));vec3 bitangent=cross(normal,tangent);mat3 tbn=mat3(tangent,bitangent,normal);float occluded=0.0;float totalWeight=0.0;vec3 samplePos;float sppF=float(spp);for(float i=0.0;i<sppF;i++){vec3 sampleDirection=tbn*samples[int(i)];if(dot(sampleDirection,normal)<0.0)sampleDirection*=-1.0;float moveAmt=samplesR[int(mod(i+noise.a*sppF,sppF))];samplePos=worldPos+aoDistance*moveAmt*sampleDirection;vec4 offset=projectionViewMatrix*vec4(samplePos,1.0);offset.xyz/=offset.w;offset.xyz=offset.xyz*0.5+0.5;float sampleDepth=textureLod(depthTexture,offset.xy,0.0).x;float distSample=linearize_depth(sampleDepth,cameraNear,cameraFar);float distWorld=linearize_depth(offset.z,cameraNear,cameraFar);float rangeCheck=smoothstep(0.0,1.0,aoDistance/(aoDistance*abs(distSample-distWorld)));rangeCheck=pow(rangeCheck,distancePower);float weight=dot(sampleDirection,normal);occluded+=rangeCheck*weight*(distSample<distWorld ? 1.0 : 0.0);totalWeight+=weight;}float occ=clamp(1.0-occluded/totalWeight,0.0,1.0);gl_FragColor=vec4(normal,occ);}' // eslint-disable-line

class SSAOPass extends AOPass {
  constructor(camera, scene) {
    super(camera, scene, fragmentShader)
  }
}

function getPointsOnSphere(n) {
  const points = []
  const inc = Math.PI * (3 - Math.sqrt(5))
  const off = 2 / n

  for (let k = 0; k < n; k++) {
    const y = k * off - 1 + off / 2
    const r = Math.sqrt(1 - y * y)
    const phi = k * inc
    points.push(new Vector3(Math.cos(phi) * r, y, Math.sin(phi) * r))
  }

  return points
}

class SSAOEffect extends AOEffect {
  constructor(composer, camera, scene, options = {}) {
    SSAOEffect.DefaultOptions = {
      ...AOEffect.DefaultOptions,
      ...{
        spp: 16,
        distance: 1,
        distancePower: 0.25,
        power: 2
      }
    }
    options = { ...SSAOEffect.DefaultOptions, ...options }
    const aoPass = new SSAOPass(camera, scene)
    super(composer, camera, scene, aoPass, options)
  }

  makeOptionsReactive(options) {
    super.makeOptionsReactive(options)

    for (const key of ['spp']) {
      Object.defineProperty(this, key, {
        get() {
          return options[key]
        },

        set(value) {
          if (value === null || value === undefined) return
          options[key] = value

          switch (key) {
            case 'spp':
              this.aoPass.fullscreenMaterial.defines.spp = value.toFixed(0)
              const samples = getPointsOnSphere(value)
              const samplesR = []

              for (let i = 0; i < value; i++) {
                samplesR.push((i + 1) / value)
              }

              this.aoPass.fullscreenMaterial.uniforms.samples = {
                value: samples
              }
              this.aoPass.fullscreenMaterial.uniforms.samplesR = {
                value: samplesR
              }
              this.aoPass.fullscreenMaterial.needsUpdate = true
              break
          }
        },

        configurable: true
      })
    }

    this.spp = options['spp']
  }
}

export { HBAOEffect, MotionBlurEffect, PoissionDenoisePass, SSAOEffect, SSDGIEffect, SSGIEffect, SS

REffect, SVGF, TRAAEffect, TemporalReprojectPass, VelocityDepthNormalPass, VelocityPass }

import * as THREE from 'three'
import { useEffect, useRef, useState } from 'react'
import { Canvas, extend, useFrame, useThree } from '@react-three/fiber'
import { useCursor, MeshPortalMaterial, CameraControls, Gltf, Text, Preload } from '@react-three/drei'
import { useRoute, useLocation } from 'wouter'
import { easing, geometry } from 'maath'
import { suspend } from 'suspend-react'

extend(geometry)
const regular = import('@pmndrs/assets/fonts/inter_regular.woff')
const medium = import('@pmndrs/assets/fonts/inter_medium.woff')

export const App = () => (
  <Canvas flat camera={{ fov: 75, position: [0, 0, 20] }} eventSource={document.getElementById('root')} eventPrefix="client">
    <color attach="background" args={['#f0f0f0']} />
    <Frame id="01" name={`pick\nles`} author="Omar Faruq Tawsif" bg="#e4cdac" position={[-1.15, 0, 0]} rotation={[0, 0.5, 0]}>
      <Gltf src="pickles_3d_version_of_hyuna_lees_illustration-transformed.glb" scale={8} position={[0, -0.7, -2]} />
    </Frame>
    <Frame id="02" name="tea" author="Omar Faruq Tawsif">
      <Gltf src="fiesta_tea-transformed.glb" position={[0, -2, -3]} />
    </Frame>
    <Frame id="03" name="still" author="Omar Faruq Tawsif" bg="#d1d1ca" position={[1.15, 0, 0]} rotation={[0, -0.5, 0]}>
      <Gltf src="still_life_based_on_heathers_artwork-transformed.glb" scale={2} position={[0, -0.8, -4]} />
    </Frame>
    <Rig />
    <Preload all />
  </Canvas>
)

function Frame({ id, name, author, bg, width = 1, height = 1.61803398875, children, ...props }) {
  const portal = useRef()
  const [, setLocation] = useLocation()
  const [, params] = useRoute('/item/:id')
  const [hovered, hover] = useState(false)
  useCursor(hovered)
  useFrame((state, dt) => easing.damp(portal.current, 'blend', params?.id === id ? 1 : 0, 0.2, dt))
  return (
    <group {...props}>
      <Text font={suspend(medium).default} fontSize={0.3} anchorY="top" anchorX="left" lineHeight={0.8} position={[-0.375, 0.715, 0.01]} material-toneMapped={false}>
        {name}
      </Text>
      <Text font={suspend(regular).default} fontSize={0.1} anchorX="right" position={[0.4, -0.659, 0.01]} material-toneMapped={false}>
        /{id}
      </Text>
      <Text font={suspend(regular).default} fontSize={0.04} anchorX="right" position={[0.0, -0.677, 0.01]} material-toneMapped={false}>
        {author}
      </Text>
      <mesh name={id} onDoubleClick={(e) => (e.stopPropagation(), setLocation('/item/' + e.object.name))} onPointerOver={(e) => hover(true)} onPointerOut={() => hover(false)}>
        <roundedPlaneGeometry args={[width, height, 0.1]} />
        <MeshPortalMaterial ref={portal} events={params?.id === id} side={THREE.DoubleSide}>
          <color attach="background" args={[bg]} />
          {children}
        </MeshPortalMaterial>
      </mesh>
    </group>
  )
}

function Rig({ position = new THREE.Vector3(0, 0, 2), focus = new THREE.Vector3(0, 0, 0) }) {
  const { controls, scene } = useThree()
  const [, params] = useRoute('/item/:id')
  useEffect(() => {
    const active = scene.getObjectByName(params?.id)
    if (active) {
      active.parent.localToWorld(position.set(0, 0.5, 0.25))
      active.parent.localToWorld(focus.set(0, 0, -2))
    }
    controls?.setLookAt(...position.toArray(), ...focus.toArray(), true)
  })
  return <CameraControls makeDefault minPolarAngle={0} maxPolarAngle={Math.PI / 2} />
}



import * as THREE from 'three'
import { Canvas, extend } from '@react-three/fiber'
import { useGLTF, MeshPortalMaterial, CameraControls, Text, Sky } from '@react-three/drei'
import { geometry } from 'maath'
import { suspend } from 'suspend-react'

extend(geometry)
const GOLDENRATIO = 1.61803398875
const regular = import('@pmndrs/assets/fonts/inter_regular.woff')
const medium = import('@pmndrs/assets/fonts/inter_medium.woff')
const zPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0)
const yPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 1)

export const App = () => (
  <Canvas gl={{ localClippingEnabled: true }} camera={{ fov: 75, position: [0, 0, 1.5] }} eventSource={document.getElementById('root')} eventPrefix="client">
    <color attach="background" args={['#f0f0f0']} />
    <Frame id="01" name="Jesse" author="McCree">
      <Sky />
      <Model position={[0, -2, 0]} />
    </Frame>
    <Model clip position={[0, -2, 0]} />
    <CameraControls makeDefault minAzimuthAngle={-Math.PI / 2.5} maxAzimuthAngle={Math.PI / 2.5} minPolarAngle={0.5} maxPolarAngle={Math.PI / 2} />
  </Canvas>
)

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.3 mccree.glb
Author: Seafoam (https://sketchfab.com/seafoam)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/low-poly-mccree-38aedc02c0b2412babdc4d0eac7c6803
Title: Low poly McCree
*/
function Model({ clip, ...props }) {
  const { nodes, materials } = useGLTF('/low_poly_mccree-transformed.glb')
  return (
    <mesh geometry={nodes.base.geometry} {...props} dispose={null}>
      <meshBasicMaterial map={materials.PaletteMaterial001.map} side={THREE.DoubleSide} clippingPlanes={clip ? [zPlane, yPlane] : null} />
    </mesh>
  )
}

function Frame({ id, name, author, bg, width = 1, height = GOLDENRATIO, children, ...props }) {
  return (
    <group {...props}>
      <Text font={suspend(medium).default} color="black" fontSize={0.25} letterSpacing={-0.025} anchorY="top" anchorX="left" lineHeight={0.8} position={[-0.375, 0.715, 0.01]}>
        {name}
      </Text>
      <Text font={suspend(regular).default} color="black" fontSize={0.1} anchorX="right" position={[0.4, -0.659, 0.01]}>
        /{id}
      </Text>
      <Text font={suspend(regular).default} color="black" fontSize={0.04} anchorX="left" position={[0.0, -0.677, 0.01]}>
        {author}
      </Text>
      <mesh name={id}>
        <roundedPlaneGeometry args={[width, height, 0.1]} />
        <MeshPortalMaterial>{children}</MeshPortalMaterial>
      </mesh>
      <mesh name={id} position={[0, 0, -0.001]}>
        <roundedPlaneGeometry args={[width + 0.05, height + 0.05, 0.12]} />
        <meshBasicMaterial color="black" />
      </mesh>
    </group>
  )
}

import { useRef } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { useGLTF, Edges, MeshPortalMaterial, CameraControls, Environment, PivotControls } from '@react-three/drei'
import { useControls } from 'leva'

export const App = () => (
  <Canvas shadows camera={{ position: [-3, 0.5, 3] }}>
    <PivotControls anchor={[-1.1, -1.1, -1.1]} scale={0.75} lineWidth={3.5}>
      <mesh castShadow receiveShadow>
        <boxGeometry args={[2, 2, 2]} />
        <Edges />
        <Side rotation={[0, 0, 0]} bg="orange" index={0}>
          <torusGeometry args={[0.65, 0.3, 64]} />
        </Side>
        <Side rotation={[0, Math.PI, 0]} bg="lightblue" index={1}>
          <torusKnotGeometry args={[0.55, 0.2, 128, 32]} />
        </Side>
        <Side rotation={[0, Math.PI / 2, Math.PI / 2]} bg="lightgreen" index={2}>
          <boxGeometry args={[1.15, 1.15, 1.15]} />
        </Side>
        <Side rotation={[0, Math.PI / 2, -Math.PI / 2]} bg="aquamarine" index={3}>
          <octahedronGeometry />
        </Side>
        <Side rotation={[0, -Math.PI / 2, 0]} bg="indianred" index={4}>
          <icosahedronGeometry />
        </Side>
        <Side rotation={[0, Math.PI / 2, 0]} bg="hotpink" index={5}>
          <dodecahedronGeometry />
        </Side>
      </mesh>
    </PivotControls>
    <CameraControls makeDefault />
  </Canvas>
)

function Side({ rotation = [0, 0, 0], bg = '#f0f0f0', children, index }) {
  const mesh = useRef()
  const { worldUnits } = useControls({ worldUnits: false })
  const { nodes } = useGLTF('/aobox-transformed.glb')
  useFrame((state, delta) => {
    mesh.current.rotation.x = mesh.current.rotation.y += delta
  })
  return (
    <MeshPortalMaterial worldUnits={worldUnits} attach={`material-${index}`}>
      {/** Everything in here is inside the portal and isolated from the canvas */}
      <ambientLight intensity={0.5} />
      <Environment preset="city" />
      {/** A box with baked AO */}
      <mesh castShadow receiveShadow rotation={rotation} geometry={nodes.Cube.geometry}>
        <meshStandardMaterial aoMapIntensity={1} aoMap={nodes.Cube.material.aoMap} color={bg} />
        <spotLight castShadow color={bg} intensity={2} position={[10, 10, 10]} angle={0.15} penumbra={1} shadow-normalBias={0.05} shadow-bias={0.0001} />
      </mesh>
      {/** The shape */}
      <mesh castShadow receiveShadow ref={mesh}>
        {children}
        <meshLambertMaterial color={bg} />
      </mesh>
    </MeshPortalMaterial>
  )
}






// https://twitter.com/igor_3000A/status/1646542441112297474

import * as THREE from 'three'
import { Canvas, useLoader } from '@react-three/fiber'
import { Environment, Lightformer, OrbitControls, MeshTransmissionMaterial, useGLTF } from '@react-three/drei'
import { EffectComposer, Bloom, LUT, BrightnessContrast, HueSaturation, ToneMapping } from '@react-three/postprocessing'
import { LUTCubeLoader, ToneMappingMode } from 'postprocessing'

function Model(props) {
  const { nodes } = useGLTF('/flower-transformed.glb')
  return (
    <group {...props} dispose={null}>
      <mesh geometry={nodes.petals.geometry}>
        <MeshTransmissionMaterial
          backside
          backsideThickness={1}
          samples={16}
          thickness={0.2}
          anisotropicBlur={0.1}
          iridescence={1}
          iridescenceIOR={1}
          iridescenceThicknessRange={[0, 1400]}
          clearcoat={1}
          envMapIntensity={0.5}
        />
        <mesh geometry={nodes.Sphere.geometry}>
          <MeshTransmissionMaterial samples={6} resolution={512} thickness={-1} anisotropy={0.25} />
        </mesh>
      </mesh>
      <mesh geometry={nodes.Sphere001.geometry}>
        <meshStandardMaterial toneMapped={false} emissive="hotpink" color="red" emissiveIntensity={2} />
      </mesh>
    </group>
  )
}

export default function App() {
  const texture = useLoader(LUTCubeLoader, '/F-6800-STD.cube')
  return (
    <Canvas
      gl={{ antialias: false }}
      camera={{ position: [0, 2.5, 5], fov: 35 }}
      onCreated={(state) => {
        state.gl.toneMapping = THREE.NoToneMapping
      }}>
      <color attach="background" args={['#151520']} />
      <ambientLight intensity={0.5} />
      <spotLight position={[10, 10, 10]} angle={0.15} penumbra={1} />
      <pointLight position={[-10, -10, -10]} />
      <Model position={[0, -0.25, 0]} />
      <OrbitControls />
      <Environment files="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/blue_photo_studio_1k.hdr" resolution={512}>
        <group rotation={[0, 0, 1]}>
          <Lightformer form="circle" intensity={10} position={[0, 10, -10]} scale={20} onUpdate={(self) => self.lookAt(0, 0, 0)} />
          <Lightformer intensity={0.1} onUpdate={(self) => self.lookAt(0, 0, 0)} position={[-5, 1, -1]} rotation-y={Math.PI / 2} scale={[50, 10, 1]} />
          <Lightformer intensity={0.1} onUpdate={(self) => self.lookAt(0, 0, 0)} position={[10, 1, 0]} rotation-y={-Math.PI / 2} scale={[50, 10, 1]} />
          <Lightformer color="white" intensity={0.2} onUpdate={(self) => self.lookAt(0, 0, 0)} position={[0, 1, 0]} scale={[10, 100, 1]} />
        </group>
      </Environment>
      <EffectComposer disableNormalPass>
        <Bloom mipmapBlur luminanceThreshold={1} intensity={2} />
        <LUT lut={texture} />
        <BrightnessContrast brightness={0} contrast={0.1} />
        <HueSaturation hue={0} saturation={-0.25} />
        <ToneMapping mode={ToneMappingMode.ACES_FILMIC} />
      </EffectComposer>
    </Canvas>
  )
}

import * as THREE from 'three'
import { useLayoutEffect, useMemo, useRef, useState } from 'react'
import { Canvas, extend, useFrame } from '@react-three/fiber'
import { Image, ScrollControls, useScroll, Billboard, Text } from '@react-three/drei'
import { suspend } from 'suspend-react'
import { generate } from 'random-words'
import { easing, geometry } from 'maath'

extend(geometry)
const inter = import('@pmndrs/assets/fonts/inter_regular.woff')

export const App = () => (
  <Canvas dpr={[1, 1.5]}>
    <ScrollControls pages={4} infinite>
      <Scene position={[0, 1.5, 0]} />
    </ScrollControls>
  </Canvas>
)

function Scene({ children, ...props }) {
  const ref = useRef()
  const scroll = useScroll()
  const [hovered, hover] = useState(null)
  useFrame((state, delta) => {
    ref.current.rotation.y = -scroll.offset * (Math.PI * 2) // Rotate contents
    state.events.update() // Raycasts every frame rather than on pointer-move
    easing.damp3(state.camera.position, [-state.pointer.x * 2, state.pointer.y * 2 + 4.5, 9], 0.3, delta)
    state.camera.lookAt(0, 0, 0)
  })
  return (
    <group ref={ref} {...props}>
      <Cards category="spring" from={0} len={Math.PI / 4} onPointerOver={hover} onPointerOut={hover} />
      <Cards category="summer" from={Math.PI / 4} len={Math.PI / 2} position={[0, 0.4, 0]} onPointerOver={hover} onPointerOut={hover} />
      <Cards category="autumn" from={Math.PI / 4 + Math.PI / 2} len={Math.PI / 2} onPointerOver={hover} onPointerOut={hover} />
      <Cards category="winter" from={Math.PI * 1.25} len={Math.PI * 2 - Math.PI * 1.25} position={[0, -0.4, 0]} onPointerOver={hover} onPointerOut={hover} />
      <ActiveCard hovered={hovered} />
    </group>
  )
}

function Cards({ category, data, from = 0, len = Math.PI * 2, radius = 5.25, onPointerOver, onPointerOut, ...props }) {
  const [hovered, hover] = useState(null)
  const amount = Math.round(len * 22)
  const textPosition = from + (amount / 2 / amount) * len
  return (
    <group {...props}>
      <Billboard position={[Math.sin(textPosition) * radius * 1.4, 0.5, Math.cos(textPosition) * radius * 1.4]}>
        <Text font={suspend(inter).default} fontSize={0.25} anchorX="center" color="black">
          {category}
        </Text>
      </Billboard>
      {Array.from({ length: amount - 3 /* minus 3 images at the end, creates a gap */ }, (_, i) => {
        const angle = from + (i / amount) * len
        return (
          <Card
            key={angle}
            onPointerOver={(e) => (e.stopPropagation(), hover(i), onPointerOver(i))}
            onPointerOut={() => (hover(null), onPointerOut(null))}
            position={[Math.sin(angle) * radius, 0, Math.cos(angle) * radius]}
            rotation={[0, Math.PI / 2 + angle, 0]}
            active={hovered !== null}
            hovered={hovered === i}
            url={`/img${Math.floor(i % 10) + 1}.jpg`}
          />
        )
      })}
    </group>
  )
}

function Card({ url, active, hovered, ...props }) {
  const ref = useRef()
  useFrame((state, delta) => {
    const f = hovered ? 1.4 : active ? 1.25 : 1
    easing.damp3(ref.current.position, [0, hovered ? 0.25 : 0, 0], 0.1, delta)
    easing.damp3(ref.current.scale, [1.618 * f, 1 * f, 1], 0.15, delta)
  })
  return (
    <group {...props}>
      <Image ref={ref} transparent radius={0.075} url={url} scale={[1.618, 1, 1]} side={THREE.DoubleSide} />
    </group>
  )
}

function ActiveCard({ hovered, ...props }) {
  const ref = useRef()
  const name = useMemo(() => generate({ exactly: 2 }).join(' '), [hovered])
  useLayoutEffect(() => void (ref.current.material.zoom = 0.8), [hovered])
  useFrame((state, delta) => {
    easing.damp(ref.current.material, 'zoom', 1, 0.5, delta)
    easing.damp(ref.current.material, 'opacity', hovered !== null, 0.3, delta)
  })
  return (
    <Billboard {...props}>
      <Text font={suspend(inter).default} fontSize={0.5} position={[2.15, 3.85, 0]} anchorX="left" color="black">
        {hovered !== null && `${name}\n${hovered}`}
      </Text>
      <Image ref={ref} transparent radius={0.3} position={[0, 1.5, 0]} scale={[3.5, 1.618 * 3.5, 0.2, 1]} url={`/img${Math.floor(hovered % 10) + 1}.jpg`} />
    </Billboard>
  )
}



import * as THREE from "three"
import { useRef } from "react"
import { Canvas, useFrame } from "@react-three/fiber"
import { Environment, useGLTF } from "@react-three/drei"
import { EffectComposer, N8AO } from "@react-three/postprocessing"
import { BallCollider, Physics, RigidBody, CylinderCollider } from "@react-three/rapier"

THREE.ColorManagement.legacyMode = false
const baubleMaterial = new THREE.MeshLambertMaterial({ color: "#c0a0a0", emissive: "red" })
const capMaterial = new THREE.MeshStandardMaterial({ metalness: 0.75, roughness: 0.15, color: "#8a492f", emissive: "#600000", envMapIntensity: 20 })
const sphereGeometry = new THREE.SphereGeometry(1, 28, 28)
const baubles = [...Array(50)].map(() => ({ scale: [0.75, 0.75, 1, 1, 1.25][Math.floor(Math.random() * 5)] }))

function Bauble({ vec = new THREE.Vector3(), scale, r = THREE.MathUtils.randFloatSpread }) {
  const { nodes } = useGLTF("/cap.glb")
  const api = useRef()
  useFrame((state, delta) => {
    delta = Math.min(0.1, delta)
    api.current.applyImpulse(
      vec
        .copy(api.current.translation())
        .normalize()
        .multiply({ x: -50 * delta * scale, y: -150 * delta * scale, z: -50 * delta * scale }),
    )
  })
  return (
    <RigidBody linearDamping={0.75} angularDamping={0.15} friction={0.2} position={[r(20), r(20) - 25, r(20) - 10]} ref={api} colliders={false} dispose={null}>
      <BallCollider args={[scale]} />
      <CylinderCollider rotation={[Math.PI / 2, 0, 0]} position={[0, 0, 1.2 * scale]} args={[0.15 * scale, 0.275 * scale]} />
      <mesh castShadow receiveShadow scale={scale} geometry={sphereGeometry} material={baubleMaterial} />
      <mesh castShadow scale={2.5 * scale} position={[0, 0, -1.8 * scale]} geometry={nodes.Mesh_1.geometry} material={capMaterial} />
    </RigidBody>
  )
}

function Pointer({ vec = new THREE.Vector3() }) {
  const ref = useRef()
  useFrame(({ mouse, viewport }) => {
    vec.lerp({ x: (mouse.x * viewport.width) / 2, y: (mouse.y * viewport.height) / 2, z: 0 }, 0.2)
    ref.current?.setNextKinematicTranslation(vec)
  })
  return (
    <RigidBody position={[100, 100, 100]} type="kinematicPosition" colliders={false} ref={ref}>
      <BallCollider args={[2]} />
    </RigidBody>
  )
}

export const App = () => (
  <Canvas
    shadows
    gl={{ alpha: true, stencil: false, depth: false, antialias: false }}
    camera={{ position: [0, 0, 20], fov: 32.5, near: 1, far: 100 }}
    onCreated={(state) => (state.gl.toneMappingExposure = 1.5)}>
    <ambientLight intensity={1} />
    <spotLight position={[20, 20, 25]} penumbra={1} angle={0.2} color="white" castShadow shadow-mapSize={[512, 512]} />
    <directionalLight position={[0, 5, -4]} intensity={4} />
    <directionalLight position={[0, -15, -0]} intensity={4} color="red" />
    <Physics gravity={[0, 0, 0]}>
      <Pointer />
      {baubles.map((props, i) => <Bauble key={i} {...props} />) /* prettier-ignore */}
    </Physics>
    <Environment files="/adamsbridge.hdr" />
    <EffectComposer disableNormalPass>
      <N8AO color="red" aoRadius={2} intensity={1.15} />
    </EffectComposer>
  </Canvas>
)

export function Underlay() {
  return (
    <div
      style={{
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        padding: 40,
        display: "inline-flex",
        flexDirection: "column",
        alignItems: "flex-start",
        justifyContent: "flex-start",
        pointerEvents: "none",
      }}>
      <div style={{ width: "100%", padding: 0, display: "inline-flex", flexDirection: "row", alignItems: "center", justifyContent: "center" }}>
        <p
          style={{
            fontFamily: "'Antonio', sans-serif",
            flex: "1 1 0%",
            height: 30,
            fontSize: 30,
            fontWeight: "700",
            lineHeight: "30px",
            color: "black",
            letterSpacing: -2,
          }}>
          POIMANDRES
        </p>
        <div style={{ flex: "1 1 0%", display: "flex", gap: "2em" }}></div>
        <p style={{ flex: "1 1 0%", height: 30, fontSize: 30, lineHeight: "30px", textAlign: "right", color: "black" }}>⎑</p>
      </div>
      <div style={{ height: 60 }} />
      <div style={{ width: "100%", padding: 0, display: "inline-flex", flexDirection: "row", alignItems: "flex-start", justifyContent: "center" }}>
        <p style={{ flex: "1 1 0%", height: "100%", fontSize: 12, lineHeight: "1.5em", color: "black" }}>
          <b>Stones, Metals and Gems</b>
          <br />
          A Universal Deity
          <br />
          <b>—</b>
        </p>
        <div style={{ width: 10 }} />
        <p
          style={{
            transform: "rotate3d(0, 0, 1, 90deg) translate3d(100%,10px,0)",
            transformOrigin: "right",
            fontSize: 12,
            fontWeight: "700",
            lineHeight: "100%",
            textAlign: "right",
            color: "black",
            whiteSpace: "nowrap",
          }}>
          DRAG POINTER &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ●
        </p>
      </div>
      <div style={{ height: 10 }} />
      <div
        className="full"
        style={{
          fontFamily: "'Antonio', sans-serif",
          width: "100%",
          flex: "1 1 0%",
          padding: 0,
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "flex-end",
          justifyContent: "center",
        }}>
        <p style={{ flex: "1 1 0%", fontSize: 250, lineHeight: "1em", color: "black", margin: 0, letterSpacing: -10 }}>X</p>
        <div style={{ width: 10 }} />
        <p style={{ flex: "1 1 0%", fontSize: 250, lineHeight: "100%", textAlign: "right", color: "black", margin: 0, letterSpacing: -10 }}>_01</p>
      </div>
      <div style={{ height: 60 }} />
      <div
        style={{
          pointerEvents: "all",
          pointer: "auto",
          width: "100%",
          padding: 0,
          display: "inline-flex",
          flexDirection: "row",
          alignItems: "flex-end",
          justifyContent: "center",
        }}>
        <p className="full" style={{ whiteSpace: "nowrap", flex: "1 1 0%", fontSize: 12, lineHeight: "1.5em", color: "black" }}>
          <b>Wonders of Antiquity</b>
          <br />
          Pythagorean Mathematics
        </p>
        <div style={{ width: 10 }} />
        <p
          className="full"
          style={{
            fontFamily: "'Antonio', sans-serif",
            flex: "1 1 0%",
            fontSize: 16,
            fontWeight: "700",
            lineHeight: "1em",
            textAlign: "center",
            color: "black",
            letterSpacing: -0.5,
            whiteSpace: "nowrap",
          }}>
          THE SUMMIT OF THE MANY
        </p>
        <div style={{ width: 10 }} />
        <p className="full" style={{ flex: "1 1 0%", fontSize: 12, lineHeight: "1em", textAlign: "right", color: "black" }}></p>
      </div>
    </div>
  )
}

export function Overlay() {
  return (
    <div style={{ position: "absolute", bottom: 40, right: 40 }}>
      <p style={{ flex: "1 1 0%", fontSize: 12, lineHeight: "1em", textAlign: "right", color: "black" }}>
        <a href="http://pmnd.rs/">pmnd.rs</a> <a href="https://github.com/pmndrs">git</a> <a href="https://codesandbox.io/s/zxpv7">csb</a>
      </p>
    </div>
  )
}

import { MathUtils } from 'three'
import { Canvas } from '@react-three/fiber'
import { useGLTF, AccumulativeShadows, RandomizedLight, OrbitControls, Environment, Lightformer } from '@react-three/drei'
import { EffectComposer, DepthOfField, N8AO, ToneMapping } from '@react-three/postprocessing'
import { Geometry, Base, Addition, Brush } from '@react-three/csg'
import { Physics, RigidBody, CuboidCollider, InstancedRigidBodies } from '@react-three/rapier'

export const App = () => (
  <Canvas flat shadows gl={{ antialias: false }} camera={{ position: [-30, 35, -15], near: 30, far: 55, fov: 12 }}>
    {/* Lighting, environment and colors */}
    <color attach="background" args={['#f0f0f0']} />
    <ambientLight intensity={0.5} />
    <directionalLight position={[-10, 10, 5]} shadow-mapSize={[256, 256]} shadow-bias={-0.0001} castShadow>
      <orthographicCamera attach="shadow-camera" args={[-10, 10, -10, 10]} />
    </directionalLight>
    <Environment resolution={32}>
      <Lightformer position={[10, 10, 10]} scale={10} intensity={4} />
      <Lightformer position={[10, 0, -10]} scale={10} color="red" intensity={6} />
      <Lightformer position={[-10, -10, -10]} scale={10} intensity={4} />
    </Environment>
    {/* Moon physics */}
    <Physics gravity={[0, -4, 0]}>
      <Scene position={[1, 0, -1.5]} />
      <Hats />
      <RigidBody position={[0, -1, 0]} type="fixed" colliders="false">
        <CuboidCollider restitution={0.1} args={[1000, 1, 1000]} />
      </RigidBody>
    </Physics>
    {/* Soft shadows, they stop rendering after 1500 frames */}
    <AccumulativeShadows temporal frames={Infinity} alphaTest={1} blend={200} limit={1500} scale={25} position={[0, -0.05, 0]}>
      <RandomizedLight amount={1} mapSize={512} radius={5} ambient={0.5} position={[-10, 10, 5]} size={10} bias={0.001} />
    </AccumulativeShadows>
    {/* Effects */}
    <EffectComposer>
      <N8AO aoRadius={0.5} intensity={1} />
      <DepthOfField target={[0, 0, -2.5]} focusRange={0.1} bokehScale={10} />
      <ToneMapping />
    </EffectComposer>
    {/* Controls */}
    <OrbitControls autoRotate autoRotateSpeed={0.1} enablePan={false} enableZoom={false} minPolarAngle={Math.PI / 4} maxPolarAngle={Math.PI / 4} />
  </Canvas>
)

function Scene(props) {
  const { nodes, materials } = useGLTF('/blender-threejs-journey-20k-transformed.glb')
  return (
    <group {...props} dispose={null}>
      <RigidBody type="fixed" colliders="trimesh">
        <mesh castShadow receiveShadow geometry={nodes.boxBase.geometry} material={materials.boxBase} />
        <mesh receiveShadow geometry={nodes.boxBack.geometry} material={materials.inside} />
        <mesh castShadow receiveShadow geometry={nodes.Text.geometry} material={materials.boxBase} />
      </RigidBody>
    </group>
  )
}

function Hats({ count = 80, rand = MathUtils.randFloatSpread }) {
  const { nodes, materials } = useGLTF('/blender-threejs-journey-20k-hat-transformed.glb')
  const instances = Array.from({ length: count }, (_, i) => ({
    key: i,
    position: [rand(2) + 1, 10 + i / 2, rand(2) - 2],
    rotation: [Math.random(), Math.random(), Math.random()]
  }))
  return (
    <InstancedRigidBodies instances={instances} colliders="hull">
      <instancedMesh receiveShadow castShadow args={[undefined, undefined, count]} dispose={null}>
        {/* Merging the hat into one clump bc instances need a single geometry to function */}
        <Geometry useGroups>
          <Base geometry={nodes.Plane006.geometry} material={materials.Material} />
          <Addition geometry={nodes.Plane006_1.geometry} material={materials.boxCap} />
        </Geometry>
      </instancedMesh>
    </InstancedRigidBodies>
  )
}


import * as THREE from 'three'
import React, { Suspense, useEffect, useState } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { Reflector, Text, useTexture, useGLTF } from '@react-three/drei'

export default function App() {
  return (
    <Canvas concurrent gl={{ alpha: false }} pixelRatio={[1, 1.5]} camera={{ position: [0, 3, 100], fov: 15 }}>
      <color attach="background" args={['black']} />
      <fog attach="fog" args={['black', 15, 20]} />
      <Suspense fallback={null}>
        <group position={[0, -1, 0]}>
          <Carla rotation={[0, Math.PI - 0.4, 0]} position={[-1.2, 0, 0.6]} scale={[0.26, 0.26, 0.26]} />
          <VideoText position={[0, 1.3, -2]} />
          <Ground />
        </group>
        <ambientLight intensity={0.5} />
        <spotLight position={[0, 10, 0]} intensity={0.3} />
        <directionalLight position={[-50, 0, -40]} intensity={0.7} />
        <Intro />
      </Suspense>
    </Canvas>
  )
}

function Carla(props) {
  const { scene } = useGLTF('/carla-draco.glb')
  return <primitive object={scene} {...props} />
}

function VideoText(props) {
  const [video] = useState(() => Object.assign(document.createElement('video'), { src: '/drei.mp4', crossOrigin: 'Anonymous', loop: true, muted: true }))
  useEffect(() => void video.play(), [video])
  return (
    <Text font="/Inter-Bold.woff" fontSize={3} letterSpacing={-0.06} {...props}>
      drei
      <meshBasicMaterial toneMapped={false}>
        <videoTexture attach="map" args={[video]} encoding={THREE.sRGBEncoding} />
      </meshBasicMaterial>
    </Text>
  )
}

function Ground() {
  const [floor, normal] = useTexture(['/SurfaceImperfections003_1K_var1.jpg', '/SurfaceImperfections003_1K_Normal.jpg'])
  return (
    <Reflector blur={[400, 100]} resolution={512} args={[10, 10]} mirror={0.5} mixBlur={6} mixStrength={1.5} rotation={[-Math.PI / 2, 0, Math.PI / 2]}>
      {(Material, props) => <Material color="#a0a0a0" metalness={0.4} roughnessMap={floor} normalMap={normal} normalScale={[2, 2]} {...props} />}
    </Reflector>
  )
}

function Intro() {
  const [vec] = useState(() => new THREE.Vector3())
  return useFrame((state) => {
    state.camera.position.lerp(vec.set(state.mouse.x * 5, 3 + state.mouse.y * 2, 14), 0.05)
    state.camera.lookAt(0, 0, 0)
  })
}

import * as THREE from 'three'
import React, { Suspense, useEffect, useRef, useState, useMemo } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations, Reflector, useTexture } from '@react-three/drei'
import useStore from './store'

const HPI = Math.PI / 2
const vec = new THREE.Vector3()
const obj = new THREE.Object3D()
const red = new THREE.Color('#900909')

export default function App(props) {
  return (
    <Canvas dpr={[1, 2]} camera={{ position: [-20, 20, 20], fov: 25 }}>
      <color attach="background" args={['#d0d0d0']} />
      <fog attach="fog" args={['#d0d0d0', 5, 10]} />
      <Suspense fallback={null}>
        <ambientLight intensity={2} />
        <directionalLight position={[10, 10, 0]} intensity={1.5} />
        <directionalLight position={[-10, 10, 5]} intensity={1} />
        <directionalLight position={[-10, 20, 0]} intensity={1.5} />
        <directionalLight position={[0, -10, 0]} intensity={0.25} />
        <group position-y={-0.25}>
          <Graph position={[-0.7, -0.2, -1]} />
          <DancingDot />
          <Bust />
          <Explosion position={[0, 0.65, 0]} beat={0} />
          <Explosion position={[0.15, 0.25, 0]} beat={1} />
          <Ground />
        </group>
        <Intro />
      </Suspense>
    </Canvas>
  )
}

function Bust() {
  const ref = useRef()
  const time = useRef(0)
  const { scene, animations, materials } = useGLTF('/bust.glb')
  const { actions, mixer } = useAnimations(animations, ref)
  const { drums } = useStore((state) => state.audio)
  const track = useStore((state) => state.track)
  // Play all actions (the fragments flying off)
  useEffect(() => Object.keys(actions).forEach((key) => actions[key].play()), [])
  // Control the exploding statue and the inner materials color
  useFrame((_) => {
    mixer.timeScale = track.synthonly ? 0.125 : 1
    if (!track.synthonly) mixer.setTime((time.current = THREE.MathUtils.lerp(time.current, track.kicks * 1.25, track.kicks === 0 ? 0.25 : 0.15)))
    materials.inner.color.copy(red).multiplyScalar((drums.avg * drums.gain) / 30)
  })
  return <primitive scale={[0.2, 0.2, 0.2]} position={[0, -0.23, 0]} rotation={[0, -2.4, 0]} ref={ref} object={scene} />
}

function Explosion({ beat, ...props }) {
  const [state] = useState({ size: 0, signal: 0 })
  const sceneRef = useRef()
  const instance = useRef()
  const sphere = useRef()
  // The GLTF only contains a point-cloud and baked keyframes for the explosion
  const { scene: originalScene, animations } = useGLTF('/explosion.glb')
  const scene = useMemo(() => originalScene.clone(true), [originalScene])
  const { actions, mixer } = useAnimations(animations, sceneRef)
  const { drums, snare } = useStore((state) => state.audio)
  const track = useStore((state) => state.track)
  mixer.timeScale = 2
  // Can reset and play all actions
  const play = () =>
    Object.keys(actions).forEach((key) => {
      actions[key].setLoop(THREE.LoopOnce).stop().reset()
      actions[key].play()
    })
  // Control the sphere and the sparks
  useFrame(() => {
    if (drums.signal && track.kicks - 1 === beat && drums.gain) play((state.size = 1))
    if (snare.signal) state.size = 0
    sphere.current.scale.lerp(vec.set(state.size * drums.gain, state.size * drums.gain, state.size * drums.gain), 0.2)
    sphere.current.children[0].intensity = drums.avg * drums.gain * 10
    // This code transforms the empty GLTF nodes into a single drawcall via instancing
    sceneRef.current.children.forEach((node, i) => instance.current.setMatrixAt(i, node.matrix))
    instance.current.visible = !!drums.gain
    instance.current.instanceMatrix.needsUpdate = true
  })
  return (
    <group {...props}>
      <mesh ref={sphere}>
        <sphereGeometry args={[0.2, 32, 32]} />
        <meshBasicMaterial toneMapped={false} transparent opacity={0.95} />
        <pointLight color="red" distance={0.5} />
      </mesh>
      <group scale={[0.05, 0.05, 0.05]}>
        <primitive ref={sceneRef} object={scene} />
        <instancedMesh ref={instance} args={[null, null, originalScene.children.length]}>
          <circleGeometry args={[0.15, 0]} />
          <meshBasicMaterial toneMapped={false} />
        </instancedMesh>
      </group>
    </group>
  )
}

function Graph(props) {
  const { synth } = useStore((state) => state.audio)
  const ref = useRef()
  useFrame(() => {
    for (let i = 0; i < 64; i++) {
      obj.position.set(i * 0.04, synth.data[i] / 1000, 0)
      obj.updateMatrix()
      ref.current.setMatrixAt(i, obj.matrix)
    }
    ref.current.instanceMatrix.needsUpdate = true
  })
  return (
    <instancedMesh ref={ref} args={[null, null, 64]} {...props}>
      <planeGeometry args={[0.02, 0.05]} />
      <meshBasicMaterial toneMapped={false} transparent opacity={1} />
    </instancedMesh>
  )
}

function DancingDot() {
  const { drums, snare } = useStore((state) => state.audio)
  const dot = useRef()
  useFrame((_) =>
    dot.current.rotation.set(Math.sin(_.clock.elapsedTime * 2) / 10 + (drums.avg * drums.gain) / 100, _.clock.elapsedTime + (snare.avg * snare.gain) / 100, 0),
  )
  return (
    <group ref={dot}>
      <mesh position={[-1, 0.25, 0]}>
        <sphereGeometry args={[0.03, 32, 32]} />
        <meshBasicMaterial toneMapped={false} color="black" />
      </mesh>
    </group>
  )
}

function Ground() {
  const [floor, normal] = useTexture(['/SurfaceImperfections003_1K_var1.jpg', '/SurfaceImperfections003_1K_Normal.jpg'])
  return (
    <Reflector position={[0, -0.225, 0]} resolution={512} args={[10, 10]} mirror={0.5} mixBlur={7} mixStrength={0.8} rotation={[-HPI, 0, HPI]} blur={[400, 50]}>
      {(Material, props) => <Material color="#858585" metalness={0.5} roughnessMap={floor} normalMap={normal} normalScale={[0.1, 0.1]} {...props} />}
    </Reflector>
  )
}

function Intro() {
  const clicked = useStore((state) => state.clicked)
  const api = useStore((state) => state.api)
  useEffect(() => api.loaded(), [])
  // Zoom in camera when user has pressed start
  return useFrame((state) => {
    if (clicked) {
      state.camera.position.lerp(vec.set(-2 + state.mouse.x, 2, 4.5), 0.05)
      state.camera.lookAt(0, 0, 0)
    }
  })
}


import create from 'zustand'
import { addEffect } from '@react-three/fiber'

async function createAudio(url, { threshold, expire } = {}) {
  const res = await fetch(url)
  const buffer = await res.arrayBuffer()
  const context = new (window.AudioContext || window.webkitAudioContext)()
  const analyser = context.createAnalyser()
  analyser.fftSize = 2048
  const data = new Uint8Array(analyser.frequencyBinCount)
  const source = context.createBufferSource()
  source.buffer = await new Promise((res) => context.decodeAudioData(buffer, res))
  source.loop = true
  const gainNode = context.createGain()
  gainNode.gain.value = 1
  gainNode.connect(context.destination)
  source.connect(analyser)
  analyser.connect(gainNode)

  let time = Date.now()
  let state = {
    source,
    data,
    gain: 1,
    signal: false,
    avg: 0,
    update: () => {
      let now = Date.now()
      let value = 0
      analyser.getByteFrequencyData(data)
      for (let i = 0; i < data.length; i++) value += data[i]
      const avg = (state.avg = value / data.length)
      if (threshold && avg > threshold && now - time > expire) {
        time = Date.now()
        state.signal = true
      } else state.signal = false
    },
    setGain(level) {
      gainNode.gain.setValueAtTime((state.gain = level), context.currentTime)
    },
  }

  return state
}

const mockData = () => ({ signal: false, avg: 0, gain: 1, data: [] })

const useStore = create((set, get) => {
  const drums = createAudio('/drums.mp3', { threshold: 10, expire: 500 })
  const snare = createAudio('/snare.mp3', { threshold: 40, expire: 500 })
  const synth = createAudio('/synth.mp3')
  return {
    loaded: false,
    clicked: false,
    audio: { drums: mockData(), snare: mockData(), synth: mockData() },
    track: { synthonly: false, kicks: 0, loops: 0 },
    api: {
      async loaded() {
        set({
          loaded: true,
          audio: {
            drums: await drums,
            snare: await snare,
            synth: await synth,
          },
        })
      },
      start() {
        const audio = get().audio
        const files = Object.values(audio)
        const track = get().track
        files.forEach(({ source }) => source.start(0))
        set({ clicked: true })
        addEffect(() => {
          files.forEach(({ update }) => update())
          if (audio.drums.signal) track.kicks++
          if (audio.snare.signal) {
            if (track.loops++ > 6) {
              track.synthonly = !track.synthonly
              audio.drums.setGain(track.synthonly ? 0 : 1)
              audio.snare.setGain(track.synthonly ? 0 : 1)
              track.loops = 0
            }
            track.kicks = 0
          }
        })
      },
    },
  }
})

export default useStore



import * as THREE from "three"
import { Canvas, useFrame, useThree } from "@react-three/fiber"
import { Outlines, Environment, useTexture } from "@react-three/drei"
import { Physics, useSphere } from "@react-three/cannon"
import { EffectComposer, N8AO, SMAA, Bloom } from "@react-three/postprocessing"
import { useControls } from "leva"

const rfs = THREE.MathUtils.randFloatSpread
const sphereGeometry = new THREE.SphereGeometry(1, 32, 32)
const baubleMaterial = new THREE.MeshStandardMaterial({ color: "white", roughness: 0, envMapIntensity: 1 })

export const App = () => (
  <Canvas shadows gl={{ antialias: false }} dpr={[1, 1.5]} camera={{ position: [0, 0, 20], fov: 35, near: 1, far: 40 }}>
    <ambientLight intensity={0.5} />
    <color attach="background" args={["#dfdfdf"]} />
    <spotLight intensity={1} angle={0.2} penumbra={1} position={[30, 30, 30]} castShadow shadow-mapSize={[512, 512]} />
    <Physics gravity={[0, 2, 0]} iterations={10}>
      <Pointer />
      <Clump />
    </Physics>
    <Environment files="/adamsbridge.hdr" />
    <EffectComposer disableNormalPass multisampling={0}>
      <N8AO halfRes color="black" aoRadius={2} intensity={1} aoSamples={6} denoiseSamples={4} />
      <Bloom mipmapBlur levels={7} intensity={1} />
      <SMAA />
    </EffectComposer>
  </Canvas>
)

function Clump({ mat = new THREE.Matrix4(), vec = new THREE.Vector3(), ...props }) {
  const { outlines } = useControls({ outlines: { value: 0.0, step: 0.01, min: 0, max: 0.05 } })
  const texture = useTexture("/cross.jpg")
  const [ref, api] = useSphere(() => ({ args: [1], mass: 1, angularDamping: 0.1, linearDamping: 0.65, position: [rfs(20), rfs(20), rfs(20)] }))
  useFrame((state) => {
    for (let i = 0; i < 40; i++) {
      // Get current whereabouts of the instanced sphere
      ref.current.getMatrixAt(i, mat)
      // Normalize the position and multiply by a negative force.
      // This is enough to drive it towards the center-point.
      api.at(i).applyForce(vec.setFromMatrixPosition(mat).normalize().multiplyScalar(-40).toArray(), [0, 0, 0])
    }
  })
  return (
    <instancedMesh ref={ref} castShadow receiveShadow args={[sphereGeometry, baubleMaterial, 40]} material-map={texture}>
      <Outlines thickness={outlines} />
    </instancedMesh>
  )
}

function Pointer() {
  const viewport = useThree((state) => state.viewport)
  const [ref, api] = useSphere(() => ({ type: "Kinematic", args: [3], position: [0, 0, 0] }))
  useFrame((state) => api.position.set((state.mouse.x * viewport.width) / 2, (state.mouse.y * viewport.height) / 2, 0))
  return (
    <mesh ref={ref} scale={0.2}>
      <sphereGeometry />
      <meshBasicMaterial color={[4, 4, 4]} toneMapped={false} />
      <pointLight intensity={8} distance={10} />
    </mesh>
  )
}


import * as THREE from "three"
import * as React from "react"
import { shaderMaterial } from "@react-three/drei"
import { extend, applyProps, ReactThreeFiber } from "@react-three/fiber"
import { toCreasedNormals } from "three-stdlib"

const OutlinesMaterial = shaderMaterial(
  { color: new THREE.Color("black"), opacity: 1, thickness: 0.05 },
  `#include <common>
   #include <morphtarget_pars_vertex>
   #include <skinning_pars_vertex>
   uniform float thickness;
   void main() {
     #if defined (USE_SKINNING)
	   #include <beginnormal_vertex>
       #include <morphnormal_vertex>
       #include <skinbase_vertex>
       #include <skinnormal_vertex>
       #include <defaultnormal_vertex>
     #endif
     #include <begin_vertex>
	   #include <morphtarget_vertex>
	   #include <skinning_vertex>
     #include <project_vertex>
     vec4 transformedNormal = vec4(normal, 0.0);
     vec4 transformedPosition = vec4(transformed, 1.0);
     #ifdef USE_INSTANCING
       transformedNormal = instanceMatrix * transformedNormal;
       transformedPosition = instanceMatrix * transformedPosition;
     #endif
     vec3 newPosition = transformedPosition.xyz + transformedNormal.xyz * thickness;
     gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); 
   }`,
  `uniform vec3 color;
   uniform float opacity;
   void main(){
     gl_FragColor = vec4(color, opacity);
     #include <tonemapping_fragment>
     #include <${parseInt(THREE.REVISION.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
   }`,
)

type OutlinesProps = JSX.IntrinsicElements["group"] & {
  /** Outline color, default: black */
  color: ReactThreeFiber.Color
  /** Outline opacity, default: 1 */
  opacity: number
  /** Outline transparency, default: false */
  transparent: boolean
  /** Outline thickness, default 0.05 */
  thickness: number
  /** Geometry crease angle (0 === no crease), default: Math.PI */
  angle: number
}

export function Outlines({ color = "black", opacity = 1, transparent = false, thickness = 0.05, angle = Math.PI, ...props }: OutlinesProps) {
  const ref = React.useRef<THREE.Group>(null!)
  const [material] = React.useState(() => new OutlinesMaterial({ side: THREE.BackSide }))
  React.useMemo(() => extend({ OutlinesMaterial }), [])
  React.useLayoutEffect(() => {
    const group = ref.current
    const parent = group.parent as THREE.Mesh & THREE.SkinnedMesh & THREE.InstancedMesh
    if (parent && parent.geometry) {
      let mesh
      if (parent.skeleton) {
        mesh = new THREE.SkinnedMesh()
        mesh.material = material
        mesh.bind(parent.skeleton, parent.bindMatrix)
        group.add(mesh)
      } else if (parent.isInstancedMesh) {
        mesh = new THREE.InstancedMesh(parent.geometry, material, parent.count)
        mesh.instanceMatrix = parent.instanceMatrix
        group.add(mesh)
      } else {
        mesh = new THREE.Mesh()
        mesh.material = material
        group.add(mesh)
      }
      mesh.geometry = angle ? toCreasedNormals(parent.geometry, angle) : parent.geometry
      return () => {
        if (angle) mesh.geometry.dispose()
        group.remove(mesh)
      }
    }
  }, [angle, ref.current?.parent?.geometry])

  React.useLayoutEffect(() => {
    const group = ref.current
    console.log(group.children.length)
    const mesh = group.children[0] as THREE.Mesh<THREE.BufferGeometry, THREE.Material>
    if (mesh) {
      applyProps(mesh.material as any, { transparent, thickness, color, opacity })
    }
  }, [angle, transparent, thickness, color, opacity])

  return <group ref={ref} {...props} />
}


import * as THREE from 'three'
import { useState, useRef } from 'react'
import { Canvas, extend, useFrame } from '@react-three/fiber'
import { useGLTF, AccumulativeShadows, RandomizedLight, Html, Text, Effects, Environment, Center, MeshTransmissionMaterial } from '@react-three/drei'
import { WaterPass } from 'three-stdlib'
import { ControlledInput } from './ControlledInput'

extend({ WaterPass })

export default function App() {
  return (
    // eventPrefix="client" to get client instead of offset coordinates
    // offset would reset xy to 0 when hovering the html overlay
    <Canvas eventPrefix="client" shadows camera={{ position: [1, 0.5, 10] }}>
      <color attach="background" args={['#f0f0f']} />
      <ambientLight intensity={1} />
      <spotLight position={[10, 10, 10]} angle={0.5} penumbra={1} castShadow />
      <pointLight position={[-10, 0, -10]} intensity={2} />
      <Input scale={2} position={[0.4, 0.25, -1]} />
      <group position={[0, -1, -2]}>
        <Center top rotation={[0, -Math.PI / 1.5, 0]} position={[0, 0, 3]}>
          <Model scale={0.8} />
        </Center>
        <Sphere scale={0.25} position={[-3, 0, 2]} />
        <Sphere scale={0.25} position={[-4, 0, -2]} />
        <Sphere scale={0.65} position={[3.5, 0, -2]} />
        <Text position={[0, 4, -10]} font="/Inter-Regular.woff" fontSize={6}>
          login
          <meshStandardMaterial color="#aaa" toneMapped={false} />
        </Text>
        <AccumulativeShadows temporal frames={100} alphaTest={0.8} opacity={0.75} scale={12}>
          <RandomizedLight amount={8} radius={4} ambient={0.5} intensity={1} position={[2.5, 5, -10]} />
        </AccumulativeShadows>
      </group>
      <Environment preset="city" />
      <Postpro />
      <Rig />
    </Canvas>
  )
}

function Postpro() {
  const ref = useRef()
  useFrame((state) => (ref.current.time = state.clock.elapsedTime * 3))
  return (
    <Effects>
      <waterPass ref={ref} factor={0.5} />
    </Effects>
  )
}

function Rig({ vec = new THREE.Vector3() }) {
  useFrame((state) => {
    state.camera.position.lerp(vec.set(1 + state.pointer.x, 0.5, 3), 0.01)
    state.camera.lookAt(0, 0, 0)
  })
}

function Sphere(props) {
  return (
    <Center top {...props}>
      <mesh castShadow receiveShadow>
        <sphereGeometry args={[1, 64, 64]} />
        <meshStandardMaterial />
      </mesh>
    </Center>
  )
}

function Model(props) {
  const { nodes } = useGLTF('https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/models/bunny/model.gltf')
  return (
    <mesh castShadow receiveShadow geometry={nodes.bunny.geometry} {...props}>
      <MeshTransmissionMaterial backside thickness={0.2} anisotropicBlur={0.1} chromaticAberration={0.1} clearcoat={1} />
    </mesh>
  )
}

function Input(props) {
  const [text, set] = useState('hello world ...')
  return (
    <group {...props}>
      <Text position={[-1.2, -0.022, 0]} anchorX="0px" font="/Inter-Regular.woff" fontSize={0.335} letterSpacing={-0.0}>
        {text}
        <meshStandardMaterial color="black" />
      </Text>
      <mesh position={[0, -0.022, 0]} scale={[2.5, 0.48, 1]}>
        <planeGeometry />
        <meshBasicMaterial transparent opacity={0.3} depthWrite={false} />
      </mesh>
      <Html transform>
        <ControlledInput type={text} onChange={(e) => set(e.target.value)} value={text} />
      </Html>
    </group>
  )
}


import { useRef, useState, useEffect } from 'react'

export const ControlledInput = (props) => {
  const { value, onChange, ...rest } = props
  const [cursor, setCursor] = useState(null)
  const ref = useRef(null)
  useEffect(() => {
    const input = ref.current
    if (input) input.setSelectionRange(cursor, cursor)
  }, [ref, cursor, value])
  const handleChange = (e) => {
    setCursor(e.target.selectionStart)
    onChange && onChange(e)
  }
  return <input ref={ref} value={value} onChange={handleChange} {...rest} />
}





import { useRef } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { Text3D, Center, Preload, Lightformer, Environment, CameraControls, RenderTexture, ContactShadows, MeshTransmissionMaterial } from '@react-three/drei'
import { Physics, RigidBody, CuboidCollider } from '@react-three/rapier'
import Turtle from './sandboxes/Turtle'
import Basic from './sandboxes/Basic'
import PingPong from './sandboxes/PingPong'
import Shoe from './sandboxes/Shoe'
import Stencil from './sandboxes/Stencil'
import Rocket from './sandboxes/Rocket'

export default function App() {
  return (
    <Canvas dpr={[1.5, 2]} camera={{ position: [-20, 40, 30], fov: 45, near: 1, far: 300 }}>
      {/** The physics world */}
      <Physics gravity={[0, -60, 0]}>
        <Letter char="P" position={[1, 50, -1]} rotation={[0, 0, 0]}>
          {/** The sandboxes dropped into here have no idea what's going to happen.
               For all intents and purposes they're just self-contained components.  */}
          <Turtle />
        </Letter>
        <Letter char="M" position={[2, 60, -2]} rotation={[4, 5, 6]}>
          <Shoe scale={5} />
        </Letter>
        <Letter char="N" position={[3, 70, 2]} rotation={[7, 8, 9]}>
          <Rocket position={[-1, -1, 0]} scale={0.6} />
        </Letter>
        <Letter char="D" position={[-1, 80, 3]} rotation={[10, 11, 12]}>
          <Basic scale={3} />
        </Letter>
        <Letter char="R" position={[-2, 90, 2]} rotation={[13, 14, 15]}>
          <PingPong />
        </Letter>
        <Letter char="S" position={[-3, 100, -3]} rotation={[16, 17, 18]} stencilBuffer>
          <Stencil scale={2} />
        </Letter>
        {/** Invisible walls */}
        <CuboidCollider position={[0, -6, 0]} type="fixed" args={[100, 1, 100]} />
        <CuboidCollider position={[0, 0, -30]} type="fixed" args={[30, 100, 1]} />
        <CuboidCollider position={[0, 0, 10]} type="fixed" args={[30, 100, 1]} />
        <CuboidCollider position={[-30, 0, 0]} type="fixed" args={[1, 100, 30]} />
        <CuboidCollider position={[30, 0, 0]} type="fixed" args={[1, 100, 30]} />
      </Physics>
      {/** Environment (for reflections) */}
      <Environment files="https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/dancing_hall_1k.hdr" resolution={1024}>
        {/** On top of the HDRI we add some rectangular and circular shapes for nicer reflections */}
        <group rotation={[-Math.PI / 3, 0, 0]}>
          <Lightformer intensity={4} rotation-x={Math.PI / 2} position={[0, 5, -9]} scale={[10, 10, 1]} />
          {[2, 0, 2, 0, 2, 0, 2, 0].map((x, i) => (
            <Lightformer key={i} form="circle" intensity={4} rotation={[Math.PI / 2, 0, 0]} position={[x, 4, i * 4]} scale={[4, 1, 1]} />
          ))}
          <Lightformer intensity={2} rotation-y={Math.PI / 2} position={[-5, 1, -1]} scale={[50, 2, 1]} />
          <Lightformer intensity={2} rotation-y={-Math.PI / 2} position={[10, 1, 0]} scale={[50, 2, 1]} />
        </group>
      </Environment>
      {/** Contact shadows for naive soft shadows */}
      <ContactShadows smooth={false} scale={100} position={[0, -5.05, 0]} blur={0.5} opacity={0.75} />
      {/** Yomotsu/camera-controls, a better replacement for OrbitControls */}
      <CameraControls makeDefault dollyToCursor minPolarAngle={0} maxPolarAngle={Math.PI / 2} />
      {/** Makes sure everything is processed and GPU uploaded before Threejs "sees" it */}
      <Preload all />
    </Canvas>
  )
}

function Letter({ char, children, stencilBuffer = false, ...props }) {
  const main = useRef()
  const contents = useRef()
  const events = useThree((state) => state.events)
  const controls = useThree((state) => state.controls)
  // The letters contents are moved to its whereabouts in world coordinates
  useFrame(() => contents.current.matrix.copy(main.current.matrixWorld))
  return (
    /** A physics rigid body */
    <RigidBody restitution={0.1} colliders="cuboid" {...props}>
      {/** Center each letter */}
      <Center ref={main}>
        <Text3D
          bevelEnabled
          onDoubleClick={(e) => (e.stopPropagation(), controls.fitToBox(main.current, true))}
          font="/bold.blob"
          smooth={1}
          scale={0.125}
          size={80}
          height={4}
          curveSegments={10}
          bevelThickness={10}
          bevelSize={2}
          bevelOffset={0}
          bevelSegments={5}>
          {char}
          <MeshTransmissionMaterial clearcoat={1} samples={3} thickness={40} chromaticAberration={0.25} anisotropy={0.4}>
            {/** Render a portalled scene into the "buffer" attribute of transmission material, which is a texture.
                 Since we're moving the contents with the letter shape in world space we take the standard event compute. */}
            <RenderTexture attach="buffer" stencilBuffer={stencilBuffer} width={512} height={512} compute={events.compute}>
              {/** Everything in here is self-contained, behaves like a regular canvas, but we're *in* the texture */}
              <color attach="background" args={['#4899c9']} />
              <group ref={contents} matrixAutoUpdate={false}>
                {/** Drop the children in here, this is where the sandboxes land. */}
                {children}
              </group>
              <Preload all />
            </RenderTexture>
          </MeshTransmissionMaterial>
        </Text3D>
      </Center>
    </RigidBody>
  )
}



@import url('https://rsms.me/inter/inter.css');

* {
  box-sizing: border-box;
}

html,
body,
#root {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  overscroll-behavior: none;
  background: #4899c9;
  font-family: 'Inter';
}

a {
  color: black;
}

a {
  pointer-events: all;
  color: black;
  text-decoration: none;
}

svg {
  fill: black;
}


import { useRef, useState } from 'react'
import { useFrame } from '@react-three/fiber'

export default function App(props) {
  return (
    <group {...props}>
      <ambientLight intensity={0.3} onPointerOver={() => null} />
      <pointLight position={[10, 10, 5]} />
      <pointLight position={[-10, -10, -5]} />
      <Box position={[-0.9, 0, 0]} />
      <Box position={[0.9, 0, 0]} />
    </group>
  )
}

function Box(props) {
  const ref = useRef()
  const [hovered, hover] = useState(false)
  const [clicked, click] = useState(false)
  useFrame((state, delta) => (ref.current.rotation.x += delta))
  return (
    <mesh
      {...props}
      ref={ref}
      scale={clicked ? 1.5 : 1}
      onClick={(event) => click(!clicked)}
      onPointerOver={(event) => hover(true)}
      onPointerOut={(event) => hover(false)}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color={hovered ? 'hotpink' : 'orange'} />
    </mesh>
  )
}

import * as THREE from 'three'
import { useRef } from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { CuboidCollider, Physics, RigidBody } from '@react-three/rapier'

const euler = new THREE.Euler()
const quaternion = new THREE.Quaternion()
const RESTITUTION = 2.2

export default function App(props) {
  return (
    <group {...props}>
      <ambientLight intensity={0.3} onPointerOver={() => null} />
      <pointLight position={[10, 10, 5]} />
      <pointLight position={[-10, -10, -5]} />
      <Physics gravity={[0, -30, 0]}>
        <Ball />
        <Paddle />
        <Enemy color="orange" position={[2.75, 1, 0]} />
        <Enemy color="skyblue" position={[-2.75, 3, 0]} />
      </Physics>
    </group>
  )
}

function Ball({ args = [0.75, 32, 32] }) {
  const { viewport } = useThree()
  const ref = useRef()
  return (
    <>
      <RigidBody ref={ref} colliders="ball" mass={1}>
        <mesh>
          <sphereGeometry args={args} />
          <meshStandardMaterial />
        </mesh>
      </RigidBody>
      {/* Invisible cuboid, if hit it respawns the ball */}
      <RigidBody
        colliders={false}
        position={[0, -viewport.height, 0]}
        restitution={RESTITUTION}
        type="fixed"
        onCollisionEnter={() => {
          ref.current.setTranslation({ x: 0, y: 0, z: 0 })
          ref.current.setLinvel({ x: 0, y: 10, z: 0 })
        }}>
        <CuboidCollider args={[100, 2, 100]} />
      </RigidBody>
    </>
  )
}

function Paddle({ args = [4, 1, 1] }) {
  const ref = useRef()
  useFrame((state) => {
    ref.current.setTranslation({ x: (state.mouse.x * state.viewport.width) / 2, y: -3.5, z: 0 })
    ref.current.setRotation(quaternion.setFromEuler(euler.set(0, 0, (state.mouse.x * Math.PI) / 5)))
  })
  return (
    <RigidBody ref={ref} colliders="cuboid" type="fixed" restitution={RESTITUTION}>
      <mesh>
        <boxGeometry args={args} />
        <meshStandardMaterial color="hotpink" />
      </mesh>
    </RigidBody>
  )
}

function Enemy({ args = [2.5, 1, 1], position, color }) {
  const ref = useRef()
  return (
    <RigidBody ref={ref} colliders="cuboid" type="fixed" position={position} restitution={RESTITUTION}>
      <mesh>
        <boxGeometry args={args} />
        <meshStandardMaterial color={color} />
      </mesh>
    </RigidBody>
  )
}


import { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'

export default function App(props) {
  const ref = useRef()
  useFrame((state, delta) => (ref.current.rotation.y += delta / 2))
  return (
    <group ref={ref} {...props}>
      <ambientLight intensity={0.75} />
      <pointLight intensity={1} position={[-10, -25, -10]} />
      <spotLight intensity={2.25} angle={0.2} penumbra={1} position={[-25, 20, -15]} />
      <Model url="/rocket-transformed.glb" />
    </group>
  )
}

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: overlaps (https://sketchfab.com/overlaps)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/models/91964c1ce1a34c3985b6257441efa500
title: Space exploration [WLP series #8]
*/
function Model({ url }) {
  const { nodes } = useGLTF(url)
  return (
    <group rotation={[-Math.PI / 2, 0, 0]} position={[0, -7, 0]} scale={7}>
      <group rotation={[Math.PI / 13.5, -Math.PI / 5.8, Math.PI / 5.6]}>
        <mesh receiveShadow castShadow geometry={nodes.planet002.geometry} material={nodes.planet002.material} />
        <mesh geometry={nodes.planet003.geometry} material={nodes.planet003.material} />
      </group>
    </group>
  )
}

import { useRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { useGLTF, PivotControls, Environment } from '@react-three/drei'

export default function App(props) {
  return (
    <group {...props}>
      <ambientLight intensity={0.2} />
      <spotLight intensity={0.5} angle={0.1} penumbra={1} position={[10, 15, 10]} />
      <PivotControls depthTest={false} anchor={[0, 0, 0]}>
        <Shoe />
      </PivotControls>
      <Environment preset="city" />
    </group>
  )
}

function Shoe() {
  const ref = useRef()
  const { nodes, materials } = useGLTF('shoe-draco.glb')
  useFrame((state) => {
    const t = state.clock.getElapsedTime() * 2
    ref.current.rotation.set(Math.cos(t / 4) / 8, Math.sin(t / 4) / 8, -0.2 - (1 + Math.sin(t / 1.5)) / 20)
    ref.current.position.y = (1 + Math.sin(t / 4)) / 10
  })
  return (
    <group ref={ref}>
      <mesh receiveShadow castShadow geometry={nodes.shoe.geometry} material={materials.laces} material-color="white" />
      <mesh receiveShadow castShadow geometry={nodes.shoe_1.geometry} material={materials.mesh} material-color="skyblue" />
      <mesh receiveShadow castShadow geometry={nodes.shoe_2.geometry} material={materials.caps} material-color="skyblue" />
      <mesh receiveShadow castShadow geometry={nodes.shoe_3.geometry} material={materials.inner} material-color="orange" />
      <mesh receiveShadow castShadow geometry={nodes.shoe_4.geometry} material={materials.sole} material-color="white" />
      <mesh receiveShadow castShadow geometry={nodes.shoe_5.geometry} material={materials.stripes} material-color="lightblue" />
      <mesh receiveShadow castShadow geometry={nodes.shoe_6.geometry} material={materials.band} material-color="lightblue" />
      <mesh receiveShadow castShadow geometry={nodes.shoe_7.geometry} material={materials.patch} material-color="orange" />
    </group>
  )
}

import { Suspense } from 'react'
import { Mask, useMask, useGLTF, PivotControls, RoundedBox, Float } from '@react-three/drei'

export default function App(props) {
  return (
    <group {...props}>
      <directionalLight position={[1, 2, 1.5]} intensity={0.5} castShadow />
      <hemisphereLight intensity={1.5} groundColor="red" />
      <Suspense fallback={null}>
        <PivotControls scale={1.5} rotation={[0, 0, Math.PI]} offset={[0, 0, 1]} activeAxes={[true, true, false]} disableRotations depthTest={false}>
          <Frame position={[0, 0, 1]} />
          <Mask id={1} position={[0, 0, 0.95]}>
            <circleGeometry args={[1.5, 64]} />
          </Mask>
        </PivotControls>
        <Float floatIntensity={4} rotationIntensity={0} speed={4}>
          <Atom invert={false} scale={1.5} />
        </Float>
        <Box color="#EAC435" args={[1, 5, 1]} rotation-y={Math.PI / 4} position={[0, 0, -2]} />
        <Box color="#03CEA4" args={[2, 2, 2]} position={[-2, 0, -2]} />
        <Box color="#FB4D3D" args={[2, 2, 2]} position={[2, 0, -2]} />
      </Suspense>
    </group>
  )
}

function Box({ args = [1, 4, 1], radius = 0.05, smoothness = 4, color = 'black', ...boxProps }) {
  return (
    <RoundedBox args={args} radius={radius} smoothness={smoothness} {...boxProps}>
      <meshPhongMaterial color={color} />
    </RoundedBox>
  )
}

function Frame(props) {
  return (
    <mesh {...props}>
      <ringGeometry args={[1.35, 1.5, 64]} />
      <meshPhongMaterial color="black" />
    </mesh>
  )
}

function Atom({ invert, ...props }) {
  const stencil = useMask(1, invert)
  const { nodes } = useGLTF('/react-transformed.glb')
  return (
    <mesh castShadow receiveShadow geometry={nodes.atom.geometry} {...props} dispose={null}>
      <meshPhongMaterial color="#33BBFF" {...stencil} />
    </mesh>
  )
}






import { useEffect } from 'react'
import { useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations, Float, Instance, Instances } from '@react-three/drei'

const spheres = [
  [1, 'orange', 0.05, [-4, -1, -1]],
  [0.75, 'hotpink', 0.1, [-4, 2, -2]],
  [1.25, 'aquamarine', 0.2, [4, -3, 2]],
  [1.5, 'lightblue', 0.3, [-4, -2, -3]],
  [2, 'pink', 0.3, [-4, 2, -4]],
  [2, 'skyblue', 0.3, [-4, 2, -4]],
  [1.5, 'orange', 0.05, [-4, -1, -1]],
  [2, 'hotpink', 0.1, [-4, 2, -2]],
  [1.5, 'aquamarine', 0.2, [4, -3, 2]],
  [1.25, 'lightblue', 0.3, [-4, -2, -3]],
  [1, 'pink', 0.3, [-4, 2, -4]],
  [1, 'skyblue', 0.3, [-4, 2, -4]]
]

export default function App() {
  return (
    <Instances renderOrder={-1000}>
      <ambientLight intensity={0.3} onPointerOver={() => null} />
      <pointLight position={[10, 10, 5]} />
      <pointLight position={[-10, -10, -5]} />
      <sphereGeometry args={[1, 64, 64]} />
      <meshBasicMaterial depthTest={false} />
      {spheres.map(([scale, color, speed, position], index) => (
        <Sphere key={index} scale={scale} color={color} speed={speed} position={position} />
      ))}
      <Float rotationIntensity={2} floatIntensity={10} speed={2}>
        <Turtle position={[0, 0, -2]} rotation={[0, Math.PI, 0]} scale={26} />
      </Float>
    </Instances>
  )
}

function Sphere({ position, scale = 1, speed = 0.1, color = 'white' }) {
  return (
    <Float rotationIntensity={40} floatIntensity={20} speed={speed}>
      <Instance position={position} scale={scale} color={color} />
    </Float>
  )
}

/*
Author: DigitalLife3D (https://sketchfab.com/DigitalLife3D)
License: CC-BY-NC-4.0 (http://creativecommons.org/licenses/by-nc/4.0/)
Source: https://sketchfab.com/3d-models/model-52a-kemps-ridley-sea-turtle-no-id-7aba937dfbce480fb3aca47be3a9740b
Title: Model 52A - Kemps Ridley Sea Turtle (no ID)
*/
function Turtle(props) {
  const { scene, animations } = useGLTF('/model_52a_-_kemps_ridley_sea_turtle_no_id-transformed.glb')
  const { actions, mixer } = useAnimations(animations, scene)
  useEffect(() => {
    mixer.timeScale = 0.5
    actions['Swim Cycle'].play()
  }, [])
  useFrame((state) => (scene.rotation.z = Math.sin(state.clock.elapsedTime / 4) / 2))
  return <primitive object={scene} {...props} />
}

import { RGBELoader } from 'three-stdlib'
import { Canvas, useLoader } from '@react-three/fiber'
import {
  Center,
  Text3D,
  Instance,
  Instances,
  Environment,
  Lightformer,
  OrbitControls,
  RandomizedLight,
  AccumulativeShadows,
  MeshTransmissionMaterial
} from '@react-three/drei'
import { useControls, button } from 'leva'
import { EffectComposer, HueSaturation, BrightnessContrast } from '@react-three/postprocessing'

export function App() {
  const { autoRotate, text, shadow, ...config } = useControls({
    text: 'Inter',
    backside: true,
    backsideThickness: { value: 0.15, min: 0, max: 2 },
    samples: { value: 16, min: 1, max: 32, step: 1 },
    resolution: { value: 1024, min: 64, max: 2048, step: 64 },
    transmission: { value: 1, min: 0, max: 1 },
    clearcoat: { value: 1, min: 0.1, max: 1 },
    clearcoatRoughness: { value: 0.0, min: 0, max: 1 },
    thickness: { value: 0.3, min: 0, max: 5 },
    chromaticAberration: { value: 0.15, min: -5, max: 5 },
    anisotropy: { value: 0.25, min: 0, max: 1, step: 0.01 },
    roughness: { value: 0, min: 0, max: 1, step: 0.01 },
    distortion: { value: 0.5, min: 0, max: 4, step: 0.01 },
    distortionScale: { value: 0.1, min: 0.01, max: 1, step: 0.01 },
    temporalDistortion: { value: 0, min: 0, max: 1, step: 0.01 },
    ior: { value: 1.25, min: 0, max: 2, step: 0.01 },
    color: 'white',
    shadow: '#94cbff',
    autoRotate: false,
    screenshot: button(() => {
      // Save the canvas as a *.png
      const link = document.createElement('a')
      link.setAttribute('download', 'canvas.png')
      link.setAttribute('href', document.querySelector('canvas').toDataURL('image/png').replace('image/png', 'image/octet-stream'))
      link.click()
    })
  })
  return (
    <Canvas shadows orthographic camera={{ position: [10, 20, 20], zoom: 80 }} gl={{ preserveDrawingBuffer: true }}>
      <color attach="background" args={['#f2f2f5']} />
      {/** The text and the grid */}
      <Text config={config} rotation={[-Math.PI / 2, 0, 0]} position={[0, -1, 2.25]}>
        {text}
      </Text>
      {/** Controls */}
      <OrbitControls
        autoRotate={autoRotate}
        autoRotateSpeed={-0.1}
        zoomSpeed={0.25}
        minZoom={40}
        maxZoom={140}
        enablePan={false}
        dampingFactor={0.05}
        minPolarAngle={Math.PI / 3}
        maxPolarAngle={Math.PI / 3}
      />
      {/** The environment is just a bunch of shapes emitting light. This is needed for the clear-coat */}
      <Environment resolution={32}>
        <group rotation={[-Math.PI / 4, -0.3, 0]}>
          <Lightformer intensity={20} rotation-x={Math.PI / 2} position={[0, 5, -9]} scale={[10, 10, 1]} />
          <Lightformer intensity={2} rotation-y={Math.PI / 2} position={[-5, 1, -1]} scale={[10, 2, 1]} />
          <Lightformer intensity={2} rotation-y={Math.PI / 2} position={[-5, -1, -1]} scale={[10, 2, 1]} />
          <Lightformer intensity={2} rotation-y={-Math.PI / 2} position={[10, 1, 0]} scale={[20, 2, 1]} />
          <Lightformer type="ring" intensity={2} rotation-y={Math.PI / 2} position={[-0.1, -1, -5]} scale={10} />
        </group>
      </Environment>
      {/** Soft shadows */}
      <AccumulativeShadows frames={100} color={shadow} colorBlend={5} toneMapped={true} alphaTest={0.9} opacity={1} scale={30} position={[0, -1.01, 0]}>
        <RandomizedLight amount={4} radius={10} ambient={0.5} intensity={1} position={[0, 10, -10]} size={15} mapSize={1024} bias={0.0001} />
      </AccumulativeShadows>
    </Canvas>
  )
}

const Grid = ({ number = 23, lineWidth = 0.026, height = 0.5 }) => (
  // Renders a grid and crosses as instances
  <Instances position={[0, -1.02, 0]}>
    <planeGeometry args={[lineWidth, height]} />
    <meshBasicMaterial color="#999" />
    {Array.from({ length: number }, (_, y) =>
      Array.from({ length: number }, (_, x) => (
        <group key={x + ':' + y} position={[x * 2 - Math.floor(number / 2) * 2, -0.01, y * 2 - Math.floor(number / 2) * 2]}>
          <Instance rotation={[-Math.PI / 2, 0, 0]} />
          <Instance rotation={[-Math.PI / 2, 0, Math.PI / 2]} />
        </group>
      ))
    )}
    <gridHelper args={[100, 100, '#bbb', '#bbb']} position={[0, -0.01, 0]} />
  </Instances>
)

function Text({ children, config, font = '/Inter_Medium_Regular.json', ...props }) {
  const texture = useLoader(RGBELoader, 'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/aerodynamics_workshop_1k.hdr')
  return (
    <>
      <group>
        <Center scale={[0.8, 1, 1]} front top {...props}>
          <Text3D
            castShadow
            bevelEnabled
            font={font}
            scale={5}
            letterSpacing={-0.03}
            height={0.25}
            bevelSize={0.01}
            bevelSegments={10}
            curveSegments={128}
            bevelThickness={0.01}>
            {children}
            <MeshTransmissionMaterial {...config} background={texture} />
          </Text3D>
        </Center>
        <Grid />
      </group>
    </>
  )
}



import * as THREE from 'three'
import { useMemo, useRef } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { Trail, Float, Line, Sphere, Stars } from '@react-three/drei'
import { EffectComposer, Bloom } from '@react-three/postprocessing'

export default function App() {
  return (
    <Canvas camera={{ position: [0, 0, 10] }}>
      <color attach="background" args={['black']} />
      <Float speed={4} rotationIntensity={1} floatIntensity={2}>
        <Atom />
      </Float>
      <Stars saturation={0} count={400} speed={0.5} />
      <EffectComposer>
        <Bloom mipmapBlur luminanceThreshold={1} radius={0.7} />
      </EffectComposer>
    </Canvas>
  )
}

function Atom(props) {
  const points = useMemo(() => new THREE.EllipseCurve(0, 0, 3, 1.15, 0, 2 * Math.PI, false, 0).getPoints(100), [])
  return (
    <group {...props}>
      <Electron position={[0, 0, 0.5]} speed={6} />
      <Electron position={[0, 0, 0.5]} rotation={[0, 0, Math.PI / 3]} speed={6.5} />
      <Electron position={[0, 0, 0.5]} rotation={[0, 0, -Math.PI / 3]} speed={7} />
      <Sphere args={[0.35, 64, 64]}>
        <meshBasicMaterial color={[6, 0.5, 2]} toneMapped={false} />
      </Sphere>
    </group>
  )
}

function Electron({ radius = 2.75, speed = 6, ...props }) {
  const ref = useRef()
  useFrame((state) => {
    const t = state.clock.getElapsedTime() * speed
    ref.current.position.set(Math.sin(t) * radius, (Math.cos(t) * radius * Math.atan(t)) / Math.PI / 1.25, 0)
  })
  return (
    <group {...props}>
      <Trail local width={5} length={10} color={new THREE.Color(2, 1, 10)} attenuation={(t) => t * t}>
        <mesh ref={ref}>
          <sphereGeometry args={[0.25]} />
          <meshBasicMaterial color={[10, 1, 10]} toneMapped={false} />
        </mesh>
      </Trail>
    </group>
  )
}
import { useRef } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { useGLTF, Bounds, Edges } from '@react-three/drei'
// use ↓ "DebugLayerMaterial as LayerMaterial" ↓ here for integrated leva debug panels
import { LayerMaterial, Depth, Fresnel } from 'lamina'
import { useControls } from 'leva'

export const App = () => (
  <Canvas orthographic dpr={[1, 2]} camera={{ position: [0, 0, 10], zoom: 200 }}>
    <group rotation={[Math.PI / 5, -Math.PI / 5, Math.PI / 2]}>
      <Bounds fit clip observe margin={1.25}>
        <Cursor scale={[0.5, 1, 0.5]} />
      </Bounds>
      <gridHelper args={[10, 40, '#101010', '#050505']} position={[-0.25, 0, 0]} rotation={[0, 0, Math.PI / 2]} />
    </group>
  </Canvas>
)

function Cursor(props) {
  const ref = useRef()
  const { nodes } = useGLTF('/cursor.glb')
  const { gradient } = useControls({ gradient: { value: 0.7, min: 0, max: 1 } })

  // Animate gradient
  useFrame((state) => {
    const sin = Math.sin(state.clock.elapsedTime / 2)
    const cos = Math.cos(state.clock.elapsedTime / 2)
    ref.current.layers[0].origin.set(cos / 2, 0, 0)
    ref.current.layers[1].origin.set(cos, sin, cos)
    ref.current.layers[2].origin.set(sin, cos, sin)
    ref.current.layers[3].origin.set(cos, sin, cos)
  })

  return (
    <mesh {...props} geometry={nodes.Cube.geometry}>
      <LayerMaterial ref={ref} toneMapped={false}>
        <Depth colorA="#ff0080" colorB="black" alpha={1} mode="normal" near={0.5 * gradient} far={0.5} origin={[0, 0, 0]} />
        <Depth colorA="blue" colorB="#f7b955" alpha={1} mode="add" near={2 * gradient} far={2} origin={[0, 1, 1]} />
        <Depth colorA="green" colorB="#f7b955" alpha={1} mode="add" near={3 * gradient} far={3} origin={[0, 1, -1]} />
        <Depth colorA="white" colorB="red" alpha={1} mode="overlay" near={1.5 * gradient} far={1.5} origin={[1, -1, -1]} />
        <Fresnel mode="add" color="white" intensity={0.5} power={1.5} bias={0.05} />
      </LayerMaterial>
      <Edges color="white" />
    </mesh>
  )
}


@import url('https://rsms.me/inter/inter.css');

* {
  box-sizing: border-box;
}

html,
body,
#root {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  font-family: inter;
  font-size: 13px;
  color: #fefefe;
  background: black;
}

@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

canvas {
  opacity: 0;
  touch-action: none;
  animation: fade-in 2s ease 0.3s forwards;
  animation-delay: 0s;
}

svg {
  fill: #fefefe;
}

a {
  color: white;
}

a {
  pointer-events: all;
  color: white;
  text-decoration: none;
}


import * as THREE from 'three'
import { useLayoutEffect } from 'react'
import { applyProps, Canvas } from '@react-three/fiber'
import { useGLTF, useBoxProjectedEnv, CubeCamera, Environment, OrbitControls, BakeShadows } from '@react-three/drei'
import { useControls } from 'leva'

export default function App() {
  return (
    <Canvas frameloop="demand" dpr={[1, 1.5]} shadows camera={{ near: 0.1, far: 40, fov: 75 }}>
      <fog attach="fog" args={['purple', 0, 130]} />
      <ambientLight intensity={0.1} />
      <group position={[0, -1, 0]}>
        <spotLight castShadow intensity={10} angle={0.1} position={[-200, 220, -100]} shadow-mapSize={[2048, 2048]} shadow-bias={-0.000001} />
        <spotLight angle={0.1} position={[-250, 120, -200]} intensity={1} castShadow shadow-mapSize={[50, 50]} shadow-bias={-0.000001} />
        <spotLight angle={0.1} position={[250, 120, 200]} intensity={1} castShadow shadow-mapSize={[50, 50]} shadow-bias={-0.000001} />
        <Court />
        <Floor />
      </group>
      <OrbitControls minPolarAngle={Math.PI / 2} maxPolarAngle={Math.PI / 2} />
      <Environment files="https://vazxmixjsiawhamofees.supabase.co/storage/v1/object/public/hdris/noon-grass/noon_grass_1k.hdr" background />
      <BakeShadows />
    </Canvas>
  )
}

function Court(props) {
  const { scene } = useGLTF('/court.glb')
  useLayoutEffect(() => {
    scene.traverse((o) => {
      if (o.isMesh) {
        applyProps(o, { castShadow: true, receiveShadow: true, 'material-envMapIntensity': 0.1 })
      }
    })
    const floor = scene.getObjectByName('GymFloor_ParquetShader_0')
    if (floor) floor.parent.remove(floor)
  }, [scene])
  return <primitive object={scene} {...props} />
}

function Floor(props) {
  const { nodes, materials } = useGLTF('/court.glb')
  const { up, scale, ...config } = useControls({
    up: { value: -0.5, min: -10, max: 10 },
    scale: { value: 27, min: 0, max: 50 },
    roughness: { value: 0.06, min: 0, max: 0.15, step: 0.001 },
    envMapIntensity: { value: 1, min: 0, max: 5 }
  })
  const projection = useBoxProjectedEnv([0, up, 0], [scale, scale, scale])
  return (
    <CubeCamera frames={1} position={[0, 0.5, 0]} rotation={[0, 0, 0]} resolution={2048} near={1} far={1000} {...props}>
      {(texture) => (
        <mesh receiveShadow position={[-13.68, -0.467, 17.52]} scale={0.02} geometry={nodes.GymFloor_ParquetShader_0.geometry} dispose={null}>
          <meshStandardMaterial
            map={materials.ParquetShader.map}
            normalMap={materials.ParquetShader.normalMap}
            normalMap-encoding={THREE.LinearEncoding}
            envMap={texture}
            metalness={0.0}
            normalScale={[0.25, -0.25]}
            color="#aaa"
            {...projection}
            {...config}
          />
        </mesh>
      )}
    </CubeCamera>
  )
}


import { Suspense, useMemo, useRef } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { useGLTF, useScroll, ScrollControls, Environment, Merged, Text, MeshReflectorMaterial } from '@react-three/drei'

function Train() {
  const ref = useRef()
  const scroll = useScroll()
  const [cabin, seat] = useGLTF(['/cabin-transformed.glb', '/seat-transformed.glb'])
  const meshes = useMemo(() => ({ Cabin: cabin.nodes.cabin_1, Seat: seat.nodes.seat }), [cabin, seat])
  useFrame(() => (ref.current.position.z = scroll.offset * 120))
  // Merged creates THREE.InstancedMeshes out of the meshes you feed it
  // All in all we end up with just 5 draw-calls for the entire scene
  return (
    <Merged castShadow receiveShadow meshes={meshes}>
      {(models) => (
        <group ref={ref}>
          <Cabin models={models} color="#252525" seatColor="sandybrown" name="1A" position={[0, 0, -6]} />
          <Cabin models={models} color="#454545" seatColor="gray" name="2B" position={[0, 0, -32]} />
          <Cabin models={models} color="#252525" seatColor="lightskyblue" name="3A" position={[0, 0, -58]} />
          <Cabin models={models} color="#454545" seatColor="gray" name="4B" position={[0, 0, -84]} />
          <Cabin models={models} color="#252525" seatColor="sandybrown" name="5B" position={[0, 0, -110]} />
        </group>
      )}
    </Merged>
  )
}

const Quarter = ({ models, color, ...props }) => (
  <group {...props}>
    <models.Seat color={color} position={[-0.35, 0, 0.7]} />
    <models.Seat color={color} position={[0.35, 0, 0.7]} />
    <models.Seat color={color} position={[-0.35, 0, -0.7]} rotation={[0, Math.PI, 0]} />
    <models.Seat color={color} position={[0.35, 0, -0.7]} rotation={[0, Math.PI, 0]} />
  </group>
)

const Row = ({ models, color, ...props }) => (
  <group {...props}>
    <Quarter models={models} color={color} position={[-1.2, -0.45, 9.75]} />
    <Quarter models={models} color={color} position={[1.2, -0.45, 9.75]} />
  </group>
)

const Cabin = ({ models, color = 'white', seatColor = 'white', name, ...props }) => (
  <group {...props}>
    <Text fontSize={4} color="#101020" position={[0, 6, 4]} rotation={[-Math.PI / 2, 0, 0]}>
      {name}
    </Text>
    <models.Cabin color={color} />
    <Row models={models} color={seatColor} />
    <Row models={models} color={seatColor} position={[0, 0, -1.9]} />
    <Row models={models} color={seatColor} position={[0, 0, -6.6]} />
    <Row models={models} color={seatColor} position={[0, 0, -8.5]} />
    <Row models={models} color={seatColor} position={[0, 0, -11]} />
    <Row models={models} color={seatColor} position={[0, 0, -12.9]} />
    <Row models={models} color={seatColor} position={[0, 0, -17.6]} />
    <Row models={models} color={seatColor} position={[0, 0, -19.5]} />
  </group>
)

export default function App() {
  return (
    <Canvas dpr={[1, 1.5]} shadows camera={{ position: [-15, 15, 18], fov: 35 }} gl={{ alpha: false }}>
      <fog attach="fog" args={['#17171b', 30, 40]} />
      <color attach="background" args={['#17171b']} />
      <ambientLight intensity={0.25} />
      <directionalLight castShadow intensity={2} position={[10, 6, 6]} shadow-mapSize={[1024, 1024]}>
        <orthographicCamera attach="shadow-camera" left={-20} right={20} top={20} bottom={-20} />
      </directionalLight>
      <Suspense fallback={null}>
        <ScrollControls pages={3}>
          <Train />
        </ScrollControls>
        <mesh position={[0, -1.5, 0]} rotation={[-Math.PI / 2, 0, 0]}>
          <planeGeometry args={[50, 50]} />
          <MeshReflectorMaterial
            blur={[400, 100]}
            resolution={1024}
            mixBlur={1}
            mixStrength={15}
            depthScale={1}
            minDepthThreshold={0.85}
            color="#151515"
            metalness={0.6}
            roughness={1}
          />
        </mesh>
        <Environment preset="dawn" />
      </Suspense>
    </Canvas>
  )
}


import * as THREE from 'three'
import { useRef, useState } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { Bvh, Instances, Instance, OrbitControls, Environment, useGLTF } from '@react-three/drei'
import { useControls } from 'leva'

import { data } from './store'

export default function App() {
  const { range } = useControls({ range: { value: 100, min: 0, max: 300, step: 10 } })
  return (
    <Canvas camera={{ position: [0, 0, 20], fov: 50 }}>
      <ambientLight intensity={0.5 * Math.PI} />
      <directionalLight intensity={0.3} position={[5, 25, 20]} />
      <Bvh firstHitOnly>
        <Shoes data={data} range={range} />
      </Bvh>
      <Environment preset="city" />
      <OrbitControls autoRotate autoRotateSpeed={1} />
    </Canvas>
  )
}

function Shoes({ data, range }) {
  const { nodes, materials } = useGLTF('/shoe.glb')
  return (
    <Instances range={range} material={materials.phong1SG} geometry={nodes.Shoe.geometry}>
      {data.map((props, i) => (
        <Shoe key={i} {...props} />
      ))}
    </Instances>
  )
}

function Shoe({ random, color = new THREE.Color(), ...props }) {
  const ref = useRef()
  const [hovered, setHover] = useState(false)
  useFrame((state) => {
    const t = state.clock.getElapsedTime() + random * 10000
    ref.current.rotation.set(Math.cos(t / 4) / 2, Math.sin(t / 4) / 2, Math.cos(t / 1.5) / 2)
    ref.current.position.y = Math.sin(t / 1.5) / 2
    ref.current.scale.x = ref.current.scale.y = ref.current.scale.z = THREE.MathUtils.lerp(ref.current.scale.z, hovered ? 1.4 : 1, 0.1)
    ref.current.color.lerp(color.set(hovered ? 'red' : 'white'), hovered ? 1 : 0.1)
  })
  return (
    <group {...props}>
      <Instance ref={ref} onPointerOver={(e) => (e.stopPropagation(), setHover(true))} onPointerOut={(e) => setHover(false)} />
    </group>
  )
}


const randomVector = (r) => [r / 2 - Math.random() * r, r / 2 - Math.random() * r, r / 2 - Math.random() * r]
const randomEuler = () => [Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI]
const data = Array.from({ length: 1000 }, (r = 10) => ({ random: Math.random(), position: randomVector(r), rotation: randomEuler() }))

export { data }


import { OrbitControls, CameraShake } from '@react-three/drei'
import { useControls } from 'leva'
import { Particles } from './Particles'

export default function App() {
  const props = useControls({
    focus: { value: 5.1, min: 3, max: 7, step: 0.01 },
    speed: { value: 100, min: 0.1, max: 100, step: 0.1 },
    aperture: { value: 1.8, min: 1, max: 5.6, step: 0.1 },
    fov: { value: 20, min: 0, max: 200 },
    curl: { value: 0.25, min: 0.01, max: 0.5, step: 0.01 }
  })
  return (
    <>
      <OrbitControls makeDefault autoRotate autoRotateSpeed={0.5} zoomSpeed={0.1} />
      <CameraShake yawFrequency={1} maxYaw={0.05} pitchFrequency={1} maxPitch={0.05} rollFrequency={0.5} maxRoll={0.5} intensity={0.2} />
      <Particles {...props} />
    </>
  )
}


import * as THREE from 'three'
import { useMemo, useState, useRef } from 'react'
import { createPortal, useFrame } from '@react-three/fiber'
import { useFBO } from '@react-three/drei'
import './shaders/simulationMaterial'
import './shaders/dofPointsMaterial'

export function Particles({ speed, fov, aperture, focus, curl, size = 512, ...props }) {
  const simRef = useRef()
  const renderRef = useRef()
  // Set up FBO
  const [scene] = useState(() => new THREE.Scene())
  const [camera] = useState(() => new THREE.OrthographicCamera(-1, 1, 1, -1, 1 / Math.pow(2, 53), 1))
  const [positions] = useState(() => new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]))
  const [uvs] = useState(() => new Float32Array([0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]))
  const target = useFBO(size, size, {
    minFilter: THREE.NearestFilter,
    magFilter: THREE.NearestFilter,
    format: THREE.RGBAFormat,
    type: THREE.FloatType
  })
  // Normalize points
  const particles = useMemo(() => {
    const length = size * size
    const particles = new Float32Array(length * 3)
    for (let i = 0; i < length; i++) {
      let i3 = i * 3
      particles[i3 + 0] = (i % size) / size
      particles[i3 + 1] = i / size / size
    }
    return particles
  }, [size])
  // Update FBO and pointcloud every frame
  useFrame((state) => {
    state.gl.setRenderTarget(target)
    state.gl.clear()
    state.gl.render(scene, camera)
    state.gl.setRenderTarget(null)
    renderRef.current.uniforms.positions.value = target.texture
    renderRef.current.uniforms.uTime.value = state.clock.elapsedTime
    renderRef.current.uniforms.uFocus.value = THREE.MathUtils.lerp(renderRef.current.uniforms.uFocus.value, focus, 0.1)
    renderRef.current.uniforms.uFov.value = THREE.MathUtils.lerp(renderRef.current.uniforms.uFov.value, fov, 0.1)
    renderRef.current.uniforms.uBlur.value = THREE.MathUtils.lerp(renderRef.current.uniforms.uBlur.value, (5.6 - aperture) * 9, 0.1)
    simRef.current.uniforms.uTime.value = state.clock.elapsedTime * speed
    simRef.current.uniforms.uCurlFreq.value = THREE.MathUtils.lerp(simRef.current.uniforms.uCurlFreq.value, curl, 0.1)
  })
  return (
    <>
      {/* Simulation goes into a FBO/Off-buffer */}
      {createPortal(
        <mesh>
          <simulationMaterial ref={simRef} />
          <bufferGeometry>
            <bufferAttribute attach="attributes-position" count={positions.length / 3} array={positions} itemSize={3} />
            <bufferAttribute attach="attributes-uv" count={uvs.length / 2} array={uvs} itemSize={2} />
          </bufferGeometry>
        </mesh>,
        scene
      )}
      {/* The result of which is forwarded into a pointcloud via data-texture */}
      <points {...props}>
        <dofPointsMaterial ref={renderRef} />
        <bufferGeometry>
          <bufferAttribute attach="attributes-position" count={particles.length / 3} array={particles} itemSize={3} />
        </bufferGeometry>
      </points>
    </>
  )
}


import { createRoot } from 'react-dom/client'
import * as THREE from 'three'
import React, { useEffect } from 'react'
import { Canvas } from '@react-three/fiber'
import { useSprings, a } from '@react-spring/three'
import './styles.css'

const length = 35
const colors = ['#A2CCB6', '#FCEEB5', '#EE786E', '#e0feff', 'lightpink', 'lightblue']
const data = Array.from({ length }, () => ({ args: [0.1 + Math.random() * 9, 0.1 + Math.random() * 9, 10] }))
const random = (i) => {
  const r = Math.random()
  return {
    position: [100 - Math.random() * 200, 100 - Math.random() * 200, i * 1.5],
    color: colors[Math.round(Math.random() * (colors.length - 1))],
    scale: [1 + r * 14, 1 + r * 14, 1],
    rotation: [0, 0, THREE.MathUtils.degToRad(Math.round(Math.random()) * 45)]
  }
}

function Content() {
  const [springs, set] = useSprings(length, (i) => ({ from: random(i), ...random(i), config: { mass: 20, tension: 150, friction: 50 } }))
  useEffect(() => void setInterval(() => set((i) => ({ ...random(i), delay: i * 40 })), 3000), [])
  return data.map((d, index) => (
    <a.mesh key={index} {...springs[index]} castShadow receiveShadow>
      <boxBufferGeometry args={d.args} />
      <a.meshStandardMaterial color={springs[index].color} roughness={0.75} metalness={0.5} />
    </a.mesh>
  ))
}

createRoot(document.getElementById('root')).render(
  <Canvas flat shadows camera={{ position: [0, 0, 100], fov: 100 }}>
    <pointLight intensity={0.5} />
    <ambientLight intensity={1.85} />
    <spotLight castShadow intensity={0.2} angle={Math.PI / 7} position={[150, 150, 250]} penumbra={1} shadow-mapSize={2048} />
    <Content />
  </Canvas>
)


import * as THREE from 'three'
import { Suspense, useRef, useState } from 'react'
import { RectAreaLightUniformsLib } from 'three/examples/jsm/lights/RectAreaLightUniformsLib'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { OrbitControls, CameraShake, Environment } from '@react-three/drei'
import Model from './Model'

RectAreaLightUniformsLib.init()

function Light() {
  const ref = useRef()
  useFrame((_) => (ref.current.rotation.x = _.clock.elapsedTime))
  return (
    <group ref={ref}>
      <rectAreaLight width={15} height={100} position={[30, 30, -10]} intensity={5} onUpdate={(self) => self.lookAt(0, 0, 0)} />
    </group>
  )
}

function Rig() {
  const [vec] = useState(() => new THREE.Vector3())
  const { camera, mouse } = useThree()
  useFrame(() => camera.position.lerp(vec.set(mouse.x * 2, 1, 60), 0.05))
  return <CameraShake maxYaw={0.01} maxPitch={0.01} maxRoll={0.01} yawFrequency={0.5} pitchFrequency={0.5} rollFrequency={0.4} />
}

export default function App() {
  return (
    <Canvas shadows dpr={[1, 2]} camera={{ position: [0, 160, 160], fov: 20 }}>
      <fog attach="fog" args={['lightpink', 60, 100]} />
      <Suspense fallback={null}>
        <ambientLight intensity={0.5} />
        <Model position={[-4.5, -4, 0]} rotation={[0, -2.8, 0]} />
        <spotLight position={[50, 50, -30]} castShadow />
        <pointLight position={[-10, -10, -10]} color="red" intensity={3} />
        <pointLight position={[0, -5, 5]} intensity={0.5} />
        <directionalLight position={[0, -5, 0]} color="red" intensity={2} />
        <Light />
        <Environment preset="warehouse" />
        <Rig />
      </Suspense>
      <OrbitControls makeDefault />
    </Canvas>
  )
}


/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF, Reflector } from '@react-three/drei'

const material = new THREE.MeshPhysicalMaterial({
  color: new THREE.Color('#bb86a1').convertSRGBToLinear(),
  roughness: 0,
  clearcoat: 1,
  clearcoatRoughness: 0,
})

export default function Model(props) {
  const group = useRef()
  const { nodes } = useGLTF('/pink-d.glb')
  return (
    <group ref={group} {...props} dispose={null}>
      <Reflector
        resolution={1024}
        receiveShadow
        mirror={0}
        mixBlur={1}
        mixStrength={0.3}
        depthScale={1}
        minDepthThreshold={0.8}
        maxDepthThreshold={1}
        position={[0, 0, 8]}
        scale={[2, 2, 1]}
        rotation={[-Math.PI / 2, 0, Math.PI]}
        args={[70, 70]}>
        {(Material, props) => <Material metalness={0.25} color="#eea6b1" roughness={1} {...props} />}
      </Reflector>
      <mesh receiveShadow castShadow material={material} geometry={nodes.Sphere.geometry} position={[-1.93, 1, -0.94]} rotation={[-Math.PI, 0.73, -Math.PI]} />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Sphere001.geometry} position={[4.49, 2.34, 3.58]} scale={[2.33, 2.33, 2.33]} />
      <mesh
        receiveShadow
        castShadow
        material={material}
        geometry={nodes.Sphere001.geometry}
        position={[-16, 5, 17]}
        rotation={[-0.26, 0.04, -0.16]}
        scale={[5, 5, 5]}
      />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Sphere002.geometry} position={[-5.28, 4.8, 5.12]} />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Sphere003.geometry} position={[-10.13, 1.3, -3.95]} rotation={[-0.15, 0.01, -0.02]} />
      <mesh
        receiveShadow
        castShadow
        material={material}
        geometry={nodes.Sphere004.geometry}
        position={[-19.36, 1.05, -2.05]}
        rotation={[0, 0, 0.64]}
        scale={[-1.33, -1.33, -1.33]}
      />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Sphere005.geometry} position={[-18.17, 0.94, -2.35]} scale={[0.87, 0.87, 0.87]} />
      <mesh
        receiveShadow
        castShadow
        material={material}
        geometry={nodes.Torus.geometry}
        position={[-0.36, 1.46, 0.73]}
        rotation={[Math.PI, 0.73, -2.64]}
        scale={[2, 2, 2]}
      />

      <mesh receiveShadow castShadow material={material} geometry={nodes.Cone.geometry} position={[2.3, 1.91, -4.41]} scale={[1.86, 1.86, 1.86]} />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Cone001.geometry} position={[-4.82, 0.47, -5.51]} rotation={[2.14, 0, -0.58]} />
      <mesh
        receiveShadow
        castShadow
        material={material}
        geometry={nodes.Cube.geometry}
        position={[-5.36, 1.94, 5.46]}
        rotation={[0, 0.42, 0]}
        scale={[1.9, 1.9, 1.9]}
      />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Cube001.geometry} position={[-1.8, 1, -10.04]} rotation={[0, -0.23, 0]} />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Cylinder.geometry} position={[-12.3, 2.41, 1.53]} />
      <mesh
        receiveShadow
        castShadow
        material={material}
        geometry={nodes.Cylinder001.geometry}
        position={[-10.47, 1.57, -8.75]}
        rotation={[Math.PI / 2, 0, -1.87]}
        scale={[1.55, 1.55, 1.55]}
      />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Cylinder002.geometry} position={[-1.15, 3.38, 14.39]} rotation={[0, Math.PI, 0]} />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Icosphere.geometry} position={[7.29, 0.6, -5.63]} scale={[0.64, 0.64, 0.64]} />
      <mesh receiveShadow castShadow material={material} geometry={nodes.Icosphere001.geometry} position={[7.26, 0.98, 12.9]} rotation={[-0.26, 0.04, -0.16]} />
    </group>
  )
}

useGLTF.preload('/pink-d.glb')

html,
body,
#root {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
}

body {
  background: #ffb6c1;
  cursor: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIxNiIgY3k9IjE2IiByPSIxMCIgZmlsbD0id2hpdGUiLz48L3N2Zz4='),
    auto;
}

#root::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: url('/view.svg');
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
  pointer-events: none;
}


import * as THREE from 'three'
import { Suspense, useEffect, useRef } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { suspend } from 'suspend-react'

export default function App(props) {
  return (
    <Canvas shadows dpr={[1, 2]} camera={{ position: [-1, 1.5, 2], fov: 25 }}>
      <spotLight position={[-4, 4, -4]} angle={0.06} penumbra={1} castShadow shadow-mapSize={[2048, 2048]} />
      <Suspense fallback={null}>
        <Track position-z={-0.25} url="/synth.mp3" />
        <Track position-z={0} url="/snare.mp3" />
        <Track position-z={0.25} url="/drums.mp3" />
        <Zoom url="/drums.mp3" />
      </Suspense>
      <mesh receiveShadow rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.025, 0]}>
        <planeGeometry />
        <shadowMaterial transparent opacity={0.15} />
      </mesh>
    </Canvas>
  )
}

function Track({ url, y = 2500, space = 1.8, width = 0.01, height = 0.05, obj = new THREE.Object3D(), ...props }) {
  const ref = useRef()
  // suspend-react is the library that r3f uses internally for useLoader. It caches promises and
  // integrates them with React suspense. You can use it as-is with or without r3f.
  const { gain, context, update, data } = suspend(() => createAudio(url), [url])
  useEffect(() => {
    // Connect the gain node, which plays the audio
    gain.connect(context.destination)
    // Disconnect it on unmount
    return () => gain.disconnect()
  }, [gain, context])

  useFrame((state) => {
    let avg = update()
    // Distribute the instanced planes according to the frequency daza
    for (let i = 0; i < data.length; i++) {
      obj.position.set(i * width * space - (data.length * width * space) / 2, data[i] / y, 0)
      obj.updateMatrix()
      ref.current.setMatrixAt(i, obj.matrix)
    }
    // Set the hue according to the frequency average
    ref.current.material.color.setHSL(avg / 500, 0.75, 0.75)
    ref.current.instanceMatrix.needsUpdate = true
  })
  return (
    <instancedMesh castShadow ref={ref} args={[null, null, data.length]} {...props}>
      <planeGeometry args={[width, height]} />
      <meshBasicMaterial toneMapped={false} />
    </instancedMesh>
  )
}

function Zoom({ url }) {
  // This will *not* re-create a new audio source, suspense is always cached,
  // so this will just access (or create and then cache) the source according to the url
  const { data } = suspend(() => createAudio(url), [url])
  return useFrame((state) => {
    // Set the cameras field of view according to the frequency average
    state.camera.fov = 25 - data.avg / 15
    state.camera.updateProjectionMatrix()
  })
}

async function createAudio(url) {
  // Fetch audio data and create a buffer source
  const res = await fetch(url)
  const buffer = await res.arrayBuffer()
  const context = new (window.AudioContext || window.webkitAudioContext)()
  const source = context.createBufferSource()
  source.buffer = await new Promise((res) => context.decodeAudioData(buffer, res))
  source.loop = true
  // This is why it doesn't run in Safari 🍏🐛. Start has to be called in an onClick event
  // which makes it too awkward for a little demo since you need to load the async data first
  source.start(0)
  // Create gain node and an analyser
  const gain = context.createGain()
  const analyser = context.createAnalyser()
  analyser.fftSize = 64
  source.connect(analyser)
  analyser.connect(gain)
  // The data array receive the audio frequencies
  const data = new Uint8Array(analyser.frequencyBinCount)
  return {
    context,
    source,
    gain,
    data,
    // This function gets called every frame per audio source
    update: () => {
      analyser.getByteFrequencyData(data)
      // Calculate a frequency average
      return (data.avg = data.reduce((prev, cur) => prev + cur / data.length, 0))
    },
  }
}


import React, { Suspense, useRef } from "react"
import { Canvas } from "@react-three/fiber"
import { Environment } from "@react-three/drei"
import Model from "./Model"
import Overlay from "./Overlay"

export default function App() {
  const overlay = useRef()
  const caption = useRef()
  const scroll = useRef(0)
  return (
    <>
      <Canvas shadows eventSource={document.getElementById("root")} eventPrefix="client">
        <ambientLight intensity={1} />
        <Suspense fallback={null}>
          <Model scroll={scroll} />
          <Environment preset="city" />
        </Suspense>
      </Canvas>
      <Overlay ref={overlay} caption={caption} scroll={scroll} />
    </>
  )
}


/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three"
import React, { useEffect, useRef, useState } from "react"
import { useGLTF, useAnimations, PerspectiveCamera } from "@react-three/drei"
import { useFrame } from "@react-three/fiber"

const color = new THREE.Color()

export default function Model({ scroll, ...props }) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF("/model.glb")
  const { actions } = useAnimations(animations, group)
  const [hovered, set] = useState()
  const extras = { receiveShadow: true, castShadow: true, "material-envMapIntensity": 0.2 }
  useEffect(() => void (actions["CameraAction.005"].play().paused = true), [])
  useEffect(() => {
    if (hovered) group.current.getObjectByName(hovered).material.color.set("white")
    document.body.style.cursor = hovered ? "pointer" : "auto"
  }, [hovered])
  useFrame((state) => {
    actions["CameraAction.005"].time = THREE.MathUtils.lerp(actions["CameraAction.005"].time, actions["CameraAction.005"].getClip().duration * scroll.current, 0.05)
    group.current.children[0].children.forEach((child, index) => {
      child.material.color.lerp(color.set(hovered === child.name ? "tomato" : "#202020"), hovered ? 0.1 : 0.05)
      const et = state.clock.elapsedTime
      child.position.y = Math.sin((et + index * 2000) / 2) * 1
      child.rotation.x = Math.sin((et + index * 2000) / 3) / 10
      child.rotation.y = Math.cos((et + index * 2000) / 2) / 10
      child.rotation.z = Math.sin((et + index * 2000) / 3) / 10
    })
  })

  return (
    <group ref={group} {...props} dispose={null}>
      <group
        onPointerOver={(e) => (e.stopPropagation(), set(e.object.name))}
        onPointerOut={(e) => (e.stopPropagation(), set(null))}
        position={[0.06, 4.04, 0.35]}
        scale={[0.25, 0.25, 0.25]}>
        <mesh name="Headphones" geometry={nodes.Headphones.geometry} material={materials.M_Headphone} {...extras} />
        <mesh name="Notebook" geometry={nodes.Notebook.geometry} material={materials.M_Notebook} {...extras} />
        <mesh name="Rocket003" geometry={nodes.Rocket003.geometry} material={materials.M_Rocket} {...extras} />
        <mesh name="Roundcube001" geometry={nodes.Roundcube001.geometry} material={materials.M_Roundcube} {...extras} />
        <mesh name="Table" geometry={nodes.Table.geometry} material={materials.M_Table} {...extras} />
        <mesh name="VR_Headset" geometry={nodes.VR_Headset.geometry} material={materials.M_Headset} {...extras} />
        <mesh name="Zeppelin" geometry={nodes.Zeppelin.geometry} material={materials.M_Zeppelin} v />
      </group>
      <group name="Camera" position={[-1.78, 2.04, 23.58]} rotation={[1.62, 0.01, 0.11]}>
        <PerspectiveCamera makeDefault far={100} near={0.1} fov={28} rotation={[-Math.PI / 2, 0, 0]}>
          <directionalLight
            castShadow
            position={[10, 20, 15]}
            shadow-camera-right={8}
            shadow-camera-top={8}
            shadow-camera-left={-8}
            shadow-camera-bottom={-8}
            shadow-mapSize-width={1024}
            shadow-mapSize-height={1024}
            intensity={2}
            shadow-bias={-0.0001}
          />
        </PerspectiveCamera>
      </group>
    </group>
  )
}

useGLTF.preload("/model.glb")


import React, { forwardRef } from "react"

const Overlay = forwardRef(({ caption, scroll }, ref) => (
  <div
    ref={ref}
    onScroll={(e) => {
      scroll.current = e.target.scrollTop / (e.target.scrollHeight - window.innerHeight)
      caption.current.innerText = scroll.current.toFixed(2)
    }}
    class="scroll">
    <div style={{ height: "400vh" }}>
      <div class="dot">
        <h1>headset</h1>
        Virtual reality (VR) is a simulated experience that can be similar to or completely different from the real world.
      </div>
    </div>
    <div style={{ height: "200vh" }}>
      <div class="dot">
        <h1>headphone</h1>
        Headphones are a pair of small loudspeaker drivers worn on or around the head over a user's ears.
      </div>
    </div>
    <div style={{ height: "200vh" }}>
      <div class="dot">
        <h1>rocket</h1>A rocket (from Italian: rocchetto, lit. 'bobbin/spool')[nb 1][1] is a projectile that spacecraft, aircraft or other vehicle use to obtain thrust from a
        rocket engine.
      </div>
    </div>
    <div style={{ height: "200vh" }}>
      <div class="dot">
        <h1>turbine</h1>A turbine (/ˈtɜːrbaɪn/ or /ˈtɜːrbɪn/) (from the Greek τύρβη, tyrbē, or Latin turbo, meaning vortex)[1][2] is a rotary mechanical device that extracts energy
        from a fluid flow and converts it into useful work.
      </div>
    </div>
    <div style={{ height: "200vh" }}>
      <div class="dot">
        <h1>table</h1>A table is an item of furniture with a flat top and one or more legs, used as a surface for working at, eating from or on which to place things.[1][2]
      </div>
    </div>
    <div style={{ height: "200vh" }}>
      <div class="dot">
        <h1>laptop</h1>A laptop, laptop computer, or notebook computer is a small, portable personal computer (PC) with a screen and alphanumeric keyboard.
      </div>
    </div>
    <div style={{ height: "200vh" }}>
      <div class="dot">
        <h1>zeppelin</h1>A Zeppelin is a type of rigid airship named after the German inventor Count Ferdinand von Zeppelin (German pronunciation: [ˈt͡sɛpəliːn]) who pioneered rigid
        airship development at the beginning of the 20th century.
      </div>
    </div>
    <span class="caption" ref={caption}>
      0.00
    </span>
  </div>
))

export default Overlay


@import url("https://rsms.me/inter/inter.css");

* {
  box-sizing: border-box;
}

html,
body,
#root,
.scroll {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  user-select: none;
  overflow: hidden;
}

#root {
  overflow: auto;
}

.scroll {
  position: absolute;
  top: 0;
  left: 0;
  overflow-y: auto;
  scroll-snap-type: y proximity;
}

.scroll > div {
  scroll-snap-align: start;
}

body {
  position: fixed;
  overflow: hidden;
  overscroll-behavior-y: none;
  background-color: #101010;
  background: radial-gradient(circle at bottom center, #212121 0%, #101010 80%);
  font-family: "Inter var", sans-serif;
  -webkit-font-smoothing: antialiased;
}

.caption {
  pointer-events: none;
  position: fixed;
  top: 0;
  right: 0;
  margin: 80px;
  color: white;
  font-size: 8em;
  font-weight: 100;
  line-height: 1em;
  font-variant-numeric: tabular-nums;
  -webkit-font-smoothing: auto;
}

.dot {
  pointer-events: none;
  position: sticky;
  top: 0px;
  display: inline-block;
  max-width: 600px;
  padding: 0;
  padding: 80px;
  color: #a0a0a0;
  line-height: 1.6em;
  font-size: 15px;
  letter-spacing: 1.5px;
}

.dot > h1 {
  -webkit-font-smoothing: auto;
  pointer-events: none;
  color: white;
  font-size: 5em;
  font-weight: 100;
  line-height: 1em;
  margin: 0;
  margin-bottom: 0.25em;
}

@media only screen and (max-width: 1000px) {
  .caption {
    font-size: 4em;
  }
}

@media only screen and (max-width: 800px) {
  .caption {
    font-size: 3em;
  }
  .dot > h1 {
    font-size: 3em;
  }
}

@media only screen and (max-width: 700px) {
  .caption {
    font-size: 2em;
  }
  .dot > h1 {
    font-size: 3em;
  }
}

@media only screen and (max-width: 600px) {
  .caption {
    font-size: 1em;
  }
  .dot > h1 {
    font-size: 3em;
  }
}
c

import { useRef, useMemo } from "react"
import { Canvas, useFrame } from "@react-three/fiber"
import { SoftShadows } from "@react-three/drei"
import { useControls } from "leva"
import { Perf } from "r3f-perf"

const easeInOutCubic = (t) => (t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1)
function Sphere({ position = [0, 0, 0], ...props }) {
  const ref = useRef()
  const factor = useMemo(() => 0.5 + Math.random(), [])
  useFrame((state) => {
    const t = easeInOutCubic((1 + Math.sin(state.clock.getElapsedTime() * factor)) / 2)
    ref.current.position.y = position[1] + t * 4
    ref.current.scale.y = 1 + t * 3
  })
  return (
    <mesh ref={ref} position={position} {...props} castShadow receiveShadow>
      <sphereGeometry args={[0.5, 32, 32]} />
      <meshLambertMaterial color="white" roughness={0} metalness={0.1} />
    </mesh>
  )
}

function Spheres({ number = 20 }) {
  const ref = useRef()
  const positions = useMemo(() => [...new Array(number)].map(() => [3 - Math.random() * 6, Math.random() * 4, 3 - Math.random() * 6]), [])
  useFrame((state) => (ref.current.rotation.y = Math.sin(state.clock.getElapsedTime() / 2) * Math.PI))
  return (
    <group ref={ref}>
      {positions.map((pos, index) => (
        <Sphere key={index} position={pos} />
      ))}
    </group>
  )
}

export default function App() {
  const { enabled, ...config } = useControls({
    enabled: true,
    size: { value: 25, min: 0, max: 100 },
    focus: { value: 0, min: 0, max: 2 },
    samples: { value: 10, min: 1, max: 20, step: 1 }
  })
  return (
    <Canvas shadows camera={{ position: [-5, 2, 10], fov: 60 }}>
      {enabled && <SoftShadows {...config} />}
      <fog attach="fog" args={["white", 0, 40]} />
      <ambientLight intensity={0.5} />
      <directionalLight castShadow position={[2.5, 8, 5]} intensity={1.5} shadow-mapSize={1024}>
        <orthographicCamera attach="shadow-camera" args={[-10, 10, -10, 10, 0.1, 50]} />
      </directionalLight>
      <pointLight position={[-10, 0, -20]} color="white" intensity={1} />
      <pointLight position={[0, -10, 0]} intensity={1} />
      <group position={[0, -3.5, 0]}>
        <mesh receiveShadow castShadow>
          <boxGeometry args={[4, 1, 1]} />
          <meshLambertMaterial />
        </mesh>
        <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.5, 0]} receiveShadow>
          <planeGeometry args={[100, 100]} />
          <shadowMaterial transparent opacity={0.4} />
        </mesh>
        <Spheres />
      </group>
      {/*<Perf position="top-left" />*/}
    </Canvas>
  )
}


import * as THREE from 'three'
import React, { Suspense, useEffect, useRef, useState, useCallback, useLayoutEffect } from 'react'
import { Canvas, useThree, useFrame, useLoader } from '@react-three/fiber'
import { Flex, Box, useFlexSize } from '@react-three/flex'
import { Loader, Line, useAspect } from '@react-three/drei'
import Effects from './components/Effects'
import Text from './components/Text'
import Geo from './components/Geo'
import state from './state'

function HeightReporter({ onReflow }) {
  const size = useFlexSize()
  useLayoutEffect(() => onReflow && onReflow(...size), [onReflow, size])
  return null
}

function Page({ text, tag, images, textScaleFactor, onReflow, left = false }) {
  const textures = useLoader(THREE.TextureLoader, images)
  const { viewport } = useThree()
  const boxProps = {
    centerAnchor: true,
    grow: 1,
    marginTop: 1,
    marginLeft: left * 1,
    marginRight: !left * 1,
    width: 'auto',
    height: 'auto',
    minWidth: 3,
    minHeight: 3,
    maxWidth: 6,
    maxHeight: 6,
  }
  return (
    <Box dir="column" align={left ? 'flex-start' : 'flex-end'} justify="flex-start" width="100%" height="auto" minHeight="100%">
      <HeightReporter onReflow={onReflow} />
      <Box dir="row" width="100%" height="auto" justify={left ? 'flex-end' : 'flex-start'} margin={0} grow={1} wrap="wrap">
        {textures.map((texture, index) => (
          <Box key={index} {...boxProps}>
            {(width, height) => (
              <mesh>
                <planeBufferGeometry args={[width, height]} />
                <meshBasicMaterial map={texture} toneMapped={false} />
              </mesh>
            )}
          </Box>
        ))}
      </Box>
      <Box marginLeft={1.5} marginRight={1.5} marginTop={2}>
        <Text position={[left ? 1 : -1, 0.5, 1]} fontSize={textScaleFactor} lineHeight={1} letterSpacing={-0.05} maxWidth={(viewport.width / 4) * 3}>
          {tag}
          <meshBasicMaterial color="#cccccc" toneMapped={false} />
        </Text>
      </Box>
      <Box marginLeft={left ? 1.5 : 1} marginRight={left ? 1 : 1.5} marginBottom={1}>
        <Text
          bold
          position-z={0.5}
          textAlign={left ? 'left' : 'right'}
          fontSize={1.5 * textScaleFactor}
          lineHeight={1}
          letterSpacing={-0.05}
          color="black"
          maxWidth={(viewport.width / 4) * 3}>
          {text}
        </Text>
      </Box>
    </Box>
  )
}

function Layercard({ depth, boxWidth, boxHeight, text, textColor, color, map, textScaleFactor }) {
  const ref = useRef()
  const { viewport, size } = useThree()
  const pageLerp = useRef(state.top / size.height)
  useFrame(() => {
    const page = (pageLerp.current = THREE.MathUtils.lerp(pageLerp.current, state.top / size.height, 0.15))
    if (depth >= 0) ref.current.opacity = page < state.threshold * 1.7 ? 1 : 1 - (page - state.threshold * 1.7)
  })
  return (
    <>
      <mesh position={[boxWidth / 2, -boxHeight / 2, depth]}>
        <planeBufferGeometry args={[boxWidth, boxHeight]} />
        <meshBasicMaterial ref={ref} color={color} map={map} toneMapped={false} transparent opacity={1} />
      </mesh>
      <Text
        bold
        position={[boxWidth / 2, -boxHeight / 2, depth + 1.5]}
        maxWidth={(viewport.width / 4) * 1}
        anchorX="center"
        anchorY="middle"
        fontSize={0.6 * textScaleFactor}
        lineHeight={1}
        letterSpacing={-0.05}
        color={textColor}>
        {text}
      </Text>
    </>
  )
}

function Content({ onReflow }) {
  const group = useRef()
  const { viewport, size } = useThree()
  const [bW, bH] = useAspect(1920, 1920, 0.5)
  const texture = useLoader(THREE.TextureLoader, state.depthbox[0].image)
  const vec = new THREE.Vector3()
  const pageLerp = useRef(state.top / size.height)
  useFrame(() => {
    const page = (pageLerp.current = THREE.MathUtils.lerp(pageLerp.current, state.top / size.height, 0.15))
    const y = page * viewport.height
    const sticky = state.threshold * viewport.height
    group.current.position.lerp(vec.set(0, page < state.threshold ? y : sticky, page < state.threshold ? 0 : page * 1.25), 0.15)
  })
  const handleReflow = useCallback((w, h) => onReflow((state.pages = h / viewport.height + 5.5)), [onReflow, viewport.height])
  const sizesRef = useRef([])
  const scale = Math.min(1, viewport.width / 16)
  return (
    <group ref={group}>
      <Flex dir="column" position={[-viewport.width / 2, viewport.height / 2, 0]} size={[viewport.width, viewport.height, 0]} onReflow={handleReflow}>
        {state.content.map((props, index) => (
          <Page
            key={index}
            left={!(index % 2)}
            textScaleFactor={scale}
            onReflow={(w, h) => {
              sizesRef.current[index] = h
              state.threshold = Math.max(4, (4 / (15.8 * 3)) * sizesRef.current.reduce((acc, e) => acc + e, 0))
            }}
            {...props}
          />
        ))}
        <Box dir="row" width="100%" height="100%" align="center" justify="center">
          <Box centerAnchor>
            {state.lines.map((props, index) => (
              <Line key={index} {...props} />
            ))}
            <Text
              bold
              position-z={0.5}
              anchorX="center"
              anchorY="middle"
              fontSize={1.5 * scale}
              lineHeight={1}
              letterSpacing={-0.05}
              color="black"
              maxWidth={(viewport.width / 4) * 3}>
              {state.depthbox[0].text}
            </Text>
          </Box>
        </Box>
        <Box dir="row" width="100%" height="100%" align="center" justify="center">
          <Box>
            <Layercard {...state.depthbox[0]} text={state.depthbox[1].text} boxWidth={bW} boxHeight={bH} map={texture} textScaleFactor={scale} />
            <Geo position={[bW / 2, -bH / 2, state.depthbox[1].depth]} />
          </Box>
        </Box>
      </Flex>
    </group>
  )
}

export default function App() {
  const scrollArea = useRef()
  const onScroll = (e) => (state.top = e.target.scrollTop)
  useEffect(() => void onScroll({ target: scrollArea.current }), [])
  const [pages, setPages] = useState(0)
  return (
    <>
      <Canvas
        shadows
        raycaster={{ enabled: false }}
        dpr={[1, 2]}
        camera={{ position: [0, 0, 10], far: 1000 }}
        gl={{ powerPreference: 'high-performance', alpha: false, antialias: false, stencil: false, depth: false }}
        onCreated={({ gl }) => gl.setClearColor('#f5f5f5')}>
        <pointLight position={[-10, -10, -10]} intensity={1} />
        <ambientLight intensity={0.4} />
        <spotLight
          castShadow
          angle={0.3}
          penumbra={1}
          position={[0, 10, 20]}
          intensity={5}
          shadow-mapSize-width={1024}
          shadow-mapSize-height={1024}
        />
        <Suspense fallback={null}>
          <Content onReflow={setPages} />
        </Suspense>
        <Effects />
      </Canvas>
      <div
        className="scrollArea"
        ref={scrollArea}
        onScroll={onScroll}
        onPointerMove={(e) => (state.mouse = [(e.clientX / window.innerWidth) * 2 - 1, (e.clientY / window.innerHeight) * 2 - 1])}>
        <div style={{ height: `${pages * 100}vh` }} />
      </div>
      <Loader />
    </>
  )
}


const state = {
  top: 0,
  pages: 0,
  threshold: 4,
  mouse: [0, 0],
  content: [
    {
      tag: '00',
      text: `The Bacchic\nand Dionysiac\nRites`,
      images: ['/images/BH41NVu.jpg', '/images/fBoIJLX.jpg', '/images/04zTfWB.jpg'],
    },
    { tag: '01', text: `The Elysian\nMysteries`, images: ['/images/c4cA8UN.jpg', '/images/ajQ73ol.jpg', '/images/gZOmLNU.jpg'] },
    { tag: '02', text: `The Hiramic\nLegend`, images: ['/images/mbFIW1b.jpg', '/images/mlDUVig.jpg', '/images/gwuZrgo.jpg'] },
  ],
  depthbox: [
    {
      depth: 0,
      color: '#cccccc',
      textColor: '#ffffff',
      text: 'In a void,\nno one could say\nwhy a thing\nonce set in motion\nshould stop anywhere.',
      image: '/images/cAKwexj.jpg',
    },
    {
      depth: -5,
      textColor: '#272727',
      text: 'For why should it stop\nhere rather than here?\nSo that a thing\nwill either be at rest\nor must be moved\nad infinitum.',
      image: '/images/04zTfWB.jpg',
    },
  ],
  lines: [
    { points: [[-20, 0, 0], [-9, 0, 0]], color: "black", lineWidth: 0.5 },
    { points: [[20, 0, 0], [9, 0, 0]], color: "black", lineWidth: 0.5 },
  ]
}

export default state

html,
body,
#root {
  margin: 0;
  padding: 0;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
  color: white;
}

body {
  cursor: url('/images/ellipse.svg'), pointer;
  cursor: -webkit-image-set(url('/images/ellipse.svg') 1x, url('/images/ellipse.svg') 2x), pointer;
  background: #272727;
  font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', 'Helvetica Neue', Helvetica, Arial, Roboto,
    Ubuntu, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';
}

.scrollArea {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  overflow: auto;
}

.loading {
  position: absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  background: #171717;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.loading-bar-container {
  width: 100px;
  height: 3px;
  background: #272727;
}

.loading-bar {
  height: 3px;
  background: white;
}

.loading-data {
  display: inline-block;
  position: relative;
  font-variant-numeric: tabular-nums;
  margin-top: 0.8em;
  color: #f0f0f0;
  font-size: 0.6em;
}


import React from 'react'
import { useReflow } from '@react-three/flex'
import { Text as TextImpl } from '@react-three/drei'

export default function Text({ bold = false, anchorX = 'left', anchorY = 'top', textAlign = 'left', ...props }) {
  const reflow = useReflow()
  const font = bold ? '/Inter-Bold.woff' : '/Inter-Regular.woff'
  return <TextImpl anchorX={anchorX} anchorY={anchorY} textAlign={textAlign} font={font} onSync={reflow} {...props} />
}


import * as THREE from 'three'
import React, { useRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { useGLTF, MeshDistortMaterial, Shadow } from '@react-three/drei'
import Text from './Text'
import state from '../state'

export default function Model(props) {
  const group = useRef()
  const shadow = useRef()
  const { nodes } = useGLTF('/geo.min.glb', true)
  useFrame(({ clock }) => {
    const t = (1 + Math.sin(clock.getElapsedTime() * 1.5)) / 2
    group.current.position.y = t / 3
    shadow.current.scale.y = shadow.current.scale.z = 1 + t
    shadow.current.scale.x = (1 + t) * 1.25
    group.current.rotation.x = group.current.rotation.z += 0.005
    group.current.position.x = THREE.MathUtils.lerp(group.current.position.x, state.mouse[0] / 2, 0.05)
    group.current.position.z = THREE.MathUtils.lerp(group.current.position.z, state.mouse[1] / 4, 0.03)
  })
  return (
    <group {...props} dispose={null}>
      <group ref={group}>
        <mesh geometry={nodes.geo.geometry} castShadow receiveShadow>
          <MeshDistortMaterial color="#ffffff" flatShading roughness={1} metalness={0.5} factor={15} speed={5} />
        </mesh>
        <mesh geometry={nodes.geo.geometry}>
          <meshBasicMaterial wireframe />
        </mesh>
      </group>
      <group position={[1.25, -0.5, 0]}>
        <Text position={[0, 0, 0]} fontSize={0.07} lineHeight={1} letterSpacing={-0.05}>
          03
          <meshBasicMaterial color="#cccccc" toneMapped={false} />
        </Text>
        <Text bold position={[-0.01, -0.1, 0]} fontSize={0.1} lineHeight={1} letterSpacing={-0.05} color="black">
          {`Poimandres,\nThe vision of Hermes`}
        </Text>
      </group>
      <Shadow ref={shadow} opacity={0.3} rotation-x={-Math.PI / 2} position={[0, -1.51, 0]} />
    </group>
  )
}


import * as THREE from 'three'
import React, { useEffect, useRef } from 'react'
import { extend, useThree, useFrame } from '@react-three/fiber'
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer'
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass'
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass'
import { GammaCorrectionShader } from 'three/examples/jsm/shaders/GammaCorrectionShader'
import { WaterPass } from './shaders/WaterPass'
import state from '../state'

extend({ EffectComposer, ShaderPass, RenderPass, WaterPass })

export default function Effects() {
  const composer = useRef()
  const water = useRef()
  const { gl, size, camera, scene } = useThree()
  useEffect(() => void composer.current.setSize(size.width, size.height), [size])
  let last = state.top
  let index = 0
  let values = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  useFrame(() => {
    const { top } = state
    values[index] = Math.abs(top - last)
    const normalize = values.reduce((a, b) => a + b) / values.length
    water.current.factor = THREE.MathUtils.lerp(water.current.factor, normalize / 20, 0.1)
    last = top
    index = (index + 1) % 10
    gl.autoClear = true
    composer.current.render()
  }, 1)
  return (
    <effectComposer ref={composer} args={[gl]}>
      <renderPass attachArray="passes" scene={scene} camera={camera} />
      <waterPass attachArray="passes" ref={water} />
      <shaderPass attachArray="passes" args={[GammaCorrectionShader]} />
    </effectComposer>
  )
}


/**  @author vergil Wang */

import * as THREE from 'three'
import { Pass } from 'three/examples/jsm/postprocessing/Pass'

const WaterShader = {
  uniforms: {
    byp: { value: 0 },
    tex: { type: 't', value: null },
    time: { type: 'f', value: 0.0 },
    factor: { type: 'f', value: 0.0 },
    resolution: { type: 'v2', value: null },
  },
  vertexShader: `varying vec2 vUv;
    void main(){  
      vUv = uv; 
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition;
    }`,
  fragmentShader: `
  uniform int byp;
    uniform float time;
    uniform float factor;
    uniform vec2 resolution;
    uniform sampler2D tex;
    varying vec2 vUv;
    void main() { 
      if (byp<1) {
        vec2 uv = vUv;
        float frequency = 4.0;
        float amplitude = 0.015 * factor;
        float x = uv.y * frequency + time * .7; 
        float y = uv.x * frequency + time * .3;
        uv.x += .5 * amplitude * cos(x);
        uv.y += .5 * amplitude * sin(y);
        vec4 rgba = texture2D(tex, uv);
        gl_FragColor = rgba;
      } else {
        gl_FragColor = texture2D(tex, vUv);
      }
    }`,
}

class WaterPass extends Pass {
  constructor(dt_size) {
    super()
    this.uniforms = THREE.UniformsUtils.clone(WaterShader.uniforms)
    if (dt_size === undefined) dt_size = 64
    this.uniforms['resolution'].value = new THREE.Vector2(dt_size, dt_size)
    this.material = new THREE.ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: WaterShader.vertexShader,
      fragmentShader: WaterShader.fragmentShader,
    })
    this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1)
    this.scene = new THREE.Scene()
    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null)
    this.quad.frustumCulled = false // Avoid getting clipped
    this.scene.add(this.quad)
    this.factor = 0
    this.time = 0
  }

  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
    const factor = Math.max(0, this.factor)
    this.uniforms['byp'].value = factor ? 0 : 1
    this.uniforms['tex'].value = readBuffer.texture
    this.uniforms['time'].value = this.time
    this.uniforms['factor'].value = this.factor
    this.time += 0.01
    this.quad.material = this.material
    if (this.renderToScreen) {
      renderer.setRenderTarget(null)
      renderer.render(this.scene, this.camera)
    } else {
      renderer.setRenderTarget(writeBuffer)
      if (this.clear) renderer.clear()
      renderer.render(this.scene, this.camera)
    }
  }
}

export { WaterPass }



import * as THREE from 'three'
import { Canvas, useThree, useFrame } from '@react-three/fiber'
import { useGLTF, Edges } from '@react-three/drei'
import { Physics, useCompoundBody, useCylinder } from '@react-three/cannon'
import { LayerMaterial, Depth, Fresnel } from 'lamina'

const vec = new THREE.Vector3()
const white = new THREE.MeshBasicMaterial({ color: '#fefefe', toneMapped: false })
const black = new THREE.MeshBasicMaterial({ color: 'black', toneMapped: false })
const cylinder = new THREE.CylinderGeometry(0.6, 0.6, 0.5, 3)

export const App = ({ amount = 12 }) => (
  <Canvas dpr={[1, 2]} camera={{ position: [0, 0, 5], fov: 50 }}>
    <Physics gravity={[0, 1, 0]}>
      {Array.from({ length: amount }, (_, i) => {
        const El = i % 2 ? Pmndrs : Vercel
        return <El key={i} mass={4} angularDamping={0.4} linearDamping={0.8} position={[Math.random(), Math.random(), Math.random()]} />
      })}
      <Cursor mass={15} angularDamping={0.5} linearDamping={0.5} position={[0, 0, 10]} />
    </Physics>
  </Canvas>
)

function Vercel(props) {
  const [ref, api] = useCylinder(() => ({ args: [0.6, 0.6, 0.5, 3], ...props }))
  useFrame(() => api.applyForce(vec.setFromMatrixPosition(ref.current.matrix).normalize().multiplyScalar(-40).toArray(), [0, 0, 0]))
  return (
    <mesh ref={ref} geometry={cylinder} material={white}>
      <Edges material={black} />
    </mesh>
  )
}

function Pmndrs(props) {
  const { nodes } = useGLTF('/pmndrs.glb')
  const [ref, api] = useCompoundBody(() => ({
    ...props,
    shapes: [
      { type: 'Box', args: [0.65, 0.65, 0.5], position: [0.18, 0.18, 0] },
      { type: 'Box', args: [0.3, 0.3, 0.5], position: [-0.35, 0, 0] },
      { type: 'Box', args: [0.3, 0.3, 0.5], position: [0, -0.35, 0] }
    ]
  }))
  useFrame(() => api.applyForce(vec.setFromMatrixPosition(ref.current.matrix).normalize().multiplyScalar(-40).toArray(), [0, 0, 0]))
  return (
    <group ref={ref}>
      <mesh scale={[0.188, 0.188, 0.97]} position={[-0.02, -0.5, 0.022]} geometry={nodes.logo.geometry} material={white}>
        <Edges scale={1.005} material={black} />
      </mesh>
    </group>
  )
}

function Cursor({ speed = 10, gradient = 0.7, ...props }) {
  const { nodes } = useGLTF('/cursor.glb')
  const viewport = useThree((state) => state.viewport)
  const [ref, api] = useCompoundBody(() => ({
    ...props,
    shapes: [
      { type: 'Cylinder', args: [0.6, 0.6, 0.5, 3], position: [0, 0.2, 0], rotation: [Math.PI / 2, Math.PI, 0] },
      { type: 'Box', args: [0.25, 1, 0.3], position: [0, -0.45, 0] }
    ]
  }))
  useFrame((state) => {
    vec.setFromMatrixPosition(ref.current.matrix)
    api.velocity.set(((state.mouse.x * viewport.width) / 2 - vec.x) * speed, ((state.mouse.y * viewport.height) / 2 - vec.y) * speed, -vec.z)
  })
  return (
    <group ref={ref}>
      <mesh scale={[0.5, 1, 0.55]} rotation={[0, Math.PI / 2, 0]} geometry={nodes.Cube.geometry}>
        <LayerMaterial toneMapped={false}>
          <Depth colorA="#ff0080" colorB="black" alpha={1} mode="normal" near={0.5 * gradient} far={0.5} origin={[0, 0, 0]} />
          <Depth colorA="blue" colorB="#f7b955" alpha={1} mode="add" near={2 * gradient} far={2} origin={[1, 1, 1]} />
          <Depth colorA="green" colorB="#f7b955" alpha={1} mode="add" near={3 * gradient} far={3} origin={[-1, -1, -1]} />
          <Depth colorA="white" colorB="red" alpha={1} mode="overlay" near={1.5 * gradient} far={1.5} origin={[1, -1, -1]} />
          <Fresnel mode="add" color="white" intensity={0.75} power={2} bias={0.05} />
        </LayerMaterial>
        <Edges scale={1.003} color="white" />
      </mesh>
    </group>
  )
}

import * as THREE from 'three'
import { useRef, useState, useMemo, useEffect, Suspense } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { Billboard, Text, TrackballControls } from '@react-three/drei'
import { generate } from 'random-words'

function Word({ children, ...props }) {
  const color = new THREE.Color()
  const fontProps = { font: '/Inter-Bold.woff', fontSize: 2.5, letterSpacing: -0.05, lineHeight: 1, 'material-toneMapped': false }
  const ref = useRef()
  const [hovered, setHovered] = useState(false)
  const over = (e) => (e.stopPropagation(), setHovered(true))
  const out = () => setHovered(false)
  // Change the mouse cursor on hover¨
  useEffect(() => {
    if (hovered) document.body.style.cursor = 'pointer'
    return () => (document.body.style.cursor = 'auto')
  }, [hovered])
  // Tie component to the render-loop
  useFrame(({ camera }) => {
    ref.current.material.color.lerp(color.set(hovered ? '#fa2720' : 'white'), 0.1)
  })
  return (
    <Billboard {...props}>
      <Text ref={ref} onPointerOver={over} onPointerOut={out} onClick={() => console.log('clicked')} {...fontProps} children={children} />
    </Billboard>
  )
}

function Cloud({ count = 4, radius = 20 }) {
  // Create a count x count random words with spherical distribution
  const words = useMemo(() => {
    const temp = []
    const spherical = new THREE.Spherical()
    const phiSpan = Math.PI / (count + 1)
    const thetaSpan = (Math.PI * 2) / count
    for (let i = 1; i < count + 1; i++)
      for (let j = 0; j < count; j++) temp.push([new THREE.Vector3().setFromSpherical(spherical.set(radius, phiSpan * i, thetaSpan * j)), generate()])
    return temp
  }, [count, radius])
  return words.map(([pos, word], index) => <Word key={index} position={pos} children={word} />)
}

export default function App() {
  return (
    <Canvas dpr={[1, 2]} camera={{ position: [0, 0, 35], fov: 90 }}>
      <fog attach="fog" args={['#202025', 0, 80]} />
      <Suspense fallback={null}>
        <group rotation={[10, 10.5, 10]}>
          <Cloud count={8} radius={20} />
        </group>
      </Suspense>
      <TrackballControls />
    </Canvas>
  )
}

import * as THREE from 'three'
import React, { useRef, useMemo, useState, useEffect } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { EffectComposer, N8AO, Bloom } from '@react-three/postprocessing'
import niceColors from 'nice-color-palettes'

const tempObject = new THREE.Object3D()
const tempColor = new THREE.Color()
const data = Array.from({ length: 1000 }, () => ({ color: niceColors[17][Math.floor(Math.random() * 5)], scale: 1 }))

export function App() {
  return (
    <Canvas gl={{ antialias: false }} camera={{ position: [0, 0, 15], near: 5, far: 20 }}>
      <color attach="background" args={['#f0f0f0']} />
      <Boxes />
      <EffectComposer disableNormalPass>
        <N8AO aoRadius={0.5} intensity={1} />
        <Bloom luminanceThreshold={1} intensity={0.5} levels={9} mipmapBlur />
      </EffectComposer>
    </Canvas>
  )
}

function Boxes() {
  const [hovered, set] = useState()
  const colorArray = useMemo(() => Float32Array.from(new Array(1000).fill().flatMap((_, i) => tempColor.set(data[i].color).toArray())), [])
  const meshRef = useRef()
  const prevRef = useRef()
  useEffect(() => void (prevRef.current = hovered), [hovered])

  useFrame((state) => {
    const time = state.clock.getElapsedTime()
    meshRef.current.rotation.x = Math.sin(time / 4)
    meshRef.current.rotation.y = Math.sin(time / 2)
    let i = 0
    for (let x = 0; x < 10; x++)
      for (let y = 0; y < 10; y++)
        for (let z = 0; z < 10; z++) {
          const id = i++
          tempObject.position.set(5 - x, 5 - y, 5 - z)
          tempObject.rotation.y = Math.sin(x / 4 + time) + Math.sin(y / 4 + time) + Math.sin(z / 4 + time)
          tempObject.rotation.z = tempObject.rotation.y * 2
          if (hovered !== prevRef.Current) {
            ;(id === hovered ? tempColor.setRGB(10, 10, 10) : tempColor.set(data[id].color)).toArray(colorArray, id * 3)
            meshRef.current.geometry.attributes.color.needsUpdate = true
          }
          tempObject.updateMatrix()
          meshRef.current.setMatrixAt(id, tempObject.matrix)
        }
    meshRef.current.instanceMatrix.needsUpdate = true
  })
  return (
    <instancedMesh
      ref={meshRef}
      args={[null, null, 1000]}
      onPointerMove={(e) => (e.stopPropagation(), set(e.instanceId))}
      onPointerOut={(e) => set(undefined)}>
      <boxGeometry args={[0.6, 0.6, 0.6]}>
        <instancedBufferAttribute attach="attributes-color" args={[colorArray, 3]} />
      </boxGeometry>
      <meshBasicMaterial toneMapped={false} vertexColors />
    </instancedMesh>
  )
}


import { useRef } from 'react'
import { Canvas, useFrame, useThree } from '@react-three/fiber'
import { WaveMaterial } from './WaveMaterial'
import { easing } from 'maath'

function ShaderPlane() {
  const ref = useRef()
  const { viewport, size } = useThree()
  useFrame((state, delta) => {
    ref.current.time += delta
    easing.damp3(ref.current.pointer, state.pointer, 0.2, delta)
  })
  return (
    <mesh scale={[viewport.width, viewport.height, 1]}>
      <planeGeometry />
      <waveMaterial ref={ref} key={WaveMaterial.key} resolution={[size.width * viewport.dpr, size.height * viewport.dpr]} />
    </mesh>
  )
}

export default function App() {
  return (
    <Canvas>
      <ShaderPlane />
    </Canvas>
  )
}


import * as THREE from 'three'
import { extend } from '@react-three/fiber'
import { shaderMaterial } from '@react-three/drei'

// Tutorial: https://www.youtube.com/watch?v=f4s1h2YETNY
const WaveMaterial = shaderMaterial(
  {
    time: 0,
    resolution: new THREE.Vector2(),
    pointer: new THREE.Vector2()
  },
  /*glsl*/ `
      varying vec2 vUv;
      void main() {
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
        vec4 viewPosition = viewMatrix * modelPosition;
        vec4 projectionPosition = projectionMatrix * viewPosition;
        gl_Position = projectionPosition;
        vUv = uv;
      }`,
  /*glsl*/ `
      uniform float time;
      uniform vec2 resolution;
      uniform vec2 pointer;
      varying vec2 vUv;      

      vec3 palette(float t) {
        vec3 a = vec3(0.5, 0.5, 0.5);
        vec3 b = vec3(0.5, 0.5, 0.5);
        vec3 c = vec3(1.0, 1.0, 1.0);
        vec3 d = vec3(0.263, 0.416, 0.557);
        return a + b * cos(6.28318 * (c * t + d));
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / resolution.y;      
        vec2 uv0 = uv;
        vec3 finalColor = vec3(0.0);
        uv = fract(uv * 1.5) - 0.5;     
        uv = sin(uv * 0.5) - pointer;     
        float d = length(uv) * exp(-length(uv0));
        vec3 col = palette(length(uv0) + time * 0.4);
        d = sin(d * 8.0 + time) / 8.0;
        d = abs(d);
        d = pow(0.02 / d, 2.0);
        finalColor += col * d;
        gl_FragColor = vec4(finalColor, 1.0);   
      }`
)

extend({ WaveMaterial })

export { WaveMaterial }



import { useRef } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { Bvh, OrbitControls, useHelper } from '@react-three/drei'
import { MeshBVHVisualizer } from 'three-mesh-bvh'
import { Perf } from 'r3f-perf'
import { useControls } from 'leva'
import { Rays } from './Rays'

function Torus(props) {
  const mesh = useRef()
  const sphere = useRef()
  useHelper(mesh, MeshBVHVisualizer)
  useFrame((state, delta) => (mesh.current.rotation.x = mesh.current.rotation.y += delta))
  return (
    <mesh
      ref={mesh}
      {...props}
      onPointerMove={(e) => sphere.current.position.copy(mesh.current.worldToLocal(e.point))}
      onPointerOver={() => (sphere.current.visible = true)}
      onPointerOut={() => (sphere.current.visible = false)}>
      <torusKnotGeometry args={[1, 0.4, 200, 50]} />
      <meshNormalMaterial />
      <mesh raycast={() => null} ref={sphere} visible={false}>
        <sphereGeometry args={[0.2]} />
        <meshBasicMaterial color="orange" toneMapped={false} />
      </mesh>
    </mesh>
  )
}

export default function App() {
  const { enabled } = useControls({ enabled: true })
  return (
    <Canvas camera-position-z={40} camera-far={100}>
      <color attach="background" args={['#202025']} />
      <Perf position="bottom-right" style={{ margin: 10 }} />
      {/** Anything that Bvh wraps is getting three-mesh-bvh's acceleratedRaycast.
           Click on "enabled" to see what normal raycast performance in threejs looks like. */}
      <Bvh firstHitOnly enabled={enabled}>
        <Rays>
          <Torus />
        </Rays>
      </Bvh>
      <OrbitControls />
    </Canvas>
  )
}






